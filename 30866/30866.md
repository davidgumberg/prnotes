# [#30866](https://github.com/bitcoin/bitcoin/pull/30866) descriptor: Add proper Clone function to miniscript::Node

_All code comments in `[]` are my own._

## Background

Issue [#30864](https://github.com/bitcoin/bitcoin/issues/30864)

`DescriptorImpl`, the abstract base class for every class of Descriptor
(`PKDescriptor`, `WPKHDescriptor`, `MultisigDescriptor`, etc....) defines a
`Clone()` function with the following signature:

```cpp
    virtual std::unique_ptr<DescriptorImpl> Clone() const = 0;
```

A comment above in the same file for the `PubkeyProvider` interface indicates
that `Clone()` is expected to return a pointer to a deep copy.[^1]

I want to look at a simple example of another Descriptor class' `Clone()`,
`class PKDescriptor`, I've editorialized some appropriate context in:


```cpp
class DescriptorImpl : public Descriptor
{
protected:
    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;
// [...]
};

class PKDescriptor final : public DescriptorImpl
{
private:
    const bool m_xonly;
// [...]
public:
    // [...]
    std::unique_ptr<DescriptorImpl> Clone() const override
    {
        // [ m_pubkey_args is a vector of unique_ptr's, we use
        //   PubkeyProvider::Clone() to get a unique_ptr to a deep copy of the
        //   provider. ]
        return std::make_unique<PKDescriptor>(m_pubkey_args.at(0)->Clone(), m_xonly);
    }
};
```

The only use of `DescriptorImpl::Clone()` appears to be in
`std::vector<std::unique_ptr<DescriptorImpl>> ParseScript()` which parses a span
of bytes into DescriptorImpl objects given some context (`ParseScriptContext`),
e.g. when parsing begins (in `std::vector<std::unique_ptr<Descriptor>> Parse()`)
`ParseScriptContext::TOP` is used for parsing the top level expression that we start
with, ParseScript() is invoked with other contexts recursively from within
ParseScriptContext, presumably when some subexpression is encountered.

`ParseScript()` is just a massive branch of `if` statements like:

```cpp
   if (Func("pk", expr)) { // [...] }
   if ((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH) && Func("pkh", expr)) { // [...] }
   } else if (ctx != ParseScriptContext::P2TR && Func("pkh", expr)) { // [...] }
   if (ctx == ParseScriptContext::TOP && Func("combo", expr)) { // [...] }
   if (((ctx == ParseScriptContext::TOP || ctx == ParseScriptContext::P2SH || ctx == ParseScriptContext::P2WSH) && (multi || sortedmulti)) || ) { // [...] }
```

`DescriptorImpl::Clone()` is used in the toplevel taproot branch (`if (ctx == ParseScriptContext::TOP && Func("tr", expr))`).

Let's look at the branch where it's used: 

```cpp
    // [ heavily editorialized to highlight the parts I think are most relevant ]
    if (ctx == ParseScriptContext::TOP && Func("tr", expr)) {
        auto arg = Expr(expr);
        // [ The internal_key of a TR descriptor is also subject to the rules of
        //   BIP 389 ]
        auto internal_keys = ParsePubkey(key_exp_index, arg, ParseScriptContext::P2TR, out, error);
        // [ Keep track of how many multipaths are in the 
        size_t max_providers_len = internal_keys.size();
        std::vector<std::vector<std::unique_ptr<DescriptorImpl>>> subscripts; //!< list of multipath expanded script subexpressions
        if (expr.size()) {
            std::vector<bool> branches;
            // Loop over all provided scripts. In every iteration exactly one script will be processed.
            do {
                // First process all open braces.
                while (Const("{", expr)) {
                    branches.push_back(false); // new left branch
                }
                // Process the actual script expression.
                auto sarg = Expr(expr);

                // [ The `subscripts` vector is extended by recursively calling
                //   ParseScript() on each expression inside of the TR(..)
                //   expression and appending the return value to the back of
                //   subscripts. ]
                subscripts.emplace_back(ParseScript(key_exp_index, sarg, ParseScriptContext::P2TR, out, error));
                // [ Keep track of the longest vector of descriptors returned by
                //   ParseScript, we expect all subscripts to either be this
                //   size or of size 1 ]
                max_providers_len = std::max(max_providers_len, subscripts.back().size());
            } while (branches.size());
        }

        // Make sure all vecs are of the same length, or exactly length 1
        // For length 1 vectors, clone subdescs until vector is the same length
        for (auto& vec : subscripts) {
            // [ If it's 1 long, no multipath and replicate it until we have max
            //   tuple size many of them. ]
            if (vec.size() == 1) {
                for (size_t i = 1; i < max_providers_len; ++i) {
                    vec.emplace_back(vec.at(0)->Clone()); // [ <----- The line we're interested in ]
                }
            // [ If the subscript has any non-1 size that isn't equal to the
            //   longest multipath tuple size, return with an error. ]
            } else if (vec.size() != max_providers_len) {
                error = strprintf("tr(): Multipath subscripts have mismatched lengths");
                return {};
            }
        }


        // [ Do the same for the internal key which also has to respect BIP 389
        //   multipath rules, any size > 1 that != the longest multipath tuple
        //   is no good. ]
        if (internal_keys.size() > 1 && internal_keys.size() != max_providers_len) {
            error = strprintf("tr(): Multipath internal key mismatches multipath subscripts lengths");
            return {};
        }

        // [ If internal key has no multipath, create clones of it for the
        //   multipath combinations. ]
        while (internal_keys.size() < max_providers_len) {
            internal_keys.emplace_back(internal_keys.at(0)->Clone());
        }
        
        // [ The multi-dimension for loop that required us to clone all of the
        //   single path expressions above for assembling the vector of
        //   TRDescriptors that are the resulting combinations of the multipath
        //   expressions. ]

        // [ There should be max_providers_len many DescriptorImpl's in each
        //   subscript. ]
        // Build the final descriptors vector
        for (size_t i = 0; i < max_providers_len; ++i) {
            // Build final subscripts vectors by retrieving the i'th subscript for each vector in subscripts
            std::vector<std::unique_ptr<DescriptorImpl>> this_subs;
            this_subs.reserve(subscripts.size());
            for (auto& subs : subscripts) {
                // [ Get the i'th member of each subcript's paths. ]
                this_subs.emplace_back(std::move(subs.at(i)));
            }
            ret.emplace_back(std::make_unique<TRDescriptor>(std::move(internal_keys.at(i)), std::move(this_subs), depths));
        }
        return ret;

```

At first, I misunderstood `ParseScript()` returning a vector of DescriptorImpl's
to be related to the handling of subexpressions, but that is already dealt with
by the `m_subdescriptor_args` member of a given `DescriptorImpl`, the reason that
`ParseScript()` returns a vector is to handle multipath descriptors as added in
[#22838](https://github.com/bitcoin/bitcoin/pull/22838) and described in [BIP
389](https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki).

Namely, the multipath descriptor rule from 389 that's being enforced here is:

    When a /<NUM;NUM;...;NUM> is encountered, parsers should account for a
    presence of multiple descriptors where the first descriptor uses the first
    NUM, and a second descriptor uses the second NUM, and so on, until each NUM
    is accounted for in the production of public keys, scripts, and addresses,
    as well as descriptor import and export operations. Descriptors that contain
    multiple Key Expressions that each have a /<NUM;NUM;...;NUM> must have
    tuples of exactly the same length so that they are derived in lockstep in
    the same way that /* paths in multiple Key expressions are handled.
    Duplicate NUMs within a tuple are not allowed.

I don't think it's super clear from the BIP text, but between the lines what is
being said here is also that descriptors that contain multiple key expressions
can contain a mixture of those without multipath  (`/<NUM;NUM...>`) expressions
and those with multipath expressions, and those that don't have a multipath
expression will be identical in each resulting multipath combination.

    Side question: Why were duplicate NUM's disallowed?
    [bitcoin/bips#1634](https://github.com/bitcoin/bips/pull/1634)


## Problem

In [#30864](https://github.com/bitcoin/bitcoin/issues/30864), one contributor
reports that running the following commands results in a heap-buffer-overflow:

```console 
$ echo "dHIoJTE3LzwyOzM+LGw6cGsoJTA4KSk=" | base64 --decode > scriptpubkeyman.crash
$ FUZZ=scriptpubkeyman src/test/fuzz/fuzz scriptpubkeyman.crash
```

The author of [#30866](https://github.com/bitcoin/bitcoin/pull/30866) and a
reviewer suggest that this crash is caused by insufficient depth of the
`miniscript::Node` copy made in `MiniscriptDescriptor::Clone()`.

`MiniscriptDescriptor::Clone()` and some relevant context:

```cpp
// [ src/script/miniscript.h ]
namespace miniscript {
template<typename Key> struct Node;
template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;

//! Construct a miniscript node as a shared_ptr.
template<typename Key, typename... Args>
NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }
}

// [ src/script/descriptor.cpp ]
class MiniscriptDescriptor final : public DescriptorImpl
{
private:
    // [ MiniscriptDescriptor's specialization over the base DescriptorImpl is a
    //   reference to a miniscript node. ]
    miniscript::NodeRef<uint32_t> m_node;

public:
    // [ Constructed from PubkeyProviders and a miniscript::NodeRef.
    MiniscriptDescriptor(std::vector<std::unique_ptr<PubkeyProvider>> providers, miniscript::NodeRef<uint32_t> node)
        : DescriptorImpl(std::move(providers), "?"), m_node(std::move(node)) {}
    // [...]
    std::unique_ptr<DescriptorImpl> Clone() const override
    {
        // [ Loop through and clone our pubkey providers into a new vector. ]
        std::vector<std::unique_ptr<PubkeyProvider>> providers;
        providers.reserve(m_pubkey_args.size());
        for (const auto& arg : m_pubkey_args) {
            providers.push_back(arg->Clone());
        }
        // 
        return std::make_unique<MiniscriptDescriptor>(std::move(providers), miniscript::MakeNodeRef<uint32_t>(*m_node));
    }
};
```




## Solution

## Annotated code

<details>

<summary>

Placeholder summary

</summary>

```
```

</details>

[^1]:
```cpp
struct PubkeyProvider
{
    /** Make a deep copy of this PubkeyProvider */
    virtual std::unique_ptr<PubkeyProvider> Clone() const = 0;
};
```
