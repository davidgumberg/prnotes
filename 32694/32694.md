# [#32694](https://github.com/bitcoin/bitcoin/pull/32694) index: move disk read lookups to base class
_All code comments in `[]` are my own._

## Background

In this PR, we're looking at the `BaseIndex` class, which serves as the base
class for the various indexes:
[`CoinStatsIndex`](https://github.com/bitcoin/bitcoin/blob/011a8c5f01685e7e126a1ab0bae8c46b7fac5250/src/index/coinstatsindex.h#L22), [`TxIndex`](https://github.com/bitcoin/bitcoin/blob/011a8c5f01685e7e126a1ab0bae8c46b7fac5250/src/index/txindex.h#L17), and [`BlockFilterIndex`](https://github.com/bitcoin/bitcoin/blob/011a8c5f01685e7e126a1ab0bae8c46b7fac5250/src/index/blockfilterindex.h#L29).

`BaseIndex` implements [`CValidationInterface`](https://github.com/bitcoin/bitcoin/blob/011a8c5f01685e7e126a1ab0bae8c46b7fac5250/src/validationinterface.h#L47),
which is the interface used by classes that can handle validation and
mempool related events, like `BlockConnected()`, `ChainstateFlushed()`,
`TransactionAddedToMempool()`, etc:

```cpp
/**
 * Base class for indices of blockchain data. This implements
 * CValidationInterface and ensures blocks are indexed sequentially according
 * to their position in the active chain.
 */
class BaseIndex : public CValidationInterface
{
```

`BaseIndex` has a `DB` member, which uses
[`CDBWrapper`](https://github.com/bitcoin/bitcoin/blob/011a8c5f01685e7e126a1ab0bae8c46b7fac5250/src/dbwrapper.h#L180),
the same interface used by `CCoinsViewDB` for reading and writing to a key value
store. (Currently, despite the name, the only db 'wrapped' by `CDBWrapper` is
LevelDB, but it is designed in a way to be easily ported to other KV db's.) The
only additional functionality provided by `BaseIndex` over `CDBWrapper is for
reading and writing a `CBlockLocator` that represents the block the index is
synced to:

```cpp
class BaseIndex : public CValidationInterface
{
protected:
    /**
     * The database stores a block locator of the chain the database is synced to
     * so that the index can efficiently determine the point it last stopped at.
     * A locator is used instead of a simple hash of the chain tip because blocks
     * and block index entries may not be flushed to disk until after this database
     * is updated.
    */
    class DB : public CDBWrapper
    {
    public:
        DB(const fs::path& path, size_t n_cache_size,
           bool f_memory = false, bool f_wipe = false, bool f_obfuscate = false);

        /// Read block locator of the chain that the index is in sync with.
        bool ReadBestBlock(CBlockLocator& locator) const
        {
            bool success = Read(DB_BEST_BLOCK, locator);
            if (!success) {
                locator.SetNull();
            }
            return success;
        }

        /// Write block locator of the chain that the index is in sync with.
        void WriteBestBlock(CDBBatch& batch, const CBlockLocator& locator)
        {
            batch.Write(DB_BEST_BLOCK, locator);
        }
    };
```

The other members are some atomic flags, one for whether or not the index has
been initialized `m_init`, one for whether or not it has been synced
`m_synced`, and an atomic pointer to the current best block index:

```cpp
class BaseIndex : public CValidationInterface
{
private:
    /// Whether the index has been initialized or not.
    std::atomic<bool> m_init{false};
    /// Whether the index is in sync with the main chain. The flag is flipped
    /// from false to true once, after which point this starts processing
    /// ValidationInterface notifications to stay in sync.
    ///
    /// Note that this will latch to true *immediately* upon startup if
    /// `m_chainstate->m_chain` is empty, which will be the case upon startup
    /// with an empty datadir if, e.g., `-txindex=1` is specified.
    std::atomic<bool> m_synced{false};

    /// The last block in the chain that the index is in sync with.
    std::atomic<const CBlockIndex*> m_best_block_index{nullptr};

    // [ Used for asynchronous index syncing. ]
    std::thread m_thread_sync;
    CThreadInterrupt m_interrupt;
```

`BaseIndex` is designed for background syncing of indexes, using a thread
`m_thread_sync`:

```cpp
bool BaseIndex::StartBackgroundSync()
{
    if (!m_init) throw std::logic_error("Error: Cannot start a non-initialized index");

    // [ util::TraceThread() is a callable wrapper, we use it for
    //   thread-specific logging, pass it a name and your callable function, and
    //   it just logs "Thread starting..."  "Thread Exit..."  ]
    m_thread_sync = std::thread(&util::TraceThread, GetName(), [this] { Sync(); });
    return true;
}

void BaseIndex::Sync()
{
    // [ Load handle on the current best block (an atomic) ]
    const CBlockIndex* pindex = m_best_block_index.load();
    // [ If we are sync'ed, no syncing is required. ]
    if (!m_synced) {
        // [ These just need to outlive each iteration of the loop. ]
        std::chrono::steady_clock::time_point last_log_time{0s};
        std::chrono::steady_clock::time_point last_locator_write_time{0s};
        while (true) {
            // [ If we've been interrupted... ]
            if (m_interrupt) {
                LogPrintf("%s: m_interrupt set; exiting ThreadSync\n", GetName());

                // [ Essentially sets m_best_block_index = pindex, has special
                //   logic needed to set prune locks on this block if we are a
                //   pruning node, so that we don't prune the best-known block
                //   to the index. ]
                SetBestBlockIndex(pindex);
                // No need to handle errors in Commit. If it fails, the error will be already be
                // logged. The best way to recover is to continue, as index cannot be corrupted by
                // a missed commit to disk for an advanced index state.
                // [ Commit() updates the bestblocklocator and flushes the index
                //   state to disk. ]
                Commit();
                return;
            }

            // [ Get this block's child, if it doesn't have any NextSyncBlock
            //   returns nullptr. ]
            const CBlockIndex* pindex_next = WITH_LOCK(cs_main, return NextSyncBlock(pindex, m_chainstate->m_chain));
            // If pindex_next is null, it means pindex is the chain tip, so
            // commit data indexed so far.
            if (!pindex_next) {
                SetBestBlockIndex(pindex);
                // No need to handle errors in Commit. See rationale above.
                Commit();

                // If pindex is still the chain tip after committing, exit the
                // sync loop. It is important for cs_main to be locked while
                // setting m_synced = true, otherwise a new block could be
                // attached while m_synced is still false, and it would not be
                // indexed.
                LOCK(::cs_main);
                pindex_next = NextSyncBlock(pindex, m_chainstate->m_chain);
                if (!pindex_next) {
                    m_synced = true;
                    break;
                }
            }
            if (pindex_next->pprev != pindex && !Rewind(pindex, pindex_next->pprev)) {
                FatalErrorf("%s: Failed to rewind index %s to a previous chain tip", __func__, GetName());
                return;
            }
            pindex = pindex_next;


            CBlock block;
            interfaces::BlockInfo block_info = kernel::MakeBlockInfo(pindex);
            if (!m_chainstate->m_blockman.ReadBlock(block, *pindex)) {
                FatalErrorf("%s: Failed to read block %s from disk",
                           __func__, pindex->GetBlockHash().ToString());
                return;
            } else {
                block_info.data = &block;
            }
            if (!CustomAppend(block_info)) {
                FatalErrorf("%s: Failed to write block %s to index database",
                           __func__, pindex->GetBlockHash().ToString());
                return;
            }

            auto current_time{std::chrono::steady_clock::now()};
            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {
                LogPrintf("Syncing %s with block chain from height %d\n",
                          GetName(), pindex->nHeight);
                last_log_time = current_time;
            }

            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {
                SetBestBlockIndex(pindex);
                last_locator_write_time = current_time;
                // No need to handle errors in Commit. See rationale above.
                Commit();
            }
        }
    }

    if (pindex) {
        LogPrintf("%s is enabled at height %d\n", GetName(), pindex->nHeight);
    } else {
        LogPrintf("%s is enabled\n", GetName());
    }
}
```





## Problem

## Solution

### [test: indexes, avoid creating threads when sync runs synchronously](https://github.com/bitcoin/bitcoin/pull/32694/commits/331a25cb16632042dd6782a9b62fcc5c8aa6da3b)

	The indexes test call StartBackgroundSync(), which spawns a thread to run Sync(),
	only for the test thread to wait for it to complete by calling IndexWaitSynced().

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/test/blockfilter_index_tests.cpp b/src/test/blockfilter_index_tests.cpp
index 81119f52b1926..1fc5bbdf3fc3c 100644
--- a/src/test/blockfilter_index_tests.cpp
+++ b/src/test/blockfilter_index_tests.cpp
@@ -12,7 +12,6 @@
 #include <node/miner.h>
 #include <pow.h>
 #include <test/util/blockfilter.h>
-#include <test/util/index.h>
 #include <test/util/setup_common.h>
 #include <validation.h>
 
@@ -143,10 +142,7 @@ BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, BuildChainTestingSetup)
     // BlockUntilSyncedToCurrentChain should return false before index is started.
     BOOST_CHECK(!filter_index.BlockUntilSyncedToCurrentChain());
 
-    BOOST_REQUIRE(filter_index.StartBackgroundSync());
-
-    // Allow filter index to catch up with the block index.
-    IndexWaitSynced(filter_index, *Assert(m_node.shutdown_signal));
+    filter_index.Sync();
 
     // Check that filter index has all blocks that were in the chain before it started.
     {
diff --git a/src/test/coinstatsindex_tests.cpp b/src/test/coinstatsindex_tests.cpp
index e09aad05e94f7..7d54f0fdf1515 100644
--- a/src/test/coinstatsindex_tests.cpp
+++ b/src/test/coinstatsindex_tests.cpp
@@ -6,7 +6,6 @@
 #include <index/coinstatsindex.h>
 #include <interfaces/chain.h>
 #include <kernel/coinstats.h>
-#include <test/util/index.h>
 #include <test/util/setup_common.h>
 #include <test/util/validation.h>
 #include <validation.h>
@@ -33,9 +32,7 @@ BOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)
     // is started.
     BOOST_CHECK(!coin_stats_index.BlockUntilSyncedToCurrentChain());
 
-    BOOST_REQUIRE(coin_stats_index.StartBackgroundSync());
-
-    IndexWaitSynced(coin_stats_index, *Assert(m_node.shutdown_signal));
+    coin_stats_index.Sync();
 
     // Check that CoinStatsIndex works for genesis block.
     const CBlockIndex* genesis_block_index;
@@ -85,8 +82,7 @@ BOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)
     {
         CoinStatsIndex index{interfaces::MakeChain(m_node), 1 << 20};
         BOOST_REQUIRE(index.Init());
-        BOOST_REQUIRE(index.StartBackgroundSync());
-        IndexWaitSynced(index, *Assert(m_node.shutdown_signal));
+        index.Sync();
         std::shared_ptr<const CBlock> new_block;
         CBlockIndex* new_block_index = nullptr;
         {
diff --git a/src/test/txindex_tests.cpp b/src/test/txindex_tests.cpp
index 9ee53878306b2..e06735e186be8 100644
--- a/src/test/txindex_tests.cpp
+++ b/src/test/txindex_tests.cpp
@@ -6,7 +6,6 @@
 #include <chainparams.h>
 #include <index/txindex.h>
 #include <interfaces/chain.h>
-#include <test/util/index.h>
 #include <test/util/setup_common.h>
 #include <validation.h>
 
@@ -30,10 +29,7 @@ BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)
     // BlockUntilSyncedToCurrentChain should return false before txindex is started.
     BOOST_CHECK(!txindex.BlockUntilSyncedToCurrentChain());
 
-    BOOST_REQUIRE(txindex.StartBackgroundSync());
-
-    // Allow tx index to catch up with the block index.
-    IndexWaitSynced(txindex, *Assert(m_node.shutdown_signal));
+    txindex.Sync();
 
     // Check that txindex excludes genesis block transactions.
     const CBlock& genesis_block = Params().GenesisBlock();
diff --git a/src/test/util/CMakeLists.txt b/src/test/util/CMakeLists.txt
index 3a6e31c720b9a..32396c41c35bc 100644
--- a/src/test/util/CMakeLists.txt
+++ b/src/test/util/CMakeLists.txt
@@ -6,7 +6,6 @@ add_library(test_util STATIC EXCLUDE_FROM_ALL
   blockfilter.cpp
   coins.cpp
   coverage.cpp
-  index.cpp
   json.cpp
   logging.cpp
   mining.cpp
diff --git a/src/test/util/index.cpp b/src/test/util/index.cpp
deleted file mode 100644
index cfeba35756216..0000000000000
--- a/src/test/util/index.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright (c) 2020-2022 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include <test/util/index.h>
-
-#include <index/base.h>
-#include <util/check.h>
-#include <util/signalinterrupt.h>
-#include <util/time.h>
-
-void IndexWaitSynced(const BaseIndex& index, const util::SignalInterrupt& interrupt)
-{
-    while (!index.BlockUntilSyncedToCurrentChain()) {
-        // Assert shutdown was not requested to abort the test, instead of looping forever, in case
-        // there was an unexpected error in the index that caused it to stop syncing and request a shutdown.
-        Assert(!interrupt);
-
-        UninterruptibleSleep(100ms);
-    }
-    assert(index.GetSummary().synced);
-}
diff --git a/src/test/util/index.h b/src/test/util/index.h
deleted file mode 100644
index a3bd1dddc3f0e..0000000000000
--- a/src/test/util/index.h
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright (c) 2020-2022 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_TEST_UTIL_INDEX_H
-#define BITCOIN_TEST_UTIL_INDEX_H
-
-class BaseIndex;
-namespace util {
-class SignalInterrupt;
-} // namespace util
-
-/** Block until the index is synced to the current chain */
-void IndexWaitSynced(const BaseIndex& index, const util::SignalInterrupt& interrupt);
-
-#endif // BITCOIN_TEST_UTIL_INDEX_H
```
</details>

### [indexes, refactor: Stop requiring CBlockIndex type to call IsBIP30Unspendable](https://github.com/bitcoin/bitcoin/pull/32694/commits/0a248708dc9d465db09168c39b3f12cb4c9465b7)

	This commit does not change behavior in any way.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index b5869416b930b..9ec034ce3c5a4 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -150,7 +150,7 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
             const auto& tx{block.data->vtx.at(i)};
 
             // Skip duplicate txid coinbase transactions (BIP30).
-            if (IsBIP30Unspendable(*pindex) && tx->IsCoinBase()) {
+            if (IsBIP30Unspendable(block.hash, block.height) && tx->IsCoinBase()) {
                 m_total_unspendable_amount += block_subsidy;
                 m_total_unspendables_bip30 += block_subsidy;
                 continue;
diff --git a/src/validation.cpp b/src/validation.cpp
index 97190dc24862c..b87de9c456346 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -6341,10 +6341,10 @@ bool IsBIP30Repeat(const CBlockIndex& block_index)
            (block_index.nHeight==91880 && block_index.GetBlockHash() == uint256{"00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721"});
 }
 
-bool IsBIP30Unspendable(const CBlockIndex& block_index)
+bool IsBIP30Unspendable(const uint256& block_hash, int block_height)
 {
-    return (block_index.nHeight==91722 && block_index.GetBlockHash() == uint256{"00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e"}) ||
-           (block_index.nHeight==91812 && block_index.GetBlockHash() == uint256{"00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"});
+    return (block_height==91722 && block_hash == uint256{"00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e"}) ||
+           (block_height==91812 && block_hash == uint256{"00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"});
 }
 
 static fs::path GetSnapshotCoinsDBPath(Chainstate& cs) EXCLUSIVE_LOCKS_REQUIRED(::cs_main)
diff --git a/src/validation.h b/src/validation.h
index 0a8a94db120eb..b2ac117698edc 100644
--- a/src/validation.h
+++ b/src/validation.h
@@ -1350,6 +1350,6 @@ bool DeploymentEnabled(const ChainstateManager& chainman, DEP dep)
 bool IsBIP30Repeat(const CBlockIndex& block_index);
 
 /** Identifies blocks which coinbase output was subsequently overwritten in the UTXO set (see BIP30) */
-bool IsBIP30Unspendable(const CBlockIndex& block_index);
+bool IsBIP30Unspendable(const uint256& block_hash, int block_height);
 
 #endif // BITCOIN_VALIDATION_H
```
</details>

### [indexes, refactor: Remove remaining CBlockIndex* uses in index Rewind methods](https://github.com/bitcoin/bitcoin/pull/32694/commits/6f1392cc42cde638773f2b697d7d2c58abcdc860)

	Move ReadBlock code from CoinStatsIndex::CustomRewind to BaseIndex::Rewind

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/index/base.cpp b/src/index/base.cpp
index 5767116ce53f3..0e76bafecaa55 100644
--- a/src/index/base.cpp
+++ b/src/index/base.cpp
@@ -14,6 +14,7 @@
 #include <node/database_args.h>
 #include <node/interface_ui.h>
 #include <tinyformat.h>
+#include <undo.h>
 #include <util/string.h>
 #include <util/thread.h>
 #include <util/translation.h>
@@ -254,8 +255,28 @@ bool BaseIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_ti
     assert(current_tip == m_best_block_index);
     assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);
 
-    if (!CustomRewind({current_tip->GetBlockHash(), current_tip->nHeight}, {new_tip->GetBlockHash(), new_tip->nHeight})) {
-        return false;
+    CBlock block;
+    CBlockUndo block_undo;
+
+    for (const CBlockIndex* iter_tip = current_tip; iter_tip != new_tip; iter_tip = iter_tip->pprev) {
+        interfaces::BlockInfo block_info = kernel::MakeBlockInfo(iter_tip);
+        if (CustomOptions().disconnect_data) {
+            if (!m_chainstate->m_blockman.ReadBlock(block, *iter_tip)) {
+                LogError("%s: Failed to read block %s from disk",
+                             __func__, iter_tip->GetBlockHash().ToString());
+                return false;
+            }
+            block_info.data = &block;
+        }
+        if (CustomOptions().disconnect_undo_data && iter_tip->nHeight > 0) {
+            if (!m_chainstate->m_blockman.ReadBlockUndo(block_undo, *iter_tip)) {
+                return false;
+            }
+            block_info.undo_data = &block_undo;
+        }
+        if (!CustomRemove(block_info)) {
+            return false;
+        }
     }
 
     // In the case of a reorg, ensure persisted block locator is not stale.
diff --git a/src/index/base.h b/src/index/base.h
index fbd9069a515d7..841bfcb00e84a 100644
--- a/src/index/base.h
+++ b/src/index/base.h
@@ -90,7 +90,7 @@ class BaseIndex : public CValidationInterface
     /// getting corrupted.
     bool Commit();
 
-    /// Loop over disconnected blocks and call CustomRewind.
+    /// Loop over disconnected blocks and call CustomRemove.
     bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip);
 
     virtual bool AllowPrune() const = 0;
@@ -107,6 +107,9 @@ class BaseIndex : public CValidationInterface
 
     void ChainStateFlushed(ChainstateRole role, const CBlockLocator& locator) override;
 
+    /// Return custom notification options for index.
+    [[nodiscard]] virtual interfaces::Chain::NotifyOptions CustomOptions() { return {}; }
+
     /// Initialize internal state from the database and block index.
     [[nodiscard]] virtual bool CustomInit(const std::optional<interfaces::BlockRef>& block) { return true; }
 
@@ -117,9 +120,8 @@ class BaseIndex : public CValidationInterface
     /// commit more index state.
     virtual bool CustomCommit(CDBBatch& batch) { return true; }
 
-    /// Rewind index to an earlier chain tip during a chain reorg. The tip must
-    /// be an ancestor of the current best block.
-    [[nodiscard]] virtual bool CustomRewind(const interfaces::BlockRef& current_tip, const interfaces::BlockRef& new_tip) { return true; }
+    /// Rewind index by one block during a chain reorg.
+    [[nodiscard]] virtual bool CustomRemove(const interfaces::BlockInfo& block) { return true; }
 
     virtual DB& GetDB() const = 0;
 
diff --git a/src/index/blockfilterindex.cpp b/src/index/blockfilterindex.cpp
index 5ce85e1f8443b..460d5d7c41b48 100644
--- a/src/index/blockfilterindex.cpp
+++ b/src/index/blockfilterindex.cpp
@@ -316,7 +316,7 @@ bool BlockFilterIndex::Write(const BlockFilter& filter, uint32_t block_height, c
     return true;
 }
 
-bool BlockFilterIndex::CustomRewind(const interfaces::BlockRef& current_tip, const interfaces::BlockRef& new_tip)
+bool BlockFilterIndex::CustomRemove(const interfaces::BlockInfo& block)
 {
     CDBBatch batch(*m_db);
     std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());
@@ -324,7 +324,7 @@ bool BlockFilterIndex::CustomRewind(const interfaces::BlockRef& current_tip, con
     // During a reorg, we need to copy all filters for blocks that are getting disconnected from the
     // height index to the hash index so we can still find them when the height index entries are
     // overwritten.
-    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip.height, current_tip.height)) {
+    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, block.height - 1, block.height)) {
         return false;
     }
 
@@ -334,8 +334,8 @@ bool BlockFilterIndex::CustomRewind(const interfaces::BlockRef& current_tip, con
     batch.Write(DB_FILTER_POS, m_next_filter_pos);
     if (!m_db->WriteBatch(batch)) return false;
 
-    // Update cached header
-    m_last_header = *Assert(ReadFilterHeader(new_tip.height, new_tip.hash));
+    // Update cached header to the previous block hash
+    m_last_header = *Assert(ReadFilterHeader(block.height - 1, *Assert(block.prev_hash)));
     return true;
 }
 
diff --git a/src/index/blockfilterindex.h b/src/index/blockfilterindex.h
index ccb4845ef5ecf..13543b961cc87 100644
--- a/src/index/blockfilterindex.h
+++ b/src/index/blockfilterindex.h
@@ -58,7 +58,7 @@ class BlockFilterIndex final : public BaseIndex
 
     bool CustomAppend(const interfaces::BlockInfo& block) override;
 
-    bool CustomRewind(const interfaces::BlockRef& current_tip, const interfaces::BlockRef& new_tip) override;
+    bool CustomRemove(const interfaces::BlockInfo& block) override;
 
     BaseIndex::DB& GetDB() const LIFETIMEBOUND override { return *m_db; }
 
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index 9ec034ce3c5a4..5f82cf93b7e56 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -265,7 +265,7 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
     return true;
 }
 
-bool CoinStatsIndex::CustomRewind(const interfaces::BlockRef& current_tip, const interfaces::BlockRef& new_tip)
+bool CoinStatsIndex::CustomRemove(const interfaces::BlockInfo& block)
 {
     CDBBatch batch(*m_db);
     std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());
@@ -273,32 +273,14 @@ bool CoinStatsIndex::CustomRewind(const interfaces::BlockRef& current_tip, const
     // During a reorg, we need to copy all hash digests for blocks that are
     // getting disconnected from the height index to the hash index so we can
     // still find them when the height index entries are overwritten.
-    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip.height, current_tip.height)) {
+    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, block.height - 1, block.height)) {
         return false;
     }
 
     if (!m_db->WriteBatch(batch)) return false;
 
-    {
-        LOCK(cs_main);
-        const CBlockIndex* iter_tip{m_chainstate->m_blockman.LookupBlockIndex(current_tip.hash)};
-        const CBlockIndex* new_tip_index{m_chainstate->m_blockman.LookupBlockIndex(new_tip.hash)};
-
-        do {
-            CBlock block;
-
-            if (!m_chainstate->m_blockman.ReadBlock(block, *iter_tip)) {
-                LogError("%s: Failed to read block %s from disk\n",
-                             __func__, iter_tip->GetBlockHash().ToString());
-                return false;
-            }
-
-            if (!ReverseBlock(block, iter_tip)) {
-                return false; // failure cause logged internally
-            }
-
-            iter_tip = iter_tip->GetAncestor(iter_tip->nHeight - 1);
-        } while (new_tip_index != iter_tip);
+    if (!ReverseBlock(block)) {
+        return false; // failure cause logged internally
     }
 
     return true;
@@ -404,26 +386,29 @@ bool CoinStatsIndex::CustomCommit(CDBBatch& batch)
     return true;
 }
 
+interfaces::Chain::NotifyOptions CoinStatsIndex::CustomOptions()
+{
+    interfaces::Chain::NotifyOptions options;
+    options.disconnect_data = true;
+    options.disconnect_undo_data = true;
+    return options;
+}
+
 // Reverse a single block as part of a reorg
-bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex)
+bool CoinStatsIndex::ReverseBlock(const interfaces::BlockInfo& block)
 {
-    CBlockUndo block_undo;
     std::pair<uint256, DBVal> read_out;
 
-    const CAmount block_subsidy{GetBlockSubsidy(pindex->nHeight, Params().GetConsensus())};
+    const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};
     m_total_subsidy -= block_subsidy;
 
     // Ignore genesis block
-    if (pindex->nHeight > 0) {
-        if (!m_chainstate->m_blockman.ReadBlockUndo(block_undo, *pindex)) {
-            return false;
-        }
-
-        if (!m_db->Read(DBHeightKey(pindex->nHeight - 1), read_out)) {
+    if (block.height > 0) {
+        if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {
             return false;
         }
 
-        uint256 expected_block_hash{pindex->pprev->GetBlockHash()};
+        uint256 expected_block_hash{*block.prev_hash};
         if (read_out.first != expected_block_hash) {
             LogPrintf("WARNING: previous block header belongs to unexpected block %s; expected %s\n",
                       read_out.first.ToString(), expected_block_hash.ToString());
@@ -437,13 +422,15 @@ bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex
     }
 
     // Remove the new UTXOs that were created from the block
-    for (size_t i = 0; i < block.vtx.size(); ++i) {
-        const auto& tx{block.vtx.at(i)};
+    assert(block.data);
+    assert(block.undo_data);
+    for (size_t i = 0; i < block.data->vtx.size(); ++i) {
+        const auto& tx{block.data->vtx.at(i)};
 
         for (uint32_t j = 0; j < tx->vout.size(); ++j) {
             const CTxOut& out{tx->vout[j]};
             COutPoint outpoint{tx->GetHash(), j};
-            Coin coin{out, pindex->nHeight, tx->IsCoinBase()};
+            Coin coin{out, block.height, tx->IsCoinBase()};
 
             // Skip unspendable coins
             if (coin.out.scriptPubKey.IsUnspendable()) {
@@ -467,7 +454,7 @@ bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex
 
         // The coinbase tx has no undo data since no former output is spent
         if (!tx->IsCoinBase()) {
-            const auto& tx_undo{block_undo.vtxundo.at(i - 1)};
+            const auto& tx_undo{block.undo_data->vtxundo.at(i - 1)};
 
             for (size_t j = 0; j < tx_undo.vprevout.size(); ++j) {
                 Coin coin{tx_undo.vprevout[j]};
diff --git a/src/index/coinstatsindex.h b/src/index/coinstatsindex.h
index 885b9e0a860f4..6e2743688ad24 100644
--- a/src/index/coinstatsindex.h
+++ b/src/index/coinstatsindex.h
@@ -38,18 +38,20 @@ class CoinStatsIndex final : public BaseIndex
     CAmount m_total_unspendables_scripts{0};
     CAmount m_total_unspendables_unclaimed_rewards{0};
 
-    [[nodiscard]] bool ReverseBlock(const CBlock& block, const CBlockIndex* pindex);
+    [[nodiscard]] bool ReverseBlock(const interfaces::BlockInfo& block);
 
     bool AllowPrune() const override { return true; }
 
 protected:
+    interfaces::Chain::NotifyOptions CustomOptions() override;
+
     bool CustomInit(const std::optional<interfaces::BlockRef>& block) override;
 
     bool CustomCommit(CDBBatch& batch) override;
 
     bool CustomAppend(const interfaces::BlockInfo& block) override;
 
-    bool CustomRewind(const interfaces::BlockRef& current_tip, const interfaces::BlockRef& new_tip) override;
+    bool CustomRemove(const interfaces::BlockInfo& block) override;
 
     BaseIndex::DB& GetDB() const override { return *m_db; }
 
diff --git a/src/interfaces/chain.h b/src/interfaces/chain.h
index de99262e9822c..f98eeeed8bb38 100644
--- a/src/interfaces/chain.h
+++ b/src/interfaces/chain.h
@@ -327,6 +327,15 @@ class Chain
         virtual void chainStateFlushed(ChainstateRole role, const CBlockLocator& locator) {}
     };
 
+    //! Options specifying which chain notifications are required.
+    struct NotifyOptions
+    {
+        //! Include block data with block disconnected notifications.
+        bool disconnect_data = false;
+        //! Include undo data with block disconnected notifications.
+        bool disconnect_undo_data = false;
+    };
+
     //! Register handler for notifications.
     virtual std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) = 0;
 
```
</details>

### [index: remove CBlockIndex access from CustomAppend()](https://github.com/bitcoin/bitcoin/pull/32694/commits/4c5ec3a70a47798d8451da65c9c0059955cde937)

	Moved CBlockUndo disk read lookups from child index classes to
	the base index class.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/index/base.cpp b/src/index/base.cpp
index 0e76bafecaa55..a5c0cc29c9d83 100644
--- a/src/index/base.cpp
+++ b/src/index/base.cpp
@@ -144,9 +144,44 @@ static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev, CChain&
         return pindex;
     }
 
+    // Since block is not in the chain, return the next block in the chain AFTER the last common ancestor.
+    // Caller will be responsible for rewinding back to the common ancestor.
     return chain.Next(chain.FindFork(pindex_prev));
 }
 
+bool BaseIndex::ProcessBlock(const CBlockIndex* pindex, const CBlock* block_data)
+{
+    interfaces::BlockInfo block_info = kernel::MakeBlockInfo(pindex, block_data);
+
+    CBlock block;
+    if (!block_data) { // disk lookup if block data wasn't provided
+        if (!m_chainstate->m_blockman.ReadBlock(block, *pindex)) {
+            FatalErrorf("%s: Failed to read block %s from disk",
+                        __func__, pindex->GetBlockHash().ToString());
+            return false;
+        }
+        block_info.data = &block;
+    }
+
+    CBlockUndo block_undo;
+    if (CustomOptions().connect_undo_data) {
+        if (pindex->nHeight > 0 && !m_chainstate->m_blockman.ReadBlockUndo(block_undo, *pindex)) {
+            FatalErrorf("%s: Failed to read undo block data %s from disk",
+                        __func__, pindex->GetBlockHash().ToString());
+            return false;
+        }
+        block_info.undo_data = &block_undo;
+    }
+
+    if (!CustomAppend(block_info)) {
+        FatalErrorf("%s: Failed to write block %s to index database",
+                    __func__, pindex->GetBlockHash().ToString());
+        return false;
+    }
+
+    return true;
+}
+
 void BaseIndex::Sync()
 {
     const CBlockIndex* pindex = m_best_block_index.load();
@@ -192,20 +227,7 @@ void BaseIndex::Sync()
             pindex = pindex_next;
 
 
-            CBlock block;
-            interfaces::BlockInfo block_info = kernel::MakeBlockInfo(pindex);
-            if (!m_chainstate->m_blockman.ReadBlock(block, *pindex)) {
-                FatalErrorf("%s: Failed to read block %s from disk",
-                           __func__, pindex->GetBlockHash().ToString());
-                return;
-            } else {
-                block_info.data = &block;
-            }
-            if (!CustomAppend(block_info)) {
-                FatalErrorf("%s: Failed to write block %s to index database",
-                           __func__, pindex->GetBlockHash().ToString());
-                return;
-            }
+            if (!ProcessBlock(pindex)) return; // error logged internally
 
             auto current_time{std::chrono::steady_clock::now()};
             if (last_log_time + SYNC_LOG_INTERVAL < current_time) {
@@ -337,17 +359,14 @@ void BaseIndex::BlockConnected(ChainstateRole role, const std::shared_ptr<const
             return;
         }
     }
-    interfaces::BlockInfo block_info = kernel::MakeBlockInfo(pindex, block.get());
-    if (CustomAppend(block_info)) {
+
+    // Dispatch block to child class; errors are logged internally and abort the node.
+    if (ProcessBlock(pindex, block.get())) {
         // Setting the best block index is intentionally the last step of this
         // function, so BlockUntilSyncedToCurrentChain callers waiting for the
         // best block index to be updated can rely on the block being fully
         // processed, and the index object being safe to delete.
         SetBestBlockIndex(pindex);
-    } else {
-        FatalErrorf("%s: Failed to write block %s to index",
-                   __func__, pindex->GetBlockHash().ToString());
-        return;
     }
 }
 
diff --git a/src/index/base.h b/src/index/base.h
index 841bfcb00e84a..4131b06cad9de 100644
--- a/src/index/base.h
+++ b/src/index/base.h
@@ -93,6 +93,8 @@ class BaseIndex : public CValidationInterface
     /// Loop over disconnected blocks and call CustomRemove.
     bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip);
 
+    bool ProcessBlock(const CBlockIndex* pindex, const CBlock* block_data = nullptr);
+
     virtual bool AllowPrune() const = 0;
 
     template <typename... Args>
diff --git a/src/index/blockfilterindex.cpp b/src/index/blockfilterindex.cpp
index 460d5d7c41b48..8530e931a9df9 100644
--- a/src/index/blockfilterindex.cpp
+++ b/src/index/blockfilterindex.cpp
@@ -13,7 +13,6 @@
 #include <node/blockstorage.h>
 #include <undo.h>
 #include <util/fs_helpers.h>
-#include <validation.h>
 
 /* The index database stores three items for each block: the disk location of the encoded filter,
  * its dSHA256 hash, and the header. Those belonging to blocks on the active chain are indexed by
@@ -112,6 +111,13 @@ BlockFilterIndex::BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, Blo
     m_filter_fileseq = std::make_unique<FlatFileSeq>(std::move(path), "fltr", FLTR_FILE_CHUNK_SIZE);
 }
 
+interfaces::Chain::NotifyOptions BlockFilterIndex::CustomOptions()
+{
+    interfaces::Chain::NotifyOptions options;
+    options.connect_undo_data = true;
+    return options;
+}
+
 bool BlockFilterIndex::CustomInit(const std::optional<interfaces::BlockRef>& block)
 {
     if (!m_db->Read(DB_FILTER_POS, m_next_filter_pos)) {
@@ -250,19 +256,7 @@ std::optional<uint256> BlockFilterIndex::ReadFilterHeader(int height, const uint
 
 bool BlockFilterIndex::CustomAppend(const interfaces::BlockInfo& block)
 {
-    CBlockUndo block_undo;
-
-    if (block.height > 0) {
-        // pindex variable gives indexing code access to node internals. It
-        // will be removed in upcoming commit
-        const CBlockIndex* pindex = WITH_LOCK(cs_main, return m_chainstate->m_blockman.LookupBlockIndex(block.hash));
-        if (!m_chainstate->m_blockman.ReadBlockUndo(block_undo, *pindex)) {
-            return false;
-        }
-    }
-
-    BlockFilter filter(m_filter_type, *Assert(block.data), block_undo);
-
+    BlockFilter filter(m_filter_type, *Assert(block.data), *Assert(block.undo_data));
     const uint256& header = filter.ComputeHeader(m_last_header);
     bool res = Write(filter, block.height, header);
     if (res) m_last_header = header; // update last header
diff --git a/src/index/blockfilterindex.h b/src/index/blockfilterindex.h
index 13543b961cc87..983cf32206a42 100644
--- a/src/index/blockfilterindex.h
+++ b/src/index/blockfilterindex.h
@@ -52,6 +52,8 @@ class BlockFilterIndex final : public BaseIndex
     std::optional<uint256> ReadFilterHeader(int height, const uint256& expected_block_hash);
 
 protected:
+    interfaces::Chain::NotifyOptions CustomOptions() override;
+
     bool CustomInit(const std::optional<interfaces::BlockRef>& block) override;
 
     bool CustomCommit(CDBBatch& batch) override;
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index 5f82cf93b7e56..819d89d542496 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -114,19 +114,11 @@ CoinStatsIndex::CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t
 
 bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 {
-    CBlockUndo block_undo;
     const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};
     m_total_subsidy += block_subsidy;
 
     // Ignore genesis block
     if (block.height > 0) {
-        // pindex variable gives indexing code access to node internals. It
-        // will be removed in upcoming commit
-        const CBlockIndex* pindex = WITH_LOCK(cs_main, return m_chainstate->m_blockman.LookupBlockIndex(block.hash));
-        if (!m_chainstate->m_blockman.ReadBlockUndo(block_undo, *pindex)) {
-            return false;
-        }
-
         std::pair<uint256, DBVal> read_out;
         if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {
             return false;
@@ -183,7 +175,7 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
             // The coinbase tx has no undo data since no former output is spent
             if (!tx->IsCoinBase()) {
-                const auto& tx_undo{block_undo.vtxundo.at(i - 1)};
+                const auto& tx_undo{Assert(block.undo_data)->vtxundo.at(i - 1)};
 
                 for (size_t j = 0; j < tx_undo.vprevout.size(); ++j) {
                     Coin coin{tx_undo.vprevout[j]};
@@ -389,6 +381,7 @@ bool CoinStatsIndex::CustomCommit(CDBBatch& batch)
 interfaces::Chain::NotifyOptions CoinStatsIndex::CustomOptions()
 {
     interfaces::Chain::NotifyOptions options;
+    options.connect_undo_data = true;
     options.disconnect_data = true;
     options.disconnect_undo_data = true;
     return options;
diff --git a/src/interfaces/chain.h b/src/interfaces/chain.h
index f98eeeed8bb38..f6e831624d0b4 100644
--- a/src/interfaces/chain.h
+++ b/src/interfaces/chain.h
@@ -330,6 +330,8 @@ class Chain
     //! Options specifying which chain notifications are required.
     struct NotifyOptions
     {
+        //! Include undo data with block connected notifications.
+        bool connect_undo_data = false;
         //! Include block data with block disconnected notifications.
         bool disconnect_data = false;
         //! Include undo data with block disconnected notifications.
```
</details>

