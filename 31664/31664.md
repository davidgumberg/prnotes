# [#31664](https://github.com/bitcoin/bitcoin/pull/31664) Fees:  add Fee rate Forecaster Manager
_All code comments in `[]` are my own._

## Background

## Problem

## Solution

### [fees: refactor: rename policy_fee_tests.cpp to feerounder_tests.cpp](https://github.com/bitcoin/bitcoin/pull/31664/commits/43dcb31a2ead080e7740d4ff87948b7022b82a7e)

Just a renaming commit, good enough for me.


### [fees: refactor: rename fees to block_policy_estimator](https://github.com/bitcoin/bitcoin/pull/31664/commits/5624f87850b67e2ff20a86a2c3b48ef825fe5315)

Renaming

### [fees: rename fees_args to block_policy_estimator_args](https://github.com/bitcoin/bitcoin/pull/31664/commits/bd3a9463d0719accf7d033ec4568976d1bcfe128)

Rename

### [fees: return current block height in `estimateSmartFee`](https://github.com/bitcoin/bitcoin/pull/31664/commits/9a36d0de678f177a6b9954fdb2f91e5c42004c15)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/policy/fees/block_policy_estimator.cpp b/src/policy/fees/block_policy_estimator.cpp
index 861e19267a2f6..86bc4176e0050 100644
--- a/src/policy/fees/block_policy_estimator.cpp
+++ b/src/policy/fees/block_policy_estimator.cpp
@@ -874,6 +874,7 @@ CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, FeeCalculation
     if (feeCalc) {
         feeCalc->desiredTarget = confTarget;
         feeCalc->returnedTarget = confTarget;
+        feeCalc->best_height = nBestSeenHeight;
     }
 
     double median = -1;
diff --git a/src/policy/fees/block_policy_estimator.h b/src/policy/fees/block_policy_estimator.h
index 394a1d7f885b5..61c1992243cfb 100644
--- a/src/policy/fees/block_policy_estimator.h
+++ b/src/policy/fees/block_policy_estimator.h
@@ -95,6 +95,7 @@ struct FeeCalculation
     FeeReason reason = FeeReason::NONE;
     int desiredTarget = 0;
     int returnedTarget = 0;
+    unsigned int best_height{0};
 };
 
 /** \class CBlockPolicyEstimator
```
</details>

### [fees: add forecaster structures](https://github.com/bitcoin/bitcoin/pull/31664/commits/11608d0fc6610af80db33682705f6b8de2b73526)

	i  - Forecaster abstract class is the base class of fee rate forecasters.
	     Derived classes must provide concrete implementation
	     of the virtual methods.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/policy/fees/forecaster.h b/src/policy/fees/forecaster.h
new file mode 100644
index 0000000000000..b46585978671a
--- /dev/null
+++ b/src/policy/fees/forecaster.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2025 The Bitcoin Core developers
+// Distributed under the MIT software license. See the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_POLICY_FEES_FORECASTER_H
+#define BITCOIN_POLICY_FEES_FORECASTER_H
+
+#include <policy/fees/forecaster_util.h>
+
+/** \class Forecaster
+ *  @brief Abstract base class for fee rate forecasters.
+ */
+class Forecaster
+{
+protected:
+    const ForecastType m_forecast_type;
+
+public:
+    explicit Forecaster(ForecastType forecast_type) : m_forecast_type(forecast_type) {}
+
+    ForecastType GetForecastType() const { return m_forecast_type; }
+
+    /**
+     * @brief Returns the estimated fee rate for a package to confirm within the given target.
+     * @param target Confirmation target in blocks.
+     * @param conservative If true, returns a higher fee rate for greater confirmation probability.
+     * @return Predicted fee rate.
+     */
+    virtual ForecastResult ForecastFeeRate(int target, bool conservative) const = 0;
+
+    /**
+     * @brief Returns the maximum supported confirmation target.
+     */
+    virtual unsigned int MaximumTarget() const = 0;
+
+    virtual ~Forecaster() = default;
+};
+
+#endif // BITCOIN_POLICY_FEES_FORECASTER_H
diff --git a/src/policy/fees/forecaster_util.h b/src/policy/fees/forecaster_util.h
new file mode 100644
index 0000000000000..11dac144aacaf
--- /dev/null
+++ b/src/policy/fees/forecaster_util.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2025 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_POLICY_FEES_FORECASTER_UTIL_H
+#define BITCOIN_POLICY_FEES_FORECASTER_UTIL_H
+
+#include <util/feefrac.h>
+
+#include <optional>
+#include <string>
+
+/**
+ * @enum ForecastType
+ * Identifier for fee rate forecasters.
+ */
+enum class ForecastType {};
+
+/**
+ * @struct ForecastResult
+ * Represents the response returned by a fee rate forecaster.
+ */
+struct ForecastResult {
+    //! This identifies which forecaster is providing this feerate forecast
+    std::optional<ForecastType> forecaster;
+
+    //! Fee rate sufficient to confirm a package within target.
+    FeeFrac feerate;
+
+    //! The block height at which the forecast was made.
+    unsigned int current_block_height{0};
+
+    std::optional<std::string> error; ///< Optional error message.
+
+    /**
+     * Compare two ForecastResult objects based on fee rate.
+     * @param other The other ForecastResult object to compare with.
+     * @return true if the current object's fee rate is less than the other, false otherwise.
+     */
+    bool operator<(const ForecastResult& other) const
+    {
+        return feerate << other.feerate;
+    }
+};
+
+#endif // BITCOIN_POLICY_FEES_FORECASTER_UTIL_H
```
</details>

### [fees: add ForecasterMan class](https://github.com/bitcoin/bitcoin/pull/31664/commits/fdc7ce973d1d3bb2df41191ba6a6b09573c68723)

	- Its a module for managing and utilising multiple
	  fee rate forecasters to provide fee rate forecast.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 7b5ea67ac4db9..bae1530b21e09 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -284,6 +284,7 @@ add_library(bitcoin_node STATIC EXCLUDE_FROM_ALL
   policy/ephemeral_policy.cpp
   policy/fees/block_policy_estimator.cpp
   policy/fees/block_policy_estimator_args.cpp
+  policy/fees/forecaster_man.cpp
   policy/packages.cpp
   policy/rbf.cpp
   policy/settings.cpp
diff --git a/src/policy/fees/forecaster_man.cpp b/src/policy/fees/forecaster_man.cpp
new file mode 100644
index 0000000000000..462fb2c80262f
--- /dev/null
+++ b/src/policy/fees/forecaster_man.cpp
@@ -0,0 +1,14 @@
+// Copyright (c) 2025 The Bitcoin Core developers
+// Distributed under the MIT software license. See the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <policy/fees/forecaster.h>
+#include <policy/fees/forecaster_man.h>
+#include <policy/fees/forecaster_util.h>
+
+#include <utility>
+
+void FeeRateForecasterManager::RegisterForecaster(std::shared_ptr<Forecaster> forecaster)
+{
+    forecasters.emplace(forecaster->GetForecastType(), forecaster);
+}
diff --git a/src/policy/fees/forecaster_man.h b/src/policy/fees/forecaster_man.h
new file mode 100644
index 0000000000000..9c70b5ab115ba
--- /dev/null
+++ b/src/policy/fees/forecaster_man.h
@@ -0,0 +1,33 @@
+// Copyright (c) 2025 The Bitcoin Core developers
+// Distributed under the MIT software license. See the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_POLICY_FEES_FORECASTER_MAN_H
+#define BITCOIN_POLICY_FEES_FORECASTER_MAN_H
+
+#include <memory>
+#include <unordered_map>
+
+class Forecaster;
+struct ForecastResult;
+
+enum class ForecastType;
+
+/** \class FeeRateForecasterManager
+ * Manages multiple fee rate forecasters.
+ */
+class FeeRateForecasterManager
+{
+private:
+    //! Map of all registered forecasters to their shared pointers.
+    std::unordered_map<ForecastType, std::shared_ptr<Forecaster>> forecasters;
+
+public:
+    /**
+     * Register a forecaster.
+     * @param[in] forecaster shared pointer to a Forecaster instance.
+     */
+    void RegisterForecaster(std::shared_ptr<Forecaster> forecaster);
+};
+
+#endif // BITCOIN_POLICY_FEES_FORECASTER_MAN_H
```
</details>

### [fees: make block_policy_estimator a forecaster](https://github.com/bitcoin/bitcoin/pull/31664/commits/c3776d115072e4dda5cb43bf7eb6a90ff04655d4)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/policy/fees/block_policy_estimator.cpp b/src/policy/fees/block_policy_estimator.cpp
index 86bc4176e0050..b47246da1e3ea 100644
--- a/src/policy/fees/block_policy_estimator.cpp
+++ b/src/policy/fees/block_policy_estimator.cpp
@@ -10,6 +10,7 @@
 #include <kernel/mempool_entry.h>
 #include <logging.h>
 #include <policy/feerate.h>
+#include <policy/fees/forecaster_util.h>
 #include <primitives/transaction.h>
 #include <random.h>
 #include <serialize.h>
@@ -540,7 +541,7 @@ bool CBlockPolicyEstimator::_removeTx(const uint256& hash, bool inBlock)
 }
 
 CBlockPolicyEstimator::CBlockPolicyEstimator(const fs::path& estimation_filepath, const bool read_stale_estimates)
-    : m_estimation_filepath{estimation_filepath}
+    : Forecaster(ForecastType::BLOCK_POLICY), m_estimation_filepath{estimation_filepath}
 {
     static_assert(MIN_BUCKET_FEERATE > 0, "Min feerate must be nonzero");
     size_t bucketIndex = 0;
@@ -723,6 +724,29 @@ CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget) const
     return estimateRawFee(confTarget, DOUBLE_SUCCESS_PCT, FeeEstimateHorizon::MED_HALFLIFE);
 }
 
+ForecastResult CBlockPolicyEstimator::ForecastFeeRate(int target, bool conservative) const
+{
+    ForecastResult result;
+    result.forecaster = ForecastType::BLOCK_POLICY;
+    FeeCalculation feeCalcConservative;
+    CFeeRate feerate{estimateSmartFee(target, &feeCalcConservative, conservative)};
+    result.current_block_height = feeCalcConservative.bestheight;
+    if (feerate == CFeeRate(0)) {
+        result.error = "Insufficient data or no feerate found";
+        return result;
+    }
+    // Note: size can be any positive non-zero integer; the evaluated fee/size will result in the same fee rate,
+    // and we only care that the fee rate remains consistent.
+    int32_t size = 1000;
+    result.feerate = FeeFrac(feerate.GetFee(size), size);
+    return result;
+}
+
+unsigned int CBlockPolicyEstimator::MaximumTarget() const
+{
+    return HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);
+}
+
 CFeeRate CBlockPolicyEstimator::estimateRawFee(int confTarget, double successThreshold, FeeEstimateHorizon horizon, EstimationResult* result) const
 {
     TxConfirmStats* stats = nullptr;
diff --git a/src/policy/fees/block_policy_estimator.h b/src/policy/fees/block_policy_estimator.h
index 61c1992243cfb..b967d0d299926 100644
--- a/src/policy/fees/block_policy_estimator.h
+++ b/src/policy/fees/block_policy_estimator.h
@@ -7,6 +7,7 @@
 
 #include <consensus/amount.h>
 #include <policy/feerate.h>
+#include <policy/fees/forecaster.h>
 #include <random.h>
 #include <sync.h>
 #include <threadsafety.h>
@@ -37,6 +38,8 @@ static constexpr bool DEFAULT_ACCEPT_STALE_FEE_ESTIMATES{false};
 
 class AutoFile;
 class TxConfirmStats;
+
+struct ForecastResult;
 struct RemovedMempoolTransactionInfo;
 struct NewMempoolTransactionInfo;
 
@@ -146,7 +149,7 @@ struct FeeCalculation
  * a certain number of blocks.  Every time a block is added to the best chain, this class records
  * stats on the transactions included in that block
  */
-class CBlockPolicyEstimator : public CValidationInterface
+class CBlockPolicyEstimator : public Forecaster, public CValidationInterface
 {
 private:
     /** Track confirm delays up to 12 blocks for short horizon */
@@ -263,6 +266,10 @@ class CBlockPolicyEstimator : public CValidationInterface
     /** Calculates the age of the file, since last modified */
     std::chrono::hours GetFeeEstimatorFileAge();
 
+    /** Overridden from Forecaster. */
+    unsigned int MaximumTarget() const override
+        EXCLUSIVE_LOCKS_REQUIRED(!m_cs_fee_estimator);
+
 protected:
     /** Overridden from CValidationInterface. */
     void TransactionAddedToMempool(const NewMempoolTransactionInfo& tx, uint64_t /*unused*/) override
@@ -272,6 +279,10 @@ class CBlockPolicyEstimator : public CValidationInterface
     void MempoolTransactionsRemovedForBlock(const std::vector<RemovedMempoolTransactionInfo>& txs_removed_for_block, unsigned int nBlockHeight) override
         EXCLUSIVE_LOCKS_REQUIRED(!m_cs_fee_estimator);
 
+    /** Overridden from Forecaster. */
+    ForecastResult ForecastFeeRate(int target, bool conservative) const override
+        EXCLUSIVE_LOCKS_REQUIRED(!m_cs_fee_estimator);
+
 private:
     mutable Mutex m_cs_fee_estimator;
 
diff --git a/src/policy/fees/forecaster_util.h b/src/policy/fees/forecaster_util.h
index 11dac144aacaf..a6178683faa88 100644
--- a/src/policy/fees/forecaster_util.h
+++ b/src/policy/fees/forecaster_util.h
@@ -14,7 +14,9 @@
  * @enum ForecastType
  * Identifier for fee rate forecasters.
  */
-enum class ForecastType {};
+enum class ForecastType {
+    BLOCK_POLICY,
+};
 
 /**
  * @struct ForecastResult
diff --git a/src/rpc/fees.cpp b/src/rpc/fees.cpp
index 4e95cf215b1a4..4a57e2ee192df 100644
--- a/src/rpc/fees.cpp
+++ b/src/rpc/fees.cpp
@@ -65,7 +65,7 @@ static RPCHelpMan estimatesmartfee()
             const CTxMemPool& mempool = EnsureMemPool(node);
 
             CHECK_NONFATAL(mempool.m_opts.signals)->SyncWithValidationInterfaceQueue();
-            unsigned int max_target = fee_estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);
+            unsigned int max_target = fee_estimator.MaximumTarget();
             unsigned int conf_target = ParseConfirmTarget(request.params[0], max_target);
             bool conservative = false;
             if (!request.params[1].isNull()) {
```
</details>

### [fees: add block policy estimator to forecaster manager](https://github.com/bitcoin/bitcoin/pull/31664/commits/4aa9dd79023684a3a3a33f0d6a8fe740ddc37414)

	- This changes `CBlockPolicyEstimator` to a shared pointer
	  this gives us three advantages.
	   - Registering to validation interface using shared pointer
	   - Scheduling block policy estimator flushes using shared pointer
	   - Registering block policy estimator to forecaster_man

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/init.cpp b/src/init.cpp
index 71c3c918f5e75..1e4e0bea08c92 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -59,6 +59,7 @@
 #include <policy/feerate.h>
 #include <policy/fees/block_policy_estimator.h>
 #include <policy/fees/block_policy_estimator_args.h>
+#include <policy/fees/forecaster_man.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
 #include <protocol.h>
@@ -325,13 +326,9 @@ void Shutdown(NodeContext& node)
         DumpMempool(*node.mempool, MempoolPath(*node.args));
     }
 
-    // Drop transactions we were still watching, record fee estimations and unregister
-    // fee estimator from validation interface.
-    if (node.fee_estimator) {
-        node.fee_estimator->Flush();
-        if (node.validation_signals) {
-            node.validation_signals->UnregisterValidationInterface(node.fee_estimator.get());
-        }
+    // Drop transactions we were still watching, record fee estimations.
+    if (node.forecasterman) {
+        node.forecasterman->GetBlockPolicyEstimator()->Flush();
     }
 
     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing
@@ -386,7 +383,7 @@ void Shutdown(NodeContext& node)
         node.validation_signals->UnregisterAllValidationInterfaces();
     }
     node.mempool.reset();
-    node.fee_estimator.reset();
+    node.forecasterman.reset();
     node.chainman.reset();
     node.validation_signals.reset();
     node.scheduler.reset();
@@ -1466,7 +1463,7 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
                                               rng.rand64(),
                                               *node.addrman, *node.netgroupman, chainparams, args.GetBoolArg("-networkactive", true));
 
-    assert(!node.fee_estimator);
+    assert(!node.forecasterman);
     // Don't initialize fee estimation with old data if we don't relay transactions,
     // as they would never get updated.
     if (!peerman_opts.ignore_incoming_txs) {
@@ -1474,12 +1471,14 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
         if (read_stale_estimates && (chainparams.GetChainType() != ChainType::REGTEST)) {
             return InitError(strprintf(_("acceptstalefeeestimates is not supported on %s chain."), chainparams.GetChainTypeString()));
         }
-        node.fee_estimator = std::make_unique<CBlockPolicyEstimator>(FeeestPath(args), read_stale_estimates);
-
-        // Flush estimates to disk periodically
-        CBlockPolicyEstimator* fee_estimator = node.fee_estimator.get();
-        scheduler.scheduleEvery([fee_estimator] { fee_estimator->FlushFeeEstimates(); }, FEE_FLUSH_INTERVAL);
-        validation_signals.RegisterValidationInterface(fee_estimator);
+        node.forecasterman = std::make_unique<FeeRateForecasterManager>();
+        auto block_policy_estimator = std::make_shared<CBlockPolicyEstimator>(FeeestPath(args), read_stale_estimates);
+        validation_signals.RegisterSharedValidationInterface(block_policy_estimator);
+        // Flush block policy estimates to disk periodically
+        scheduler.scheduleEvery([block_policy_estimator] { block_policy_estimator->FlushFeeEstimates(); }, FEE_FLUSH_INTERVAL);
+
+        // Register block policy estimator to forecaster manager
+        node.forecasterman->RegisterForecaster(block_policy_estimator);
     }
 
     for (const std::string& socket_addr : args.GetArgs("-bind")) {
diff --git a/src/node/context.cpp b/src/node/context.cpp
index bfec54bc0f525..762c663de49d8 100644
--- a/src/node/context.cpp
+++ b/src/node/context.cpp
@@ -15,7 +15,7 @@
 #include <netgroup.h>
 #include <node/kernel_notifications.h>
 #include <node/warnings.h>
-#include <policy/fees/block_policy_estimator.h>
+#include <policy/fees/forecaster_man.h>
 #include <scheduler.h>
 #include <txmempool.h>
 #include <validation.h>
diff --git a/src/node/context.h b/src/node/context.h
index debc12212064c..26d33b051b74d 100644
--- a/src/node/context.h
+++ b/src/node/context.h
@@ -16,7 +16,7 @@ class ArgsManager;
 class AddrMan;
 class BanMan;
 class BaseIndex;
-class CBlockPolicyEstimator;
+class FeeRateForecasterManager;
 class CConnman;
 class ValidationSignals;
 class CScheduler;
@@ -67,7 +67,7 @@ struct NodeContext {
     std::unique_ptr<CConnman> connman;
     std::unique_ptr<CTxMemPool> mempool;
     std::unique_ptr<const NetGroupManager> netgroupman;
-    std::unique_ptr<CBlockPolicyEstimator> fee_estimator;
+    std::unique_ptr<FeeRateForecasterManager> forecasterman;
     std::unique_ptr<PeerManager> peerman;
     std::unique_ptr<ChainstateManager> chainman;
     std::unique_ptr<BanMan> banman;
diff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp
index 833dc5c736d81..7bbda20239b84 100644
--- a/src/node/interfaces.cpp
+++ b/src/node/interfaces.cpp
@@ -41,6 +41,7 @@
 #include <node/warnings.h>
 #include <policy/feerate.h>
 #include <policy/fees/block_policy_estimator.h>
+#include <policy/fees/forecaster_man.h>
 #include <policy/policy.h>
 #include <policy/rbf.h>
 #include <policy/settings.h>
@@ -739,13 +740,13 @@ class ChainImpl : public Chain
     }
     CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override
     {
-        if (!m_node.fee_estimator) return {};
-        return m_node.fee_estimator->estimateSmartFee(num_blocks, calc, conservative);
+        if (!m_node.forecasterman) return {};
+        return m_node.forecasterman->GetBlockPolicyEstimator()->estimateSmartFee(num_blocks, calc, conservative);
     }
     unsigned int estimateMaxBlocks() override
     {
-        if (!m_node.fee_estimator) return 0;
-        return m_node.fee_estimator->HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);
+        if (!m_node.forecasterman) return 0;
+        return m_node.forecasterman->GetBlockPolicyEstimator()->MaximumTarget();
     }
     CFeeRate mempoolMinFee() override
     {
diff --git a/src/policy/fees/block_policy_estimator.cpp b/src/policy/fees/block_policy_estimator.cpp
index b47246da1e3ea..7784903d9ed3e 100644
--- a/src/policy/fees/block_policy_estimator.cpp
+++ b/src/policy/fees/block_policy_estimator.cpp
@@ -728,9 +728,9 @@ ForecastResult CBlockPolicyEstimator::ForecastFeeRate(int target, bool conservat
 {
     ForecastResult result;
     result.forecaster = ForecastType::BLOCK_POLICY;
-    FeeCalculation feeCalcConservative;
-    CFeeRate feerate{estimateSmartFee(target, &feeCalcConservative, conservative)};
-    result.current_block_height = feeCalcConservative.bestheight;
+    FeeCalculation fee_calculation_result;
+    CFeeRate feerate{estimateSmartFee(target, &fee_calculation_result, conservative)};
+    result.current_block_height = fee_calculation_result.best_height;
     if (feerate == CFeeRate(0)) {
         result.error = "Insufficient data or no feerate found";
         return result;
diff --git a/src/policy/fees/forecaster_man.cpp b/src/policy/fees/forecaster_man.cpp
index 462fb2c80262f..9157daab8bfe5 100644
--- a/src/policy/fees/forecaster_man.cpp
+++ b/src/policy/fees/forecaster_man.cpp
@@ -2,6 +2,7 @@
 // Distributed under the MIT software license. See the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
+#include <policy/fees/block_policy_estimator.h>
 #include <policy/fees/forecaster.h>
 #include <policy/fees/forecaster_man.h>
 #include <policy/fees/forecaster_util.h>
@@ -12,3 +13,10 @@ void FeeRateForecasterManager::RegisterForecaster(std::shared_ptr<Forecaster> fo
 {
     forecasters.emplace(forecaster->GetForecastType(), forecaster);
 }
+
+CBlockPolicyEstimator* FeeRateForecasterManager::GetBlockPolicyEstimator()
+{
+    Assert(forecasters.contains(ForecastType::BLOCK_POLICY));
+    Forecaster* block_policy_estimator = forecasters.find(ForecastType::BLOCK_POLICY)->second.get();
+    return dynamic_cast<CBlockPolicyEstimator*>(block_policy_estimator);
+}
diff --git a/src/policy/fees/forecaster_man.h b/src/policy/fees/forecaster_man.h
index 9c70b5ab115ba..f6b409ec402c6 100644
--- a/src/policy/fees/forecaster_man.h
+++ b/src/policy/fees/forecaster_man.h
@@ -8,6 +8,7 @@
 #include <memory>
 #include <unordered_map>
 
+class CBlockPolicyEstimator;
 class Forecaster;
 struct ForecastResult;
 
@@ -28,6 +29,11 @@ class FeeRateForecasterManager
      * @param[in] forecaster shared pointer to a Forecaster instance.
      */
     void RegisterForecaster(std::shared_ptr<Forecaster> forecaster);
+
+    /*
+     * Return the pointer to block policy estimator.
+     */
+    CBlockPolicyEstimator* GetBlockPolicyEstimator();
 };
 
 #endif // BITCOIN_POLICY_FEES_FORECASTER_MAN_H
diff --git a/src/rpc/fees.cpp b/src/rpc/fees.cpp
index 4a57e2ee192df..c1240a97b3b16 100644
--- a/src/rpc/fees.cpp
+++ b/src/rpc/fees.cpp
@@ -8,6 +8,7 @@
 #include <node/context.h>
 #include <policy/feerate.h>
 #include <policy/fees/block_policy_estimator.h>
+#include <policy/fees/forecaster_man.h>
 #include <rpc/protocol.h>
 #include <rpc/request.h>
 #include <rpc/server.h>
@@ -60,12 +61,12 @@ static RPCHelpMan estimatesmartfee()
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
         {
-            CBlockPolicyEstimator& fee_estimator = EnsureAnyFeeEstimator(request.context);
+            CBlockPolicyEstimator& block_policy_fee_estimator = *(EnsureAnyForecasterMan(request.context).GetBlockPolicyEstimator());
             const NodeContext& node = EnsureAnyNodeContext(request.context);
             const CTxMemPool& mempool = EnsureMemPool(node);
 
             CHECK_NONFATAL(mempool.m_opts.signals)->SyncWithValidationInterfaceQueue();
-            unsigned int max_target = fee_estimator.MaximumTarget();
+            unsigned int max_target = block_policy_fee_estimator.MaximumTarget();
             unsigned int conf_target = ParseConfirmTarget(request.params[0], max_target);
             bool conservative = false;
             if (!request.params[1].isNull()) {
@@ -79,7 +80,7 @@ static RPCHelpMan estimatesmartfee()
             UniValue result(UniValue::VOBJ);
             UniValue errors(UniValue::VARR);
             FeeCalculation feeCalc;
-            CFeeRate feeRate{fee_estimator.estimateSmartFee(conf_target, &feeCalc, conservative)};
+            CFeeRate feeRate{block_policy_fee_estimator.estimateSmartFee(conf_target, &feeCalc, conservative)};
             if (feeRate != CFeeRate(0)) {
                 CFeeRate min_mempool_feerate{mempool.GetMinFee()};
                 CFeeRate min_relay_feerate{mempool.m_opts.min_relay_feerate};
@@ -152,11 +153,11 @@ static RPCHelpMan estimaterawfee()
         },
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
         {
-            CBlockPolicyEstimator& fee_estimator = EnsureAnyFeeEstimator(request.context);
+            CBlockPolicyEstimator& block_policy_fee_estimator = *(EnsureAnyForecasterMan(request.context).GetBlockPolicyEstimator());
             const NodeContext& node = EnsureAnyNodeContext(request.context);
 
             CHECK_NONFATAL(node.validation_signals)->SyncWithValidationInterfaceQueue();
-            unsigned int max_target = fee_estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);
+            unsigned int max_target = block_policy_fee_estimator.MaximumTarget();
             unsigned int conf_target = ParseConfirmTarget(request.params[0], max_target);
             double threshold = 0.95;
             if (!request.params[1].isNull()) {
@@ -173,9 +174,9 @@ static RPCHelpMan estimaterawfee()
                 EstimationResult buckets;
 
                 // Only output results for horizons which track the target
-                if (conf_target > fee_estimator.HighestTargetTracked(horizon)) continue;
+                if (conf_target > block_policy_fee_estimator.HighestTargetTracked(horizon)) continue;
 
-                feeRate = fee_estimator.estimateRawFee(conf_target, threshold, horizon, &buckets);
+                feeRate = block_policy_fee_estimator.estimateRawFee(conf_target, threshold, horizon, &buckets);
                 UniValue horizon_result(UniValue::VOBJ);
                 UniValue errors(UniValue::VARR);
                 UniValue passbucket(UniValue::VOBJ);
diff --git a/src/rpc/server_util.cpp b/src/rpc/server_util.cpp
index a0b19925386a1..e0693c060a178 100644
--- a/src/rpc/server_util.cpp
+++ b/src/rpc/server_util.cpp
@@ -84,19 +84,20 @@ ChainstateManager& EnsureAnyChainman(const std::any& context)
     return EnsureChainman(EnsureAnyNodeContext(context));
 }
 
-CBlockPolicyEstimator& EnsureFeeEstimator(const NodeContext& node)
+FeeRateForecasterManager& EnsureForecasterMan(const NodeContext& node)
 {
-    if (!node.fee_estimator) {
+    if (!node.forecasterman) {
         throw JSONRPCError(RPC_INTERNAL_ERROR, "Fee estimation disabled");
     }
-    return *node.fee_estimator;
+    return *node.forecasterman.get();
 }
 
-CBlockPolicyEstimator& EnsureAnyFeeEstimator(const std::any& context)
+FeeRateForecasterManager& EnsureAnyForecasterMan(const std::any& context)
 {
-    return EnsureFeeEstimator(EnsureAnyNodeContext(context));
+    return EnsureForecasterMan(EnsureAnyNodeContext(context));
 }
 
+
 CConnman& EnsureConnman(const NodeContext& node)
 {
     if (!node.connman) {
diff --git a/src/rpc/server_util.h b/src/rpc/server_util.h
index 6fb5e1c9b35bc..fd79a042fd149 100644
--- a/src/rpc/server_util.h
+++ b/src/rpc/server_util.h
@@ -12,10 +12,10 @@
 class AddrMan;
 class ArgsManager;
 class CBlockIndex;
-class CBlockPolicyEstimator;
 class CConnman;
 class CTxMemPool;
 class ChainstateManager;
+class FeeRateForecasterManager;
 class PeerManager;
 class BanMan;
 namespace node {
@@ -34,8 +34,8 @@ ArgsManager& EnsureArgsman(const node::NodeContext& node);
 ArgsManager& EnsureAnyArgsman(const std::any& context);
 ChainstateManager& EnsureChainman(const node::NodeContext& node);
 ChainstateManager& EnsureAnyChainman(const std::any& context);
-CBlockPolicyEstimator& EnsureFeeEstimator(const node::NodeContext& node);
-CBlockPolicyEstimator& EnsureAnyFeeEstimator(const std::any& context);
+FeeRateForecasterManager& EnsureForecasterMan(const node::NodeContext& node);
+FeeRateForecasterManager& EnsureAnyForecasterMan(const std::any& context);
 CConnman& EnsureConnman(const node::NodeContext& node);
 interfaces::Mining& EnsureMining(const node::NodeContext& node);
 PeerManager& EnsurePeerman(const node::NodeContext& node);
diff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp
index 3252500f1bfaa..06b63d1b95351 100644
--- a/src/test/util/setup_common.cpp
+++ b/src/test/util/setup_common.cpp
@@ -288,7 +288,7 @@ ChainTestingSetup::~ChainTestingSetup()
     m_node.netgroupman.reset();
     m_node.args = nullptr;
     m_node.mempool.reset();
-    Assert(!m_node.fee_estimator); // Each test must create a local object, if they wish to use the fee_estimator
+    Assert(!m_node.forecasterman); // Each test must create a local object, if they wish to use the forecasterman
     m_node.chainman.reset();
     m_node.validation_signals.reset();
     m_node.scheduler.reset();
```
</details>

### [fees: add `forecastTypeToString` method](https://github.com/bitcoin/bitcoin/pull/31664/commits/144ca4c2583af8e8d3ece8570319477805ff3a26)

	- This method converts a ForecastType enum to its
	  string representation.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index bae1530b21e09..0e71eecf7f65b 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -167,6 +167,7 @@ add_library(bitcoin_common STATIC EXCLUDE_FROM_ALL
   netbase.cpp
   outputtype.cpp
   policy/feerate.cpp
+  policy/fees/forecaster_util.cpp
   policy/policy.cpp
   pow.cpp
   protocol.cpp
diff --git a/src/policy/fees/forecaster_util.cpp b/src/policy/fees/forecaster_util.cpp
new file mode 100644
index 0000000000000..79ff1f8adbd72
--- /dev/null
+++ b/src/policy/fees/forecaster_util.cpp
@@ -0,0 +1,15 @@
+// Copyright (c) 2025 The Bitcoin Core developers
+// Distributed under the MIT software license. See the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <policy/fees/forecaster_util.h>
+
+std::string forecastTypeToString(ForecastType forecastType)
+{
+    switch (forecastType) {
+    case ForecastType::BLOCK_POLICY:
+        return std::string("Block Policy Estimator");
+    }
+    // no default case, so the compiler can warn about missing cases
+    assert(false);
+}
diff --git a/src/policy/fees/forecaster_util.h b/src/policy/fees/forecaster_util.h
index a6178683faa88..ae274d83fb5c8 100644
--- a/src/policy/fees/forecaster_util.h
+++ b/src/policy/fees/forecaster_util.h
@@ -45,4 +45,6 @@ struct ForecastResult {
     }
 };
 
+std::string forecastTypeToString(ForecastType forecastType);
+
 #endif // BITCOIN_POLICY_FEES_FORECASTER_UTIL_H
```
</details>

### [fees: add `CalculatePercentiles` function](https://github.com/bitcoin/bitcoin/pull/31664/commits/eea285565d8adbd94d0b789dd1b00731de40ce79)

	- The CalculatePercentiles function, given
	  a vector of feerates in the order they were added
	  to the block, will return the 25th, 50th, 75th,
	  and 95th percentile feerates.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/policy/fees/forecaster_util.cpp b/src/policy/fees/forecaster_util.cpp
index 79ff1f8adbd72..21eb8a749340b 100644
--- a/src/policy/fees/forecaster_util.cpp
+++ b/src/policy/fees/forecaster_util.cpp
@@ -3,6 +3,46 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <policy/fees/forecaster_util.h>
+#include <policy/policy.h>
+
+#include <algorithm>
+
+Percentiles CalculatePercentiles(const std::vector<FeeFrac>& package_feerates, const int32_t total_weight)
+{
+    if (package_feerates.empty()) return Percentiles{};
+    int32_t accumulated_weight{0};
+    const int32_t p25_weight = 0.25 * total_weight;
+    const int32_t p50_weight = 0.50 * total_weight;
+    const int32_t p75_weight = 0.75 * total_weight;
+    const int32_t p95_weight = 0.95 * total_weight;
+    auto last_tracked_feerate = package_feerates.front();
+    auto percentiles = Percentiles{};
+
+    // Process histogram entries while maintaining monotonicity
+    for (const auto& curr_feerate : package_feerates) {
+        accumulated_weight += curr_feerate.size * WITNESS_SCALE_FACTOR;
+        // Maintain monotonicity by taking the minimum between the current and last tracked fee rate
+        last_tracked_feerate = std::min(last_tracked_feerate, curr_feerate, [](const FeeFrac& a, const FeeFrac& b) {
+            return std::is_lt(FeeRateCompare(a, b));
+        });
+        if (accumulated_weight >= p25_weight && percentiles.p25.IsEmpty()) {
+            percentiles.p25 = last_tracked_feerate;
+        }
+        if (accumulated_weight >= p50_weight && percentiles.p50.IsEmpty()) {
+            percentiles.p50 = last_tracked_feerate;
+        }
+        if (accumulated_weight >= p75_weight && percentiles.p75.IsEmpty()) {
+            percentiles.p75 = last_tracked_feerate;
+        }
+        if (accumulated_weight >= p95_weight && percentiles.p95.IsEmpty()) {
+            percentiles.p95 = last_tracked_feerate;
+            break; // Early exit once all percentiles are calculated
+        }
+    }
+
+    // Return empty percentiles if we couldn't calculate the 95th percentile.
+    return percentiles.p95.IsEmpty() ? Percentiles{} : percentiles;
+}
 
 std::string forecastTypeToString(ForecastType forecastType)
 {
diff --git a/src/policy/fees/forecaster_util.h b/src/policy/fees/forecaster_util.h
index ae274d83fb5c8..ec0fea96cfe1e 100644
--- a/src/policy/fees/forecaster_util.h
+++ b/src/policy/fees/forecaster_util.h
@@ -45,6 +45,36 @@ struct ForecastResult {
     }
 };
 
+// Block percentiles fee rate (in BTC/vB).
+struct Percentiles {
+    FeeFrac p25;
+    FeeFrac p50;
+    FeeFrac p75;
+    FeeFrac p95;
+
+    Percentiles() = default;
+
+    bool empty() const
+    {
+        return p25.IsEmpty() && p50.IsEmpty() && p75.IsEmpty() && p95.IsEmpty();
+    }
+};
+
+/**
+ * Calculates the percentile fee rates from a given vector of fee rates.
+ *
+ * This function assumes that the fee rates in the input vector are sorted in descending order
+ * based on mining score priority. It ensures that the calculated percentile fee rates
+ * are monotonically decreasing by filtering out outliers. Outliers can occur when
+ * the mining score of a transaction increases due to the inclusion of its ancestors
+ * in different transaction packages.
+ *
+ * @param[in] package_feerates A vector containing packages fee rates.
+ * @param[in] total_weight The total weight units to use for percentile fee rate calculations.
+ * @return Percentiles object containing the calculated percentile fee rates.
+ */
+Percentiles CalculatePercentiles(const std::vector<FeeFrac>& package_feerates, const int32_t total_weight);
+
 std::string forecastTypeToString(ForecastType forecastType);
 
 #endif // BITCOIN_POLICY_FEES_FORECASTER_UTIL_H
diff --git a/src/test/CMakeLists.txt b/src/test/CMakeLists.txt
index f803d24c91aa6..18084a2326f1a 100644
--- a/src/test/CMakeLists.txt
+++ b/src/test/CMakeLists.txt
@@ -42,6 +42,7 @@ add_executable(test_bitcoin
   disconnected_transactions.cpp
   feefrac_tests.cpp
   feerounder_tests.cpp
+  forecaster_util_tests.cpp
   flatfile_tests.cpp
   fs_tests.cpp
   getarg_tests.cpp
diff --git a/src/test/forecaster_util_tests.cpp b/src/test/forecaster_util_tests.cpp
new file mode 100644
index 0000000000000..923c2c04ebaef
--- /dev/null
+++ b/src/test/forecaster_util_tests.cpp
@@ -0,0 +1,64 @@
+// Copyright (c) 2024 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+
+#include <policy/fees/forecaster_util.h>
+#include <policy/policy.h>
+
+#include <boost/test/unit_test.hpp>
+#include <vector>
+
+BOOST_AUTO_TEST_SUITE(forecaster_util_tests)
+
+BOOST_AUTO_TEST_CASE(calculate_percentile_test)
+{
+    // Test that CalculatePercentiles returns empty when vector is empty
+    BOOST_CHECK(CalculatePercentiles({}, DEFAULT_BLOCK_MAX_WEIGHT).empty());
+
+    const int32_t package_size{10};
+    const int32_t individual_tx_vsize = static_cast<int32_t>(DEFAULT_BLOCK_MAX_WEIGHT / WITNESS_SCALE_FACTOR) / package_size;
+
+    const FeeFrac super_high_fee_rate{500 * individual_tx_vsize, individual_tx_vsize}; // Super High fee: 500 sat/kvB
+    const FeeFrac high_fee_rate{100 * individual_tx_vsize, individual_tx_vsize};       // High fee: 100 sat/kvB
+    const FeeFrac medium_fee_rate{50 * individual_tx_vsize, individual_tx_vsize};      // Medium fee: 50 sat/kvB
+    const FeeFrac low_fee_rate{10 * individual_tx_vsize, individual_tx_vsize};         // Low fee: 10 sat/kvB
+
+    std::vector<FeeFrac> package_feerates;
+    package_feerates.reserve(package_size);
+
+    // Populate the feerate histogram based on specified index ranges.
+    for (int i = 0; i < package_size; ++i) {
+        if (i < 3) {
+            package_feerates.emplace_back(super_high_fee_rate); // Super High fee rate for top 3
+        } else if (i < 5) {
+            package_feerates.emplace_back(high_fee_rate); // High fee rate for next 2
+        } else if (i < 8) {
+            package_feerates.emplace_back(medium_fee_rate);                                          // Medium fee rate for next 3
+            BOOST_CHECK(CalculatePercentiles(package_feerates, DEFAULT_BLOCK_MAX_WEIGHT).empty());   // CalculatePercentiles should return empty until reaching the 95th percentile
+        } else {
+            package_feerates.emplace_back(low_fee_rate); // Low fee rate for remaining 2
+        }
+    }
+
+    // Test percentile calculation on a complete histogram
+    {
+        const auto percentiles = CalculatePercentiles(package_feerates, DEFAULT_BLOCK_MAX_WEIGHT);
+        BOOST_CHECK(percentiles.p25 == super_high_fee_rate);
+        BOOST_CHECK(percentiles.p50 == high_fee_rate);
+        BOOST_CHECK(percentiles.p75 == medium_fee_rate);
+        BOOST_CHECK(percentiles.p95 == low_fee_rate);
+    }
+
+    // Test that CalculatePercentiles maintains monotonicity across all percentiles
+    {
+        package_feerates[7] = super_high_fee_rate; // Increase 8th index to a high fee rate
+        const auto percentiles = CalculatePercentiles(package_feerates, DEFAULT_BLOCK_MAX_WEIGHT);
+        BOOST_CHECK(percentiles.p25 == super_high_fee_rate);
+        BOOST_CHECK(percentiles.p50 == high_fee_rate);
+        BOOST_CHECK(percentiles.p75 == medium_fee_rate); // Should still reflect the previous medium rate
+        BOOST_CHECK(percentiles.p95 == low_fee_rate);
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
```
</details>

### [fees: add `MemPoolForecaster` class](https://github.com/bitcoin/bitcoin/pull/31664/commits/1df624b1cbefb9772ea0f9d37d87a8afea4f9d23)

	- The mempool forecaster uses the unconfirmed transactions in the mempool
	  to generate a fee rate that a package should have for it to confirm as soon as possible.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 0e71eecf7f65b..e86bd6d53b1d0 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -286,6 +286,7 @@ add_library(bitcoin_node STATIC EXCLUDE_FROM_ALL
   policy/fees/block_policy_estimator.cpp
   policy/fees/block_policy_estimator_args.cpp
   policy/fees/forecaster_man.cpp
+  policy/fees/mempool_forecaster.cpp
   policy/packages.cpp
   policy/rbf.cpp
   policy/settings.cpp
diff --git a/src/policy/fees/forecaster_util.cpp b/src/policy/fees/forecaster_util.cpp
index 21eb8a749340b..966ed2c9bfeb2 100644
--- a/src/policy/fees/forecaster_util.cpp
+++ b/src/policy/fees/forecaster_util.cpp
@@ -47,6 +47,8 @@ Percentiles CalculatePercentiles(const std::vector<FeeFrac>& package_feerates, c
 std::string forecastTypeToString(ForecastType forecastType)
 {
     switch (forecastType) {
+    case ForecastType::MEMPOOL_FORECAST:
+        return std::string("Mempool Forecast");
     case ForecastType::BLOCK_POLICY:
         return std::string("Block Policy Estimator");
     }
diff --git a/src/policy/fees/forecaster_util.h b/src/policy/fees/forecaster_util.h
index ec0fea96cfe1e..394c2f3770ff1 100644
--- a/src/policy/fees/forecaster_util.h
+++ b/src/policy/fees/forecaster_util.h
@@ -16,6 +16,7 @@
  */
 enum class ForecastType {
     BLOCK_POLICY,
+    MEMPOOL_FORECAST,
 };
 
 /**
diff --git a/src/policy/fees/mempool_forecaster.cpp b/src/policy/fees/mempool_forecaster.cpp
new file mode 100644
index 0000000000000..027beb29a2a6b
--- /dev/null
+++ b/src/policy/fees/mempool_forecaster.cpp
@@ -0,0 +1,55 @@
+// Copyright (c) 2024 The Bitcoin Core developers
+// Distributed under the MIT software license. See the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <logging.h>
+#include <node/miner.h>
+#include <policy/fees/forecaster.h>
+#include <policy/fees/forecaster_util.h>
+#include <policy/fees/mempool_forecaster.h>
+#include <policy/policy.h>
+#include <validation.h>
+
+ForecastResult MemPoolForecaster::ForecastFeeRate(int target, bool conservative) const
+{
+    ForecastResult result;
+    result.forecaster = m_forecast_type;
+    LOCK2(cs_main, m_mempool->cs);
+    auto activeTip = m_chainstate->m_chainman.ActiveTip();
+    if (!activeTip) {
+        result.error = "No active chainstate available";
+        return result;
+    }
+    result.current_block_height = static_cast<unsigned int>(activeTip->nHeight);
+
+    if (target > MEMPOOL_FORECAST_MAX_TARGET) {
+        result.error = strprintf("Confirmation target %s exceeds the maximum limit of %s. mempool conditions might change",
+                                   target, MEMPOOL_FORECAST_MAX_TARGET);
+        return result;
+    }
+
+    node::BlockAssembler::Options options;
+    options.test_block_validity = false;
+    node::BlockAssembler assembler(*m_chainstate, m_mempool, options);
+
+    const auto pblocktemplate = assembler.CreateNewBlock();
+    const auto& m_package_feerates = pblocktemplate->m_package_feerates;
+    const auto percentiles = CalculatePercentiles(m_package_feerates, DEFAULT_BLOCK_MAX_WEIGHT);
+    if (percentiles.empty()) {
+        result.error = "Forecaster unable to provide a fee rate due to insufficient data";
+        return result;
+    }
+
+    LogDebug(BCLog::MEMPOOL,
+             "%s: Block height %s, Block template 25th percentile fee rate: %s %s/kvB, "
+             "50th percentile fee rate: %s %s/kvB, 75th percentile fee rate: %s %s/kvB, "
+             "95th percentile fee rate: %s %s/kvB\n",
+             forecastTypeToString(m_forecast_type), result.current_block_height,
+             CFeeRate(percentiles.p25.fee, percentiles.p25.size).GetFeePerK(), CURRENCY_ATOM,
+             CFeeRate(percentiles.p50.fee, percentiles.p50.size).GetFeePerK(), CURRENCY_ATOM,
+             CFeeRate(percentiles.p75.fee, percentiles.p75.size).GetFeePerK(), CURRENCY_ATOM,
+             CFeeRate(percentiles.p95.fee, percentiles.p95.size).GetFeePerK(), CURRENCY_ATOM);
+
+    result.feerate = conservative ? percentiles.p50 : percentiles.p75;
+    return result;
+}
diff --git a/src/policy/fees/mempool_forecaster.h b/src/policy/fees/mempool_forecaster.h
new file mode 100644
index 0000000000000..43e0d789bdd03
--- /dev/null
+++ b/src/policy/fees/mempool_forecaster.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2024 The Bitcoin Core developers
+// Distributed under the MIT software license. See the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_POLICY_FEES_MEMPOOL_FORECASTER_H
+#define BITCOIN_POLICY_FEES_MEMPOOL_FORECASTER_H
+
+
+#include <policy/fees/forecaster.h>
+
+class Chainstate;
+class CTxMemPool;
+
+// Fee rate forecasts above this confirmation target are not reliable,
+// as mempool conditions are likely to change.
+constexpr int MEMPOOL_FORECAST_MAX_TARGET{2};
+
+/** \class MemPoolForecaster
+ * @brief Forecasts the fee rate required for a transaction to be included in the next block.
+ *
+ * This forecaster uses Bitcoin Core's block-building algorithm to generate the block
+ * template that will likely be mined from unconfirmed transactions in the mempool. It calculates percentile
+ * fee rates from the selected packages of the template: the 75th percentile fee rate is used as the economical
+ * forecast, and the 50th fee rate percentile as the conservative forecast.
+ */
+class MemPoolForecaster : public Forecaster
+{
+public:
+    MemPoolForecaster(const CTxMemPool* mempool, Chainstate* chainstate)
+        : Forecaster(ForecastType::MEMPOOL_FORECAST), m_mempool(mempool), m_chainstate(chainstate) {};
+    ~MemPoolForecaster() = default;
+
+    /** Overridden from Forecaster. */
+    ForecastResult ForecastFeeRate(int target, bool conservative) const override;
+    unsigned int MaximumTarget() const override
+    {
+        return MEMPOOL_FORECAST_MAX_TARGET;
+    };
+
+private:
+    const CTxMemPool* m_mempool;
+    Chainstate* m_chainstate;
+};
+#endif // BITCOIN_POLICY_FEES_MEMPOOL_FORECASTER_H
```
</details>

### [test: add mempool forecaster unit test](https://github.com/bitcoin/bitcoin/pull/31664/commits/918e3b728b3df28e8bbdec476ddbb5d3d8914797)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/test/CMakeLists.txt b/src/test/CMakeLists.txt
index 18084a2326f1a..1a1a10a351d60 100644
--- a/src/test/CMakeLists.txt
+++ b/src/test/CMakeLists.txt
@@ -55,6 +55,7 @@ add_executable(test_bitcoin
   key_tests.cpp
   logging_tests.cpp
   mempool_tests.cpp
+  mempoolforecaster_tests.cpp
   merkle_tests.cpp
   merkleblock_tests.cpp
   miner_tests.cpp
diff --git a/src/test/mempoolforecaster_tests.cpp b/src/test/mempoolforecaster_tests.cpp
new file mode 100644
index 0000000000000..6e9f281a32f5d
--- /dev/null
+++ b/src/test/mempoolforecaster_tests.cpp
@@ -0,0 +1,100 @@
+// Copyright (c) 2024 The Bitcoin Core developers
+// Distributed under the MIT software license. See the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <policy/fees/forecaster.h>
+#include <policy/fees/forecaster_util.h>
+#include <policy/fees/mempool_forecaster.h>
+#include <random.h>
+#include <test/util/txmempool.h>
+#include <txmempool.h>
+#include <uint256.h>
+#include <util/feefrac.h>
+#include <util/strencodings.h>
+#include <validation.h>
+
+
+#include <test/util/setup_common.h>
+
+#include <memory>
+#include <string>
+
+#include <boost/test/unit_test.hpp>
+
+BOOST_FIXTURE_TEST_SUITE(mempoolforecaster_tests, TestChain100Setup)
+
+static inline CTransactionRef make_random_tx()
+{
+    auto rng = FastRandomContext();
+    auto tx = CMutableTransaction();
+    tx.vin.resize(1);
+    tx.vout.resize(1);
+    tx.vin[0].prevout.hash = Txid::FromUint256(rng.rand256());
+    tx.vin[0].prevout.n = 0;
+    tx.vin[0].scriptSig << OP_TRUE;
+    tx.vout[0].scriptPubKey = CScript() << OP_TRUE;
+    tx.vout[0].nValue = COIN;
+    return MakeTransactionRef(tx);
+}
+
+BOOST_AUTO_TEST_CASE(MempoolForecaster)
+{
+    auto mempool_forecaster = std::make_unique<MemPoolForecaster>(m_node.mempool.get(), &(m_node.chainman->ActiveChainstate()));
+    int conf_target = MEMPOOL_FORECAST_MAX_TARGET + 1;
+    LOCK2(cs_main, m_node.mempool->cs);
+    {
+        // Test when targetBlocks > MEMPOOL_FORECAST_MAX_TARGET
+        const auto result = mempool_forecaster->ForecastFeeRate(conf_target, /*conservative=*/true);
+        BOOST_CHECK(result.feerate.IsEmpty());
+        BOOST_CHECK(*result.error == strprintf("Confirmation target %s exceeds the maximum limit of %s. mempool conditions might change",
+                                                 conf_target, MEMPOOL_FORECAST_MAX_TARGET));
+    }
+
+    BOOST_CHECK(m_node.mempool->GetTotalTxSize() == 0);
+    TestMemPoolEntryHelper entry;
+
+    const CAmount low_fee{CENT / 3000};
+    const CAmount med_fee{CENT / 100};
+    const CAmount high_fee{CENT / 10};
+    std::string data_err = "Forecaster unable to provide a fee rate due to insufficient data";
+
+    conf_target = MEMPOOL_FORECAST_MAX_TARGET;
+    // Test when there are not enough mempool transactions to get an accurate forecast
+    {
+        // Add transactions with high_fee fee until mempool transactions weight is more than 25th percent of DEFAULT_BLOCK_MAX_WEIGHT
+        while (static_cast<int>(m_node.mempool->GetTotalTxSize() * WITNESS_SCALE_FACTOR) <= static_cast<int>(0.25 * DEFAULT_BLOCK_MAX_WEIGHT)) {
+            AddToMempool(*m_node.mempool, entry.Fee(high_fee).FromTx(make_random_tx()));
+        }
+        const auto result = mempool_forecaster->ForecastFeeRate(conf_target, /*conservative=*/true);
+        BOOST_CHECK(result.feerate.IsEmpty());
+        BOOST_CHECK(*result.error == data_err);
+    }
+
+    {
+        // Add transactions with med_fee fee until mempool transactions weight is more than 50th percent of DEFAULT_BLOCK_MAX_WEIGHT
+        while (static_cast<int>(m_node.mempool->GetTotalTxSize() * WITNESS_SCALE_FACTOR) <= static_cast<int>(0.5 * DEFAULT_BLOCK_MAX_WEIGHT)) {
+            AddToMempool(*m_node.mempool, entry.Fee(med_fee).FromTx(make_random_tx()));
+        }
+        const auto result = mempool_forecaster->ForecastFeeRate(conf_target, /*conservative=*/true);
+        BOOST_CHECK(result.feerate.IsEmpty());
+        BOOST_CHECK(*result.error == data_err);
+    }
+
+    // Mempool transactions are enough to provide feerate forecast
+    {
+        // Add low_fee transactions until mempool transactions weight is more than 95th percent of DEFAULT_BLOCK_MAX_WEIGHT
+        while (static_cast<int>(m_node.mempool->GetTotalTxSize() * WITNESS_SCALE_FACTOR) <= static_cast<int>(0.95 * DEFAULT_BLOCK_MAX_WEIGHT)) {
+            const auto txref = make_random_tx();
+            AddToMempool(*m_node.mempool, entry.Fee(low_fee).FromTx(make_random_tx()));
+        }
+
+        const auto result_conservative = mempool_forecaster->ForecastFeeRate(conf_target, /*conservative=*/true);
+        const auto result_economical = mempool_forecaster->ForecastFeeRate(conf_target, /*conservative=*/false);
+        BOOST_CHECK(!result_conservative.feerate.IsEmpty() && !result_economical.feerate.IsEmpty());
+        const auto tx_vsize = entry.FromTx(make_random_tx()).GetTxSize();
+        BOOST_CHECK(result_economical.feerate == FeeFrac(low_fee, tx_vsize));
+        BOOST_CHECK(result_conservative.feerate == FeeFrac(med_fee, tx_vsize));
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
```
</details>

### [fees: cache `MemPoolPolicyEstimator` forecasts](https://github.com/bitcoin/bitcoin/pull/31664/commits/c1eb10ab303251b617cfe633c1449ef02174c4c3)

	- Provide new forecast only when the time delta from previous
	  forecast is older than 30 seconds.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/policy/fees/mempool_forecaster.cpp b/src/policy/fees/mempool_forecaster.cpp
index 027beb29a2a6b..d1b4b1ad2f23e 100644
--- a/src/policy/fees/mempool_forecaster.cpp
+++ b/src/policy/fees/mempool_forecaster.cpp
@@ -28,6 +28,13 @@ ForecastResult MemPoolForecaster::ForecastFeeRate(int target, bool conservative)
         return result;
     }
 
+    const auto cached_estimate = cache.get_cached_forecast();
+    const auto known_chain_tip_hash = cache.get_chain_tip_hash();
+    if (cached_estimate && *activeTip->phashBlock == known_chain_tip_hash) {
+        result.feerate = conservative ? cached_estimate->p50 : cached_estimate->p75;
+        return result;
+    }
+
     node::BlockAssembler::Options options;
     options.test_block_validity = false;
     node::BlockAssembler assembler(*m_chainstate, m_mempool, options);
@@ -50,6 +57,7 @@ ForecastResult MemPoolForecaster::ForecastFeeRate(int target, bool conservative)
              CFeeRate(percentiles.p75.fee, percentiles.p75.size).GetFeePerK(), CURRENCY_ATOM,
              CFeeRate(percentiles.p95.fee, percentiles.p95.size).GetFeePerK(), CURRENCY_ATOM);
 
+    cache.update(percentiles, *activeTip->phashBlock);
     result.feerate = conservative ? percentiles.p50 : percentiles.p75;
     return result;
 }
diff --git a/src/policy/fees/mempool_forecaster.h b/src/policy/fees/mempool_forecaster.h
index 43e0d789bdd03..e06c3e6959435 100644
--- a/src/policy/fees/mempool_forecaster.h
+++ b/src/policy/fees/mempool_forecaster.h
@@ -6,7 +6,15 @@
 #define BITCOIN_POLICY_FEES_MEMPOOL_FORECASTER_H
 
 
+#include <logging.h>
 #include <policy/fees/forecaster.h>
+#include <policy/fees/forecaster_util.h>
+#include <sync.h>
+#include <uint256.h>
+#include <util/time.h>
+
+
+#include <chrono>
 
 class Chainstate;
 class CTxMemPool;
@@ -14,6 +22,53 @@ class CTxMemPool;
 // Fee rate forecasts above this confirmation target are not reliable,
 // as mempool conditions are likely to change.
 constexpr int MEMPOOL_FORECAST_MAX_TARGET{2};
+constexpr std::chrono::seconds CACHE_LIFE{7};
+
+/**
+ * CachedMempoolForecast holds a cache of recent fee rate forecasts.
+ * We only provide fresh fee rate if the last saved cache ages more than CACHE_LIFE.
+ */
+struct CachedMempoolForecast {
+private:
+    mutable Mutex cache_mutex;
+    uint256 chain_tip_hash GUARDED_BY(cache_mutex);
+    Percentiles fee_rate GUARDED_BY(cache_mutex);
+    NodeClock::time_point last_updated GUARDED_BY(cache_mutex){NodeClock::now() - CACHE_LIFE - std::chrono::seconds(1)};
+
+public:
+    CachedMempoolForecast() = default;
+    CachedMempoolForecast(const CachedMempoolForecast&) = delete;
+    CachedMempoolForecast& operator=(const CachedMempoolForecast&) = delete;
+
+    bool isStale() const EXCLUSIVE_LOCKS_REQUIRED(cache_mutex)
+    {
+        AssertLockHeld(cache_mutex);
+        return (last_updated + CACHE_LIFE) < NodeClock::now();
+    }
+
+    std::optional<Percentiles> get_cached_forecast() const EXCLUSIVE_LOCKS_REQUIRED(!cache_mutex)
+    {
+        LOCK(cache_mutex);
+        if (isStale()) return std::nullopt;
+        LogDebug(BCLog::ESTIMATEFEE, "%s: cache is not stale, using cached value\n", forecastTypeToString(ForecastType::MEMPOOL_FORECAST));
+        return fee_rate;
+    }
+
+    uint256 get_chain_tip_hash() const EXCLUSIVE_LOCKS_REQUIRED(!cache_mutex)
+    {
+        LOCK(cache_mutex);
+        return chain_tip_hash;
+    }
+
+    void update(const Percentiles& new_fee_rate, uint256 current_tip_hash) EXCLUSIVE_LOCKS_REQUIRED(!cache_mutex)
+    {
+        LOCK(cache_mutex);
+        fee_rate = new_fee_rate;
+        last_updated = NodeClock::now();
+        chain_tip_hash = current_tip_hash;
+        LogDebug(BCLog::ESTIMATEFEE, "%s: updated cache\n", forecastTypeToString(ForecastType::MEMPOOL_FORECAST));
+    }
+};
 
 /** \class MemPoolForecaster
  * @brief Forecasts the fee rate required for a transaction to be included in the next block.
@@ -40,5 +95,6 @@ class MemPoolForecaster : public Forecaster
 private:
     const CTxMemPool* m_mempool;
     Chainstate* m_chainstate;
+    mutable CachedMempoolForecast cache;
 };
 #endif // BITCOIN_POLICY_FEES_MEMPOOL_FORECASTER_H
```
</details>

### [fees: add `ForecastFeeRateFromForecasters` method](https://github.com/bitcoin/bitcoin/pull/31664/commits/bad72f1a24585768f4bac937a17597879063400e)

	- Polls all registered forecasters and selects the lowest fee rate.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/init.cpp b/src/init.cpp
index 1e4e0bea08c92..427eda1c9bc8b 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -60,6 +60,7 @@
 #include <policy/fees/block_policy_estimator.h>
 #include <policy/fees/block_policy_estimator_args.h>
 #include <policy/fees/forecaster_man.h>
+#include <policy/fees/mempool_forecaster.h>
 #include <policy/policy.h>
 #include <policy/settings.h>
 #include <protocol.h>
@@ -1463,24 +1464,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
                                               rng.rand64(),
                                               *node.addrman, *node.netgroupman, chainparams, args.GetBoolArg("-networkactive", true));
 
-    assert(!node.forecasterman);
-    // Don't initialize fee estimation with old data if we don't relay transactions,
-    // as they would never get updated.
-    if (!peerman_opts.ignore_incoming_txs) {
-        bool read_stale_estimates = args.GetBoolArg("-acceptstalefeeestimates", DEFAULT_ACCEPT_STALE_FEE_ESTIMATES);
-        if (read_stale_estimates && (chainparams.GetChainType() != ChainType::REGTEST)) {
-            return InitError(strprintf(_("acceptstalefeeestimates is not supported on %s chain."), chainparams.GetChainTypeString()));
-        }
-        node.forecasterman = std::make_unique<FeeRateForecasterManager>();
-        auto block_policy_estimator = std::make_shared<CBlockPolicyEstimator>(FeeestPath(args), read_stale_estimates);
-        validation_signals.RegisterSharedValidationInterface(block_policy_estimator);
-        // Flush block policy estimates to disk periodically
-        scheduler.scheduleEvery([block_policy_estimator] { block_policy_estimator->FlushFeeEstimates(); }, FEE_FLUSH_INTERVAL);
-
-        // Register block policy estimator to forecaster manager
-        node.forecasterman->RegisterForecaster(block_policy_estimator);
-    }
-
     for (const std::string& socket_addr : args.GetArgs("-bind")) {
         std::string host_out;
         uint16_t port_out{0};
@@ -1695,6 +1678,26 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)
 
     ChainstateManager& chainman = *Assert(node.chainman);
 
+    assert(!node.forecasterman);
+    // Don't initialize fee estimation with old data if we don't relay transactions,
+    // as they would never get updated.
+    if (!peerman_opts.ignore_incoming_txs) {
+        bool read_stale_estimates = args.GetBoolArg("-acceptstalefeeestimates", DEFAULT_ACCEPT_STALE_FEE_ESTIMATES);
+        if (read_stale_estimates && (chainparams.GetChainType() != ChainType::REGTEST)) {
+            return InitError(strprintf(_("acceptstalefeeestimates is not supported on %s chain."), chainparams.GetChainTypeString()));
+        }
+        node.forecasterman = std::make_unique<FeeRateForecasterManager>();
+        auto mempool_forecaster = std::make_shared<MemPoolForecaster>(node.mempool.get(), &(chainman.ActiveChainstate()));
+        node.forecasterman->RegisterForecaster(mempool_forecaster);
+        auto block_policy_estimator = std::make_shared<CBlockPolicyEstimator>(FeeestPath(args), read_stale_estimates);
+        validation_signals.RegisterSharedValidationInterface(block_policy_estimator);
+        // Flush block policy estimates to disk periodically
+        scheduler.scheduleEvery([block_policy_estimator] { block_policy_estimator->FlushFeeEstimates(); }, FEE_FLUSH_INTERVAL);
+
+        // Register block policy estimator to forecaster manager
+        node.forecasterman->RegisterForecaster(block_policy_estimator);
+    }
+
     assert(!node.peerman);
     node.peerman = PeerManager::make(*node.connman, *node.addrman,
                                      node.banman.get(), chainman,
diff --git a/src/policy/fees/forecaster_man.cpp b/src/policy/fees/forecaster_man.cpp
index 9157daab8bfe5..1bdf50eecc1e3 100644
--- a/src/policy/fees/forecaster_man.cpp
+++ b/src/policy/fees/forecaster_man.cpp
@@ -2,11 +2,13 @@
 // Distributed under the MIT software license. See the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
+#include <logging.h>
 #include <policy/fees/block_policy_estimator.h>
 #include <policy/fees/forecaster.h>
 #include <policy/fees/forecaster_man.h>
 #include <policy/fees/forecaster_util.h>
 
+#include <algorithm>
 #include <utility>
 
 void FeeRateForecasterManager::RegisterForecaster(std::shared_ptr<Forecaster> forecaster)
@@ -20,3 +22,54 @@ CBlockPolicyEstimator* FeeRateForecasterManager::GetBlockPolicyEstimator()
     Forecaster* block_policy_estimator = forecasters.find(ForecastType::BLOCK_POLICY)->second.get();
     return dynamic_cast<CBlockPolicyEstimator*>(block_policy_estimator);
 }
+
+std::pair<ForecastResult, std::vector<std::string>> FeeRateForecasterManager::ForecastFeeRateFromForecasters(
+    int target, bool conservative) const
+{
+    std::vector<std::string> err_messages;
+    ForecastResult feerate_forecast;
+
+    for (const auto& forecaster : forecasters) {
+        auto curr_forecast = forecaster.second->ForecastFeeRate(target, conservative);
+
+        if (curr_forecast.error.has_value()) {
+            err_messages.emplace_back(
+                strprintf("%s: %s", forecastTypeToString(forecaster.first), curr_forecast.error.value()));
+        }
+
+        // Handle case where the block policy forecaster does not have enough data.
+        if (forecaster.first == ForecastType::BLOCK_POLICY && curr_forecast.feerate.IsEmpty()) {
+            return {ForecastResult(), err_messages};
+        }
+
+        if (!curr_forecast.feerate.IsEmpty()) {
+            if (feerate_forecast.feerate.IsEmpty()) {
+                // If there's no selected forecast, choose curr_forecast as feerate_forecast.
+                feerate_forecast = curr_forecast;
+            } else {
+                // Otherwise, choose the smaller as feerate_forecast.
+                feerate_forecast = std::min(feerate_forecast, curr_forecast);
+            }
+        }
+    }
+
+    if (!feerate_forecast.feerate.IsEmpty()) {
+        Assume(feerate_forecast.forecaster);
+        LogInfo("Fee rate Forecaster %s: Block height %s, fee rate %s %s/kvB.\n",
+                forecastTypeToString(feerate_forecast.forecaster.value()),
+                feerate_forecast.current_block_height,
+                CFeeRate(feerate_forecast.feerate.fee, feerate_forecast.feerate.size).GetFeePerK(),
+                CURRENCY_ATOM);
+    }
+
+    return {feerate_forecast, err_messages};
+}
+
+unsigned int FeeRateForecasterManager::MaximumTarget() const
+{
+    unsigned int maximum_target{0};
+    for (const auto& forecaster : forecasters) {
+        maximum_target = std::max(maximum_target, forecaster.second->MaximumTarget());
+    }
+    return maximum_target;
+}
diff --git a/src/policy/fees/forecaster_man.h b/src/policy/fees/forecaster_man.h
index f6b409ec402c6..8454679ad9431 100644
--- a/src/policy/fees/forecaster_man.h
+++ b/src/policy/fees/forecaster_man.h
@@ -6,6 +6,7 @@
 #define BITCOIN_POLICY_FEES_FORECASTER_MAN_H
 
 #include <memory>
+#include <optional>
 #include <unordered_map>
 
 class CBlockPolicyEstimator;
@@ -34,6 +35,22 @@ class FeeRateForecasterManager
      * Return the pointer to block policy estimator.
      */
     CBlockPolicyEstimator* GetBlockPolicyEstimator();
+
+    /**
+     * Get a fee rate forecast from all registered forecasters for a given confirmation target.
+     *
+     * Polls all registered forecasters and selects the lowest fee rate.
+     *
+     * @param[in] target The target within which the transaction should be confirmed.
+     * @param[in] conservative True if the package cannot be fee bumped later.
+     * @return A pair consisting of the forecast result and a vector of error messages.
+     */
+    std::pair<ForecastResult, std::vector<std::string>> ForecastFeeRateFromForecasters(int target, bool conservative) const;
+
+    /**
+     * @brief Returns the maximum supported confirmation target from all forecasters.
+     */
+    unsigned int MaximumTarget() const;
 };
 
 #endif // BITCOIN_POLICY_FEES_FORECASTER_MAN_H
```
</details>

