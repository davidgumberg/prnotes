# [#30469](https://github.com/bitcoin/bitcoin/pull/30469) index: Fix coinstats overflow
_All code comments in `[]` are my own._

## Background

All of Bitcoin Core's *Index classes are derived from [`class
BaseIndex`](https://github.com/bitcoin/bitcoin/blob/966af3e5ae5f8b7bfb3e7d310f38f0f7c6e1997c/src/index/base.h#L42)
and can override a few different `Custom*` functions to handle block validation
callbacks:

```cpp
class BaseIndex : public CValidationInterface
{
    /// Return custom notification options for index.
    [[nodiscard]] virtual interfaces::Chain::NotifyOptions CustomOptions() { return {}; }

    /// Initialize internal state from the database and block index.
    [[nodiscard]] virtual bool CustomInit(const std::optional<interfaces::BlockRef>& block) { return true; }

    /// Write update index entries for a newly connected block.
    [[nodiscard]] virtual bool CustomAppend(const interfaces::BlockInfo& block) { return true; }

    /// Virtual method called internally by Commit that can be overridden to atomically
    /// commit more index state.
    virtual bool CustomCommit(CDBBatch& batch) { return true; }

    /// Rewind index by one block during a chain reorg.
    [[nodiscard]] virtual bool CustomRemove(const interfaces::BlockInfo& block) { return true; }
```
https://github.com/bitcoin/bitcoin/blob/966af3e5ae5f8b7bfb3e7d310f38f0f7c6e1997c/src/index/base.h#L112-L126

## Problem

Summarized very well in [#26362](https://github.com/bitcoin/bitcoin/issues/26362):

The values in the CoinStatsIndex:

```cpp
CAmount m_total_prevout_spent_amount{0}; 
CAmount m_total_new_outputs_ex_coinbase_amount{0}; 
CAmount m_total_coinbase_amount{0}; 
```

are subject to overflow since `CAmount` is an int64, and these count cumulative
values for the chain. That is the case even though we never expose the
cumulative amounts and only expose the per-block amounts in RPC's.

## Solution

### [index, refactor: Rename ReverseBlock to RevertBlock](https://github.com/bitcoin/bitcoin/pull/30469/commits/63207566019a174162b7696a025c8a42a1e40e5c)

	Semantically this is the correct name for what the function is doing.

Just renaming, lgtm!

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index 96693f7f48a28..ce3f566d9e704 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -265,7 +265,7 @@ bool CoinStatsIndex::CustomRemove(const interfaces::BlockInfo& block)
 
     if (!m_db->WriteBatch(batch)) return false;
 
-    if (!ReverseBlock(block)) {
+    if (!RevertBlock(block)) {
         return false; // failure cause logged internally
     }
 
@@ -381,8 +381,8 @@ interfaces::Chain::NotifyOptions CoinStatsIndex::CustomOptions()
     return options;
 }
 
-// Reverse a single block as part of a reorg
-bool CoinStatsIndex::ReverseBlock(const interfaces::BlockInfo& block)
+// Revert a single block as part of a reorg
+bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
 {
     std::pair<uint256, DBVal> read_out;
 
diff --git a/src/index/coinstatsindex.h b/src/index/coinstatsindex.h
index 6e2743688ad24..f2e95b449e43f 100644
--- a/src/index/coinstatsindex.h
+++ b/src/index/coinstatsindex.h
@@ -38,7 +38,7 @@ class CoinStatsIndex final : public BaseIndex
     CAmount m_total_unspendables_scripts{0};
     CAmount m_total_unspendables_unclaimed_rewards{0};
 
-    [[nodiscard]] bool ReverseBlock(const interfaces::BlockInfo& block);
+    [[nodiscard]] bool RevertBlock(const interfaces::BlockInfo& block);
 
     bool AllowPrune() const override { return true; }
 
```
</details>

### [index, refactor: DRY coinbase check](https://github.com/bitcoin/bitcoin/pull/30469/commits/966af3e5ae5f8b7bfb3e7d310f38f0f7c6e1997c)

	Also marks a few additional variables const.

This refactor commit modifies `CoinStatsIndex::CustomAppend()` to only check
once if a tx is coinbase, and caches the result, it also marks a few values
along the way as `const` (just like it says on the box!)

When looping over each transaction in the newly appended block:

```diff
         for (size_t i = 0; i < block.data->vtx.size(); ++i) {
             const auto& tx{block.data->vtx.at(i)};
+            const bool is_coinbase{tx->IsCoinBase()};
 
             // Skip duplicate txid coinbase transactions (BIP30).
-            if (IsBIP30Unspendable(block.hash, block.height) && tx->IsCoinBase()) {
+            if (is_coinbase && IsBIP30Unspendable(block.hash, block.height)) {
                 m_total_unspendable_amount += block_subsidy;
                 m_total_unspendables_bip30 += block_subsidy;
                 continue;
```

When looping over each vout of each transaction:

```diff
 
             for (uint32_t j = 0; j < tx->vout.size(); ++j) {
                 const CTxOut& out{tx->vout[j]};
-                Coin coin{out, block.height, tx->IsCoinBase()};
-                COutPoint outpoint{tx->GetHash(), j};
+                const Coin coin{out, block.height, is_coinbase};
+                const COutPoint outpoint{tx->GetHash(), j};
 
                 // Skip unspendable coins
                 if (coin.out.scriptPubKey.IsUnspendable()) {
                    
                 // [...]
 
                 ApplyCoinHash(m_muhash, outpoint, coin);
 
-                if (tx->IsCoinBase()) {
+                if (is_coinbase) {
                     m_total_coinbase_amount += coin.out.nValue;
                 } else {
                     m_total_new_outputs_ex_coinbase_amount += coin.out.nValue;
```

Applying undo data for each transaction, I did not know that the effect on the
UTXO set of a block of removing outputs from the unspent set was encoded in a
`CBlockUndo`!

```diff
             // The coinbase tx has no undo data since no former output is spent
-            if (!tx->IsCoinBase()) {
+            if (!is_coinbase) {
                 const auto& tx_undo{Assert(block.undo_data)->vtxundo.at(i - 1)};
 
                 for (size_t j = 0; j < tx_undo.vprevout.size(); ++j) {
-                    Coin coin{tx_undo.vprevout[j]};
-                    COutPoint outpoint{tx->vin[j].prevout.hash, tx->vin[j].prevout.n};
+                    const Coin coin{tx_undo.vprevout[j]};
+                    const COutPoint outpoint{tx->vin[j].prevout.hash, tx->vin[j].prevout.n};
 
                     RemoveCoinHash(m_muhash, outpoint, coin);
```

And do the same in `CoinStatsIndex::RevertBlock`:

```diff
     assert(block.undo_data);
     for (size_t i = 0; i < block.data->vtx.size(); ++i) {
         const auto& tx{block.data->vtx.at(i)};
+        const bool is_coinbase{tx->IsCoinBase()};
 
         for (uint32_t j = 0; j < tx->vout.size(); ++j) {
             const CTxOut& out{tx->vout[j]};
-            COutPoint outpoint{tx->GetHash(), j};
-            Coin coin{out, block.height, tx->IsCoinBase()};
+            const COutPoint outpoint{tx->GetHash(), j};
+            const Coin coin{out, block.height, is_coinbase};
 
             // Skip unspendable coins
             if (coin.out.scriptPubKey.IsUnspendable()) {
@@ -440,13 +442,12 @@ bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
         }
 
         // The coinbase tx has no undo data since no former output is spent
-        if (!tx->IsCoinBase()) {
+        if (!is_coinbase) {
             const auto& tx_undo{block.undo_data->vtxundo.at(i - 1)};
 
             for (size_t j = 0; j < tx_undo.vprevout.size(); ++j) {
-                Coin coin{tx_undo.vprevout[j]};
-                COutPoint outpoint{tx->vin[j].prevout.hash, tx->vin[j].prevout.n};
-
+                const Coin coin{tx_undo.vprevout[j]};
+                const COutPoint outpoint{tx->vin[j].prevout.hash, tx->vin[j].prevout.n};
                 ApplyCoinHash(m_muhash, outpoint, coin);
 
                 m_total_prevout_spent_amount -= coin.out.nValue;
```
</details>

### [refactor, index: Remove member variables in coinstatsindex](https://github.com/bitcoin/bitcoin/pull/30469/commits/e7b111a63067cf6c66140228c28ab1fa96f7ff18)

This is step 1 of the change, it transitions coinstatsindex from having a bunch
of member variables `m_total_*`

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index 48d4c74961967..4764f39a9a96f 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -115,11 +115,10 @@ CoinStatsIndex::CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t
 bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 {
     const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};
-    m_total_subsidy += block_subsidy;
+    std::pair<uint256, DBVal> read_out;
 
     // Ignore genesis block
     if (block.height > 0) {
-        std::pair<uint256, DBVal> read_out;
         if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {
             return false;
         }
@@ -144,8 +143,8 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
             // Skip duplicate txid coinbase transactions (BIP30).
             if (is_coinbase && IsBIP30Unspendable(block.hash, block.height)) {
-                m_total_unspendable_amount += block_subsidy;
-                m_total_unspendables_bip30 += block_subsidy;
+                read_out.second.total_unspendable_amount += block_subsidy;
+                read_out.second.total_unspendables_bip30 += block_subsidy;
                 continue;
             }
 
@@ -156,22 +155,22 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
                 // Skip unspendable coins
                 if (coin.out.scriptPubKey.IsUnspendable()) {
-                    m_total_unspendable_amount += coin.out.nValue;
-                    m_total_unspendables_scripts += coin.out.nValue;
+                    read_out.second.total_unspendable_amount += coin.out.nValue;
+                    read_out.second.total_unspendables_scripts += coin.out.nValue;
                     continue;
                 }
 
                 ApplyCoinHash(m_muhash, outpoint, coin);
 
                 if (is_coinbase) {
-                    m_total_coinbase_amount += coin.out.nValue;
+                    read_out.second.total_coinbase_amount += coin.out.nValue;
                 } else {
-                    m_total_new_outputs_ex_coinbase_amount += coin.out.nValue;
+                    read_out.second.total_new_outputs_ex_coinbase_amount += coin.out.nValue;
                 }
 
-                ++m_transaction_output_count;
-                m_total_amount += coin.out.nValue;
-                m_bogo_size += GetBogoSize(coin.out.scriptPubKey);
+                ++read_out.second.transaction_output_count;
+                read_out.second.total_amount += coin.out.nValue;
+                read_out.second.bogo_size += GetBogoSize(coin.out.scriptPubKey);
             }
 
             // The coinbase tx has no undo data since no former output is spent
@@ -184,50 +183,39 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
                     RemoveCoinHash(m_muhash, outpoint, coin);
 
-                    m_total_prevout_spent_amount += coin.out.nValue;
+                    read_out.second.total_prevout_spent_amount += coin.out.nValue;
 
-                    --m_transaction_output_count;
-                    m_total_amount -= coin.out.nValue;
-                    m_bogo_size -= GetBogoSize(coin.out.scriptPubKey);
+                    --read_out.second.transaction_output_count;
+                    read_out.second.total_amount -= coin.out.nValue;
+                    read_out.second.bogo_size -= GetBogoSize(coin.out.scriptPubKey);
                 }
             }
         }
     } else {
         // genesis block
-        m_total_unspendable_amount += block_subsidy;
-        m_total_unspendables_genesis_block += block_subsidy;
+        read_out.second.total_unspendable_amount += block_subsidy;
+        read_out.second.total_unspendables_genesis_block += block_subsidy;
     }
 
+    read_out.second.total_subsidy += block_subsidy;
+
     // If spent prevouts + block subsidy are still a higher amount than
     // new outputs + coinbase + current unspendable amount this means
     // the miner did not claim the full block reward. Unclaimed block
     // rewards are also unspendable.
-    const CAmount unclaimed_rewards{(m_total_prevout_spent_amount + m_total_subsidy) - (m_total_new_outputs_ex_coinbase_amount + m_total_coinbase_amount + m_total_unspendable_amount)};
-    m_total_unspendable_amount += unclaimed_rewards;
-    m_total_unspendables_unclaimed_rewards += unclaimed_rewards;
+    const CAmount unclaimed_rewards{(read_out.second.total_prevout_spent_amount + read_out.second.total_subsidy) - (read_out.second.total_new_outputs_ex_coinbase_amount + read_out.second.total_coinbase_amount + read_out.second.total_unspendable_amount)};
+    read_out.second.total_unspendable_amount += unclaimed_rewards;
+    read_out.second.total_unspendables_unclaimed_rewards += unclaimed_rewards;
 
-    std::pair<uint256, DBVal> value;
-    value.first = block.hash;
-    value.second.transaction_output_count = m_transaction_output_count;
-    value.second.bogo_size = m_bogo_size;
-    value.second.total_amount = m_total_amount;
-    value.second.total_subsidy = m_total_subsidy;
-    value.second.total_unspendable_amount = m_total_unspendable_amount;
-    value.second.total_prevout_spent_amount = m_total_prevout_spent_amount;
-    value.second.total_new_outputs_ex_coinbase_amount = m_total_new_outputs_ex_coinbase_amount;
-    value.second.total_coinbase_amount = m_total_coinbase_amount;
-    value.second.total_unspendables_genesis_block = m_total_unspendables_genesis_block;
-    value.second.total_unspendables_bip30 = m_total_unspendables_bip30;
-    value.second.total_unspendables_scripts = m_total_unspendables_scripts;
-    value.second.total_unspendables_unclaimed_rewards = m_total_unspendables_unclaimed_rewards;
+    read_out.first = block.hash;
 
     uint256 out;
     m_muhash.Finalize(out);
-    value.second.muhash = out;
+    read_out.second.muhash = out;
 
     // Intentionally do not update DB_MUHASH here so it stays in sync with
     // DB_BEST_BLOCK, and the index is not corrupted if there is an unclean shutdown.
-    return m_db->Write(DBHeightKey(block.height), value);
+    return m_db->Write(DBHeightKey(block.height), read_out);
 }
 
 [[nodiscard]] static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,
@@ -347,19 +335,6 @@ bool CoinStatsIndex::CustomInit(const std::optional<interfaces::BlockRef>& block
                       GetName());
             return false;
         }
-
-        m_transaction_output_count = entry.transaction_output_count;
-        m_bogo_size = entry.bogo_size;
-        m_total_amount = entry.total_amount;
-        m_total_subsidy = entry.total_subsidy;
-        m_total_unspendable_amount = entry.total_unspendable_amount;
-        m_total_prevout_spent_amount = entry.total_prevout_spent_amount;
-        m_total_new_outputs_ex_coinbase_amount = entry.total_new_outputs_ex_coinbase_amount;
-        m_total_coinbase_amount = entry.total_coinbase_amount;
-        m_total_unspendables_genesis_block = entry.total_unspendables_genesis_block;
-        m_total_unspendables_bip30 = entry.total_unspendables_bip30;
-        m_total_unspendables_scripts = entry.total_unspendables_scripts;
-        m_total_unspendables_unclaimed_rewards = entry.total_unspendables_unclaimed_rewards;
     }
 
     return true;
@@ -387,9 +362,6 @@ bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
 {
     std::pair<uint256, DBVal> read_out;
 
-    const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};
-    m_total_subsidy -= block_subsidy;
-
     // Ignore genesis block
     if (block.height > 0) {
         if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {
@@ -409,7 +381,8 @@ bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
         }
     }
 
-    // Remove the new UTXOs that were created from the block
+    // Roll back muhash by removing the new UTXOs that were created by the
+    // block and reapplying the old UTXOs that were spent by the block
     assert(block.data);
     assert(block.undo_data);
     for (size_t i = 0; i < block.data->vtx.size(); ++i) {
@@ -421,24 +394,9 @@ bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
             const COutPoint outpoint{tx->GetHash(), j};
             const Coin coin{out, block.height, is_coinbase};
 
-            // Skip unspendable coins
-            if (coin.out.scriptPubKey.IsUnspendable()) {
-                m_total_unspendable_amount -= coin.out.nValue;
-                m_total_unspendables_scripts -= coin.out.nValue;
-                continue;
+            if (!coin.out.scriptPubKey.IsUnspendable()) {
+                RemoveCoinHash(m_muhash, outpoint, coin);
             }
-
-            RemoveCoinHash(m_muhash, outpoint, coin);
-
-            if (tx->IsCoinBase()) {
-                m_total_coinbase_amount -= coin.out.nValue;
-            } else {
-                m_total_new_outputs_ex_coinbase_amount -= coin.out.nValue;
-            }
-
-            --m_transaction_output_count;
-            m_total_amount -= coin.out.nValue;
-            m_bogo_size -= GetBogoSize(coin.out.scriptPubKey);
         }
 
         // The coinbase tx has no undo data since no former output is spent
@@ -449,37 +407,14 @@ bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
                 const Coin coin{tx_undo.vprevout[j]};
                 const COutPoint outpoint{tx->vin[j].prevout.hash, tx->vin[j].prevout.n};
                 ApplyCoinHash(m_muhash, outpoint, coin);
-
-                m_total_prevout_spent_amount -= coin.out.nValue;
-
-                m_transaction_output_count++;
-                m_total_amount += coin.out.nValue;
-                m_bogo_size += GetBogoSize(coin.out.scriptPubKey);
             }
         }
     }
 
-    const CAmount unclaimed_rewards{(m_total_new_outputs_ex_coinbase_amount + m_total_coinbase_amount + m_total_unspendable_amount) - (m_total_prevout_spent_amount + m_total_subsidy)};
-    m_total_unspendable_amount -= unclaimed_rewards;
-    m_total_unspendables_unclaimed_rewards -= unclaimed_rewards;
-
-    // Check that the rolled back internal values are consistent with the DB read out
+    // Check that the rolled back muhash is consistent with the DB read out
     uint256 out;
     m_muhash.Finalize(out);
     Assert(read_out.second.muhash == out);
 
-    Assert(m_transaction_output_count == read_out.second.transaction_output_count);
-    Assert(m_total_amount == read_out.second.total_amount);
-    Assert(m_bogo_size == read_out.second.bogo_size);
-    Assert(m_total_subsidy == read_out.second.total_subsidy);
-    Assert(m_total_unspendable_amount == read_out.second.total_unspendable_amount);
-    Assert(m_total_prevout_spent_amount == read_out.second.total_prevout_spent_amount);
-    Assert(m_total_new_outputs_ex_coinbase_amount == read_out.second.total_new_outputs_ex_coinbase_amount);
-    Assert(m_total_coinbase_amount == read_out.second.total_coinbase_amount);
-    Assert(m_total_unspendables_genesis_block == read_out.second.total_unspendables_genesis_block);
-    Assert(m_total_unspendables_bip30 == read_out.second.total_unspendables_bip30);
-    Assert(m_total_unspendables_scripts == read_out.second.total_unspendables_scripts);
-    Assert(m_total_unspendables_unclaimed_rewards == read_out.second.total_unspendables_unclaimed_rewards);
-
     return true;
 }
diff --git a/src/index/coinstatsindex.h b/src/index/coinstatsindex.h
index f2e95b449e43f..d859442cda575 100644
--- a/src/index/coinstatsindex.h
+++ b/src/index/coinstatsindex.h
@@ -25,18 +25,6 @@ class CoinStatsIndex final : public BaseIndex
     std::unique_ptr<BaseIndex::DB> m_db;
 
     MuHash3072 m_muhash;
-    uint64_t m_transaction_output_count{0};
-    uint64_t m_bogo_size{0};
-    CAmount m_total_amount{0};
-    CAmount m_total_subsidy{0};
-    CAmount m_total_unspendable_amount{0};
-    CAmount m_total_prevout_spent_amount{0};
-    CAmount m_total_new_outputs_ex_coinbase_amount{0};
-    CAmount m_total_coinbase_amount{0};
-    CAmount m_total_unspendables_genesis_block{0};
-    CAmount m_total_unspendables_bip30{0};
-    CAmount m_total_unspendables_scripts{0};
-    CAmount m_total_unspendables_unclaimed_rewards{0};
 
     [[nodiscard]] bool RevertBlock(const interfaces::BlockInfo& block);
 
```
</details>

### [index: Fix coinstatsindex overflow issue](https://github.com/bitcoin/bitcoin/pull/30469/commits/c2bc3b97f741fc9e154653935d2c9612e73a3891)

	The index originally stored cumulative values but this allowed for
	potential overflow issues which were observed on Signet. Fix this by
	storing index-specific values per-block instead of cummulative values and use a different
	folder for this new version of the index.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/doc/files.md b/doc/files.md
index 0bf115e1c1184..c8d8aab3a7ae5 100644
--- a/doc/files.md
+++ b/doc/files.md
@@ -57,7 +57,7 @@ Subdirectory       | File(s)               | Description
 `indexes/txindex/` | LevelDB database      | Transaction index; *optional*, used if `-txindex=1`
 `indexes/blockfilter/basic/db/` | LevelDB database      | Blockfilter index LevelDB database for the basic filtertype; *optional*, used if `-blockfilterindex=basic`
 `indexes/blockfilter/basic/`    | `fltrNNNNN.dat`<sup>[\[2\]](#note2)</sup> | Blockfilter index filters for the basic filtertype; *optional*, used if `-blockfilterindex=basic`
-`indexes/coinstats/db/` | LevelDB database | Coinstats index; *optional*, used if `-coinstatsindex=1`
+`indexes/coinstatsindex/db/` | LevelDB database | Coinstats index; *optional*, used if `-coinstatsindex=1`
 `wallets/`         |                       | [Contains wallets](#multi-wallet-environment); can be specified by `-walletdir` option; if `wallets/` subdirectory does not exist, wallets reside in the [data directory](#data-directory-location)
 `./`               | `anchors.dat`         | Anchor IP address database, created on shutdown and deleted at startup. Anchors are last known outgoing block-relay-only peers that are tried to re-connect to on startup
 `./`               | `banlist.json`        | Stores the addresses/subnets of banned nodes.
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index 4764f39a9a96f..bdc05d2dc208b 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -31,15 +31,15 @@ struct DBVal {
     uint64_t transaction_output_count;
     uint64_t bogo_size;
     CAmount total_amount;
-    CAmount total_subsidy;
+    CAmount block_subsidy;
     CAmount total_unspendable_amount;
-    CAmount total_prevout_spent_amount;
-    CAmount total_new_outputs_ex_coinbase_amount;
-    CAmount total_coinbase_amount;
-    CAmount total_unspendables_genesis_block;
-    CAmount total_unspendables_bip30;
-    CAmount total_unspendables_scripts;
-    CAmount total_unspendables_unclaimed_rewards;
+    CAmount block_prevout_spent_amount;
+    CAmount block_new_outputs_ex_coinbase_amount;
+    CAmount block_coinbase_amount;
+    CAmount block_unspendables_genesis_block;
+    CAmount block_unspendables_bip30;
+    CAmount block_unspendables_scripts;
+    CAmount block_unspendables_unclaimed_rewards;
 
     SERIALIZE_METHODS(DBVal, obj)
     {
@@ -47,15 +47,15 @@ struct DBVal {
         READWRITE(obj.transaction_output_count);
         READWRITE(obj.bogo_size);
         READWRITE(obj.total_amount);
-        READWRITE(obj.total_subsidy);
+        READWRITE(obj.block_subsidy);
         READWRITE(obj.total_unspendable_amount);
-        READWRITE(obj.total_prevout_spent_amount);
-        READWRITE(obj.total_new_outputs_ex_coinbase_amount);
-        READWRITE(obj.total_coinbase_amount);
-        READWRITE(obj.total_unspendables_genesis_block);
-        READWRITE(obj.total_unspendables_bip30);
-        READWRITE(obj.total_unspendables_scripts);
-        READWRITE(obj.total_unspendables_unclaimed_rewards);
+        READWRITE(obj.block_prevout_spent_amount);
+        READWRITE(obj.block_new_outputs_ex_coinbase_amount);
+        READWRITE(obj.block_coinbase_amount);
+        READWRITE(obj.block_unspendables_genesis_block);
+        READWRITE(obj.block_unspendables_bip30);
+        READWRITE(obj.block_unspendables_scripts);
+        READWRITE(obj.block_unspendables_unclaimed_rewards);
     }
 };
 
@@ -106,7 +106,17 @@ std::unique_ptr<CoinStatsIndex> g_coin_stats_index;
 CoinStatsIndex::CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory, bool f_wipe)
     : BaseIndex(std::move(chain), "coinstatsindex")
 {
-    fs::path path{gArgs.GetDataDirNet() / "indexes" / "coinstats"};
+    // An earlier version of the index used "indexes/coinstats" but it contained
+    // a bug and is superseded by a fixed version at "indexes/coinstatsindex".
+    // The original index is kept around until the next release in case users
+    // decide to downgrade their node.
+    auto old_path = gArgs.GetDataDirNet() / "indexes" / "coinstats";
+    if (fs::exists(old_path)) {
+        // TODO: Change this to deleting the old index with v31.
+        LogWarning("Old version of coinstatsindex found at %s. This folder can be safely deleted unless you " \
+            "plan to downgrade your node to version 29 or lower.", fs::PathToString(old_path));
+    }
+    fs::path path{gArgs.GetDataDirNet() / "indexes" / "coinstatsindex"};
     fs::create_directories(path);
 
     m_db = std::make_unique<CoinStatsIndex::DB>(path / "db", n_cache_size, f_memory, f_wipe);
@@ -115,7 +125,9 @@ CoinStatsIndex::CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t
 bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 {
     const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};
+    CAmount block_unspendable{0};
     std::pair<uint256, DBVal> read_out;
+    std::pair<uint256, DBVal> new_value;
 
     // Ignore genesis block
     if (block.height > 0) {
@@ -135,6 +147,11 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
             }
         }
 
+        new_value.second.total_amount = read_out.second.total_amount;
+        new_value.second.total_unspendable_amount = read_out.second.total_unspendable_amount;
+        new_value.second.transaction_output_count = read_out.second.transaction_output_count;
+        new_value.second.bogo_size = read_out.second.bogo_size;
+
         // Add the new utxos created from the block
         assert(block.data);
         for (size_t i = 0; i < block.data->vtx.size(); ++i) {
@@ -143,8 +160,8 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
             // Skip duplicate txid coinbase transactions (BIP30).
             if (is_coinbase && IsBIP30Unspendable(block.hash, block.height)) {
-                read_out.second.total_unspendable_amount += block_subsidy;
-                read_out.second.total_unspendables_bip30 += block_subsidy;
+                block_unspendable += block_subsidy;
+                new_value.second.block_unspendables_bip30 += block_subsidy;
                 continue;
             }
 
@@ -155,22 +172,22 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
                 // Skip unspendable coins
                 if (coin.out.scriptPubKey.IsUnspendable()) {
-                    read_out.second.total_unspendable_amount += coin.out.nValue;
-                    read_out.second.total_unspendables_scripts += coin.out.nValue;
+                    block_unspendable += coin.out.nValue;
+                    new_value.second.block_unspendables_scripts += coin.out.nValue;
                     continue;
                 }
 
                 ApplyCoinHash(m_muhash, outpoint, coin);
 
                 if (is_coinbase) {
-                    read_out.second.total_coinbase_amount += coin.out.nValue;
+                    new_value.second.block_coinbase_amount += coin.out.nValue;
                 } else {
-                    read_out.second.total_new_outputs_ex_coinbase_amount += coin.out.nValue;
+                    new_value.second.block_new_outputs_ex_coinbase_amount += coin.out.nValue;
                 }
 
-                ++read_out.second.transaction_output_count;
-                read_out.second.total_amount += coin.out.nValue;
-                read_out.second.bogo_size += GetBogoSize(coin.out.scriptPubKey);
+                ++new_value.second.transaction_output_count;
+                new_value.second.total_amount += coin.out.nValue;
+                new_value.second.bogo_size += GetBogoSize(coin.out.scriptPubKey);
             }
 
             // The coinbase tx has no undo data since no former output is spent
@@ -183,39 +200,39 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
                     RemoveCoinHash(m_muhash, outpoint, coin);
 
-                    read_out.second.total_prevout_spent_amount += coin.out.nValue;
+                    new_value.second.block_prevout_spent_amount += coin.out.nValue;
 
-                    --read_out.second.transaction_output_count;
-                    read_out.second.total_amount -= coin.out.nValue;
-                    read_out.second.bogo_size -= GetBogoSize(coin.out.scriptPubKey);
+                    --new_value.second.transaction_output_count;
+                    new_value.second.total_amount -= coin.out.nValue;
+                    new_value.second.bogo_size -= GetBogoSize(coin.out.scriptPubKey);
                 }
             }
         }
     } else {
         // genesis block
-        read_out.second.total_unspendable_amount += block_subsidy;
-        read_out.second.total_unspendables_genesis_block += block_subsidy;
+        block_unspendable += block_subsidy;
+        new_value.second.block_unspendables_genesis_block += block_subsidy;
     }
 
-    read_out.second.total_subsidy += block_subsidy;
+    new_value.second.block_subsidy += block_subsidy;
 
     // If spent prevouts + block subsidy are still a higher amount than
     // new outputs + coinbase + current unspendable amount this means
     // the miner did not claim the full block reward. Unclaimed block
     // rewards are also unspendable.
-    const CAmount unclaimed_rewards{(read_out.second.total_prevout_spent_amount + read_out.second.total_subsidy) - (read_out.second.total_new_outputs_ex_coinbase_amount + read_out.second.total_coinbase_amount + read_out.second.total_unspendable_amount)};
-    read_out.second.total_unspendable_amount += unclaimed_rewards;
-    read_out.second.total_unspendables_unclaimed_rewards += unclaimed_rewards;
+    const CAmount unclaimed_rewards{(new_value.second.block_prevout_spent_amount + new_value.second.block_subsidy) - (new_value.second.block_new_outputs_ex_coinbase_amount + new_value.second.block_coinbase_amount + block_unspendable)};
+    new_value.second.block_unspendables_unclaimed_rewards += unclaimed_rewards;
+    new_value.second.total_unspendable_amount += (unclaimed_rewards + block_unspendable);
 
-    read_out.first = block.hash;
+    new_value.first = block.hash;
 
     uint256 out;
     m_muhash.Finalize(out);
-    read_out.second.muhash = out;
+    new_value.second.muhash = out;
 
     // Intentionally do not update DB_MUHASH here so it stays in sync with
     // DB_BEST_BLOCK, and the index is not corrupted if there is an unclean shutdown.
-    return m_db->Write(DBHeightKey(block.height), read_out);
+    return m_db->Write(DBHeightKey(block.height), new_value);
 }
 
 [[nodiscard]] static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,
@@ -294,15 +311,17 @@ std::optional<CCoinsStats> CoinStatsIndex::LookUpStats(const CBlockIndex& block_
     stats.nTransactionOutputs = entry.transaction_output_count;
     stats.nBogoSize = entry.bogo_size;
     stats.total_amount = entry.total_amount;
-    stats.total_subsidy = entry.total_subsidy;
     stats.total_unspendable_amount = entry.total_unspendable_amount;
-    stats.total_prevout_spent_amount = entry.total_prevout_spent_amount;
-    stats.total_new_outputs_ex_coinbase_amount = entry.total_new_outputs_ex_coinbase_amount;
-    stats.total_coinbase_amount = entry.total_coinbase_amount;
-    stats.total_unspendables_genesis_block = entry.total_unspendables_genesis_block;
-    stats.total_unspendables_bip30 = entry.total_unspendables_bip30;
-    stats.total_unspendables_scripts = entry.total_unspendables_scripts;
-    stats.total_unspendables_unclaimed_rewards = entry.total_unspendables_unclaimed_rewards;
+
+    stats.block_subsidy = entry.block_subsidy;
+    stats.block_prevout_spent_amount = entry.block_prevout_spent_amount;
+    stats.block_new_outputs_ex_coinbase_amount = entry.block_new_outputs_ex_coinbase_amount;
+    stats.block_coinbase_amount = entry.block_coinbase_amount;
+
+    stats.block_unspendables_genesis_block = entry.block_unspendables_genesis_block;
+    stats.block_unspendables_bip30 = entry.block_unspendables_bip30;
+    stats.block_unspendables_scripts = entry.block_unspendables_scripts;
+    stats.block_unspendables_unclaimed_rewards = entry.block_unspendables_unclaimed_rewards;
 
     return stats;
 }
diff --git a/src/kernel/coinstats.h b/src/kernel/coinstats.h
index c0c363a842838..b310d1cdf0584 100644
--- a/src/kernel/coinstats.h
+++ b/src/kernel/coinstats.h
@@ -48,24 +48,26 @@ struct CCoinsStats {
 
     // Following values are only available from coinstats index
 
-    //! Total cumulative amount of block subsidies up to and including this block
-    CAmount total_subsidy{0};
-    //! Total cumulative amount of unspendable coins up to and including this block
+    //! Total amount of unspendable coins
     CAmount total_unspendable_amount{0};
-    //! Total cumulative amount of prevouts spent up to and including this block
-    CAmount total_prevout_spent_amount{0};
-    //! Total cumulative amount of outputs created up to and including this block
-    CAmount total_new_outputs_ex_coinbase_amount{0};
-    //! Total cumulative amount of coinbase outputs up to and including this block
-    CAmount total_coinbase_amount{0};
-    //! The unspendable coinbase amount from the genesis block
-    CAmount total_unspendables_genesis_block{0};
-    //! The two unspendable coinbase outputs total amount caused by BIP30
-    CAmount total_unspendables_bip30{0};
-    //! Total cumulative amount of outputs sent to unspendable scripts (OP_RETURN for example) up to and including this block
-    CAmount total_unspendables_scripts{0};
-    //! Total cumulative amount of coins lost due to unclaimed miner rewards up to and including this block
-    CAmount total_unspendables_unclaimed_rewards{0};
+
+    //! Amount of block subsidies in this block
+    CAmount block_subsidy{0};
+    //! Amount of prevouts spent in this block
+    CAmount block_prevout_spent_amount{0};
+    //! Amount of outputs created in this block
+    CAmount block_new_outputs_ex_coinbase_amount{0};
+    //! Amount of coinbase outputs in this block
+    CAmount block_coinbase_amount{0};
+
+    //! The unspendable coinbase output amount from the genesis block
+    CAmount block_unspendables_genesis_block{0};
+    //! The unspendable coinbase output amounts caused by BIP30
+    CAmount block_unspendables_bip30{0};
+    //! Amount of outputs sent to unspendable scripts (OP_RETURN for example) in this block
+    CAmount block_unspendables_scripts{0};
+    //! Amount of coins lost due to unclaimed miner rewards in this block
+    CAmount block_unspendables_unclaimed_rewards{0};
 
     CCoinsStats() = default;
     CCoinsStats(int block_height, const uint256& block_hash);
diff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp
index cfc0379f68304..9c3ee70fd9c52 100644
--- a/src/rpc/blockchain.cpp
+++ b/src/rpc/blockchain.cpp
@@ -1103,26 +1103,20 @@ static RPCHelpMan gettxoutsetinfo()
         } else {
             ret.pushKV("total_unspendable_amount", ValueFromAmount(stats.total_unspendable_amount));
 
-            CCoinsStats prev_stats{};
-            if (pindex->nHeight > 0) {
-                const std::optional<CCoinsStats> maybe_prev_stats = GetUTXOStats(coins_view, *blockman, hash_type, node.rpc_interruption_point, pindex->pprev, index_requested);
-                if (!maybe_prev_stats) {
-                    throw JSONRPCError(RPC_INTERNAL_ERROR, "Unable to read UTXO set");
-                }
-                prev_stats = maybe_prev_stats.value();
-            }
-
             UniValue block_info(UniValue::VOBJ);
-            block_info.pushKV("prevout_spent", ValueFromAmount(stats.total_prevout_spent_amount - prev_stats.total_prevout_spent_amount));
-            block_info.pushKV("coinbase", ValueFromAmount(stats.total_coinbase_amount - prev_stats.total_coinbase_amount));
-            block_info.pushKV("new_outputs_ex_coinbase", ValueFromAmount(stats.total_new_outputs_ex_coinbase_amount - prev_stats.total_new_outputs_ex_coinbase_amount));
-            block_info.pushKV("unspendable", ValueFromAmount(stats.total_unspendable_amount - prev_stats.total_unspendable_amount));
+            block_info.pushKV("prevout_spent", ValueFromAmount(stats.block_prevout_spent_amount));
+            block_info.pushKV("coinbase", ValueFromAmount(stats.block_coinbase_amount));
+            block_info.pushKV("new_outputs_ex_coinbase", ValueFromAmount(stats.block_new_outputs_ex_coinbase_amount));
+            block_info.pushKV("unspendable", ValueFromAmount(stats.block_unspendables_genesis_block +
+                        stats.block_unspendables_bip30 +
+                        stats.block_unspendables_scripts +
+                        stats.block_unspendables_unclaimed_rewards));
 
             UniValue unspendables(UniValue::VOBJ);
-            unspendables.pushKV("genesis_block", ValueFromAmount(stats.total_unspendables_genesis_block - prev_stats.total_unspendables_genesis_block));
-            unspendables.pushKV("bip30", ValueFromAmount(stats.total_unspendables_bip30 - prev_stats.total_unspendables_bip30));
-            unspendables.pushKV("scripts", ValueFromAmount(stats.total_unspendables_scripts - prev_stats.total_unspendables_scripts));
-            unspendables.pushKV("unclaimed_rewards", ValueFromAmount(stats.total_unspendables_unclaimed_rewards - prev_stats.total_unspendables_unclaimed_rewards));
+            unspendables.pushKV("genesis_block", ValueFromAmount(stats.block_unspendables_genesis_block));
+            unspendables.pushKV("bip30", ValueFromAmount(stats.block_unspendables_bip30));
+            unspendables.pushKV("scripts", ValueFromAmount(stats.block_unspendables_scripts));
+            unspendables.pushKV("unclaimed_rewards", ValueFromAmount(stats.block_unspendables_unclaimed_rewards));
             block_info.pushKV("unspendables", std::move(unspendables));
 
             ret.pushKV("block_info", std::move(block_info));
diff --git a/test/functional/feature_init.py b/test/functional/feature_init.py
index a7b7e0c676093..b9d41a9713cc5 100755
--- a/test/functional/feature_init.py
+++ b/test/functional/feature_init.py
@@ -128,7 +128,7 @@ def check_clean_start(extra_args):
                 'startup_args': ['-txindex=1'],
             },
             # Removing these files does not result in a startup error:
-            # 'indexes/blockfilter/basic/*.dat', 'indexes/blockfilter/basic/db/*.*', 'indexes/coinstats/db/*.*',
+            # 'indexes/blockfilter/basic/*.dat', 'indexes/blockfilter/basic/db/*.*', 'indexes/coinstatsindex/db/*.*',
             # 'indexes/txindex/*.log', 'indexes/txindex/CURRENT', 'indexes/txindex/LOCK'
         ]
 
@@ -154,7 +154,7 @@ def check_clean_start(extra_args):
                 'startup_args': ['-blockfilterindex=1'],
             },
             {
-                'filepath_glob': 'indexes/coinstats/db/*.*',
+                'filepath_glob': 'indexes/coinstatsindex/db/*.*',
                 'error_message': 'LevelDB error: Corruption',
                 'startup_args': ['-coinstatsindex=1'],
             },
```
</details>

### [index, refactor: Append blocks to coinstatsindex without db read](https://github.com/bitcoin/bitcoin/pull/30469/commits/90cbaf408c6d338987281e8196f2418107e2c2bf)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index bdc05d2dc208b..704afb89ef1bc 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -126,20 +126,16 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 {
     const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};
     CAmount block_unspendable{0};
-    std::pair<uint256, DBVal> read_out;
     std::pair<uint256, DBVal> new_value;
 
     // Ignore genesis block
     if (block.height > 0) {
-        if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {
-            return false;
-        }
-
         uint256 expected_block_hash{*Assert(block.prev_hash)};
-        if (read_out.first != expected_block_hash) {
+        if (m_current_block_hash != expected_block_hash) {
             LogWarning("previous block header belongs to unexpected block %s; expected %s",
-                      read_out.first.ToString(), expected_block_hash.ToString());
+                      m_current_block_hash.ToString(), expected_block_hash.ToString());
 
+            std::pair<uint256, DBVal> read_out;
             if (!m_db->Read(DBHashKey(expected_block_hash), read_out)) {
                 LogError("previous block header not found; expected %s",
                           expected_block_hash.ToString());
@@ -147,11 +143,6 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
             }
         }
 
-        new_value.second.total_amount = read_out.second.total_amount;
-        new_value.second.total_unspendable_amount = read_out.second.total_unspendable_amount;
-        new_value.second.transaction_output_count = read_out.second.transaction_output_count;
-        new_value.second.bogo_size = read_out.second.bogo_size;
-
         // Add the new utxos created from the block
         assert(block.data);
         for (size_t i = 0; i < block.data->vtx.size(); ++i) {
@@ -185,9 +176,9 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
                     new_value.second.block_new_outputs_ex_coinbase_amount += coin.out.nValue;
                 }
 
-                ++new_value.second.transaction_output_count;
-                new_value.second.total_amount += coin.out.nValue;
-                new_value.second.bogo_size += GetBogoSize(coin.out.scriptPubKey);
+                ++m_transaction_output_count;
+                m_total_amount += coin.out.nValue;
+                m_bogo_size += GetBogoSize(coin.out.scriptPubKey);
             }
 
             // The coinbase tx has no undo data since no former output is spent
@@ -202,9 +193,9 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
 
                     new_value.second.block_prevout_spent_amount += coin.out.nValue;
 
-                    --new_value.second.transaction_output_count;
-                    new_value.second.total_amount -= coin.out.nValue;
-                    new_value.second.bogo_size -= GetBogoSize(coin.out.scriptPubKey);
+                    --m_transaction_output_count;
+                    m_total_amount -= coin.out.nValue;
+                    m_bogo_size -= GetBogoSize(coin.out.scriptPubKey);
                 }
             }
         }
@@ -222,14 +213,20 @@ bool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)
     // rewards are also unspendable.
     const CAmount unclaimed_rewards{(new_value.second.block_prevout_spent_amount + new_value.second.block_subsidy) - (new_value.second.block_new_outputs_ex_coinbase_amount + new_value.second.block_coinbase_amount + block_unspendable)};
     new_value.second.block_unspendables_unclaimed_rewards += unclaimed_rewards;
-    new_value.second.total_unspendable_amount += (unclaimed_rewards + block_unspendable);
+    m_total_unspendable_amount += (unclaimed_rewards + block_unspendable);
 
     new_value.first = block.hash;
+    new_value.second.total_amount = m_total_amount;
+    new_value.second.total_unspendable_amount = m_total_unspendable_amount;
+    new_value.second.transaction_output_count = m_transaction_output_count;
+    new_value.second.bogo_size = m_bogo_size;
 
     uint256 out;
     m_muhash.Finalize(out);
     new_value.second.muhash = out;
 
+    m_current_block_hash = block.hash;
+
     // Intentionally do not update DB_MUHASH here so it stays in sync with
     // DB_BEST_BLOCK, and the index is not corrupted if there is an unclean shutdown.
     return m_db->Write(DBHeightKey(block.height), new_value);
@@ -354,6 +351,12 @@ bool CoinStatsIndex::CustomInit(const std::optional<interfaces::BlockRef>& block
                       GetName());
             return false;
         }
+
+        m_transaction_output_count = entry.transaction_output_count;
+        m_bogo_size = entry.bogo_size;
+        m_total_amount = entry.total_amount;
+        m_total_unspendable_amount = entry.total_unspendable_amount;
+        m_current_block_hash = block->hash;
     }
 
     return true;
@@ -435,5 +438,11 @@ bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
     m_muhash.Finalize(out);
     Assert(read_out.second.muhash == out);
 
+    m_transaction_output_count = read_out.second.transaction_output_count;
+    m_bogo_size = read_out.second.bogo_size;
+    m_total_amount = read_out.second.total_amount;
+    m_total_unspendable_amount = read_out.second.total_unspendable_amount;
+    m_current_block_hash = *block.prev_hash;
+
     return true;
 }
diff --git a/src/index/coinstatsindex.h b/src/index/coinstatsindex.h
index d859442cda575..9f9b0433295cf 100644
--- a/src/index/coinstatsindex.h
+++ b/src/index/coinstatsindex.h
@@ -25,6 +25,12 @@ class CoinStatsIndex final : public BaseIndex
     std::unique_ptr<BaseIndex::DB> m_db;
 
     MuHash3072 m_muhash;
+    uint64_t m_transaction_output_count{0};
+    uint64_t m_bogo_size{0};
+    CAmount m_total_amount{0};
+    CAmount m_total_unspendable_amount{0};
+
+    uint256 m_current_block_hash{};
 
     [[nodiscard]] bool RevertBlock(const interfaces::BlockInfo& block);
 
```
</details>

### [test: Add coinstatsindex compatibility test](https://github.com/bitcoin/bitcoin/pull/30469/commits/17cf72948569f27ccf45796aadb693bbed1ba42e)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/test/functional/feature_coinstatsindex_compatibility.py b/test/functional/feature_coinstatsindex_compatibility.py
new file mode 100755
index 0000000000000..357700a71373b
--- /dev/null
+++ b/test/functional/feature_coinstatsindex_compatibility.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+# Copyright (c) 2025 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test coinstatsindex across node versions.
+
+This test may be removed some time after v29 has reached end of life.
+"""
+
+import shutil
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class CoinStatsIndexTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+        self.supports_cli = False
+        self.extra_args = [["-coinstatsindex"],["-coinstatsindex"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_previous_releases()
+
+    def setup_nodes(self):
+        self.add_nodes(
+            self.num_nodes,
+            extra_args=self.extra_args,
+            versions=[
+                None,
+                280200,
+            ],
+        )
+        self.start_nodes()
+
+    def run_test(self):
+        self._test_coin_stats_index_compatibility()
+
+    def _test_coin_stats_index_compatibility(self):
+        node = self.nodes[0]
+        legacy_node = self.nodes[1]
+        for n in self.nodes:
+            self.wait_until(lambda: n.getindexinfo()['coinstatsindex']['synced'] is True)
+
+        self.log.info("Test that gettxoutsetinfo() output is consistent between the different index versions")
+        res0 = node.gettxoutsetinfo('muhash')
+        res1 = legacy_node.gettxoutsetinfo('muhash')
+        assert_equal(res1, res0)
+
+        self.log.info("Test that gettxoutsetinfo() output is consistent for the new index running on a datadir with the old version")
+        self.stop_nodes()
+        shutil.rmtree(node.chain_path / "indexes" / "coinstatsindex")
+        shutil.copytree(legacy_node.chain_path / "indexes" / "coinstats", node.chain_path / "indexes" / "coinstats")
+        old_version_path = node.chain_path / "indexes" / "coinstats"
+        msg = f'[warning] Old version of coinstatsindex found at {old_version_path}. This folder can be safely deleted unless you plan to downgrade your node to version 29 or lower.'
+        with node.assert_debug_log(expected_msgs=[msg]):
+            self.start_node(0, ['-coinstatsindex'])
+        self.wait_until(lambda: node.getindexinfo()['coinstatsindex']['synced'] is True)
+        res2 = node.gettxoutsetinfo('muhash')
+        assert_equal(res2, res0)
+
+
+if __name__ == '__main__':
+    CoinStatsIndexTest(__file__).main()
diff --git a/test/functional/test_runner.py b/test/functional/test_runner.py
index f2e514a7a4658..94965618cd98d 100755
--- a/test/functional/test_runner.py
+++ b/test/functional/test_runner.py
@@ -342,6 +342,7 @@
     'feature_anchors.py',
     'mempool_datacarrier.py',
     'feature_coinstatsindex.py',
+    'feature_coinstatsindex_compatibility.py',
     'wallet_orphanedreward.py',
     'wallet_timelock.py',
     'p2p_permissions.py',
```
</details>

### [doc: Add release note for 30469](https://github.com/bitcoin/bitcoin/pull/30469/commits/03a7318a4df196bff97438caa57693ca02706029)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/doc/release-notes-30469.md b/doc/release-notes-30469.md
new file mode 100644
index 0000000000000..a1f6045960a53
--- /dev/null
+++ b/doc/release-notes-30469.md
@@ -0,0 +1,4 @@
+Indexes
+-------
+
+- The implementation of coinstatsindex was changed to prevent an overflow bug that could already be observed on the default Signet. The new version of the index will need to be synced from scratch when starting the upgraded node for the first time. The new version is stored in `/indexes/coinstatsindex/` in contrast to the old version which was stored at `/indexes/coinstats/`. The old version of the index is not deleted by the upgraded node in case the user chooses to downgrade their node in the future. If the user does not plan to downgrade it is safe for them to remove `/indexes/coinstats/` from their datadir. A future release of Bitcoin Core may remove the old version of the index automatically.
```
</details>

### [index: Check BIP30 blocks when rewinding Coinstatsindex](https://github.com/bitcoin/bitcoin/pull/30469/commits/dd7e696762b4863a5f06d150c4fe3fb882ac69dc)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp
index 704afb89ef1bc..f6eb2ffdeee55 100644
--- a/src/index/coinstatsindex.cpp
+++ b/src/index/coinstatsindex.cpp
@@ -411,6 +411,10 @@ bool CoinStatsIndex::RevertBlock(const interfaces::BlockInfo& block)
         const auto& tx{block.data->vtx.at(i)};
         const bool is_coinbase{tx->IsCoinBase()};
 
+        if (is_coinbase && IsBIP30Unspendable(block.hash, block.height)) {
+            continue;
+        }
+
         for (uint32_t j = 0; j < tx->vout.size(); ++j) {
             const CTxOut& out{tx->vout[j]};
             const COutPoint outpoint{tx->GetHash(), j};
```
</details>

