# [#33106](https://github.com/bitcoin/bitcoin/pull/33106) policy: lower the default blockmintxfee, incrementalrelayfee, minrelaytxfee
_All code comments in `[]` are my own._

## Background

Bitcoin has a minimum relay fee mempool policy to prevent DoS attacks where
attackers can get the network to spam itself with transactions. Minimum relay
fee creates a cost floor associated with broadcasting to the network, this value
should be set so that it is always cheaper to get bandwidth external from the
bitcoin core network, e.g. from AWS and broadcast messages to the network than
it is to use the tx relay network to broadcast to itself. See: https://delvingbitcoin.org/t/changing-the-minimum-relay-feerate/1886/12

## Problem

The current minrelayfee is 1 sat/vB, but miners have begun to include
transactions with lower feerates than this in blocks, this has resulted in
extreme divergence between mempool policy and block activity, which destroys
compact block reconstruction since Bitcoin Core nodes don't hold on to the
transactions that get included in blocks.

## Solution

Lower the minrelayfee to 0.1sat/vB, for motivation behind this number:

https://github.com/bitcoin/bitcoin/pull/32959#issuecomment-3095260286, the
https://github.com/bitcoin/bitcoin/pull/33106/commits/6da5de58cabc4133c379baa50845e30e5bc6b3e4
https://delvingbitcoin.org/t/changing-the-minimum-relay-feerate/1886

### [[test] check miner doesn't select 0fee transactions](https://github.com/bitcoin/bitcoin/pull/33106/commits/e5f896bb1f052fb8c7811c6024cb49143b427512)

<details>


<summary>test_blockmintxfee_parameter annotated</summary>

```python
    def test_blockmintxfee_parameter(self):
        self.log.info("Test -blockmintxfee setting")
        self.restart_node(0, extra_args=['-minrelaytxfee=0', '-persistmempool=0'])
        node = self.nodes[0]

        # test default (no parameter), zero and a bunch of arbitrary blockmintxfee rates [sat/kvB]
        for blockmintxfee_sat_kvb in (DEFAULT_BLOCK_MIN_TX_FEE, 0, 50, 100, 500, 2500, 5000, 21000, 333333, 2500000):
            # [ convert sats/KvB to BTC/KvB ]
            blockmintxfee_btc_kvb = blockmintxfee_sat_kvb / Decimal(COIN)
            if blockmintxfee_sat_kvb == DEFAULT_BLOCK_MIN_TX_FEE:
                self.log.info(f"-> Default -blockmintxfee setting ({blockmintxfee_sat_kvb} sat/kvB)...")
            else:
                blockmintxfee_parameter = f"-blockmintxfee={blockmintxfee_btc_kvb:.8f}"
                self.log.info(f"-> Test {blockmintxfee_parameter} ({blockmintxfee_sat_kvb} sat/kvB)...")
                self.restart_node(0, extra_args=[blockmintxfee_parameter, '-minrelaytxfee=0', '-persistmempool=0'])
                # [ Probably mitigates some weird state issues with the test framework node<=>wallet connection, the test framework node's wallet is not all it seems, this should probably be moved somehow into restart_node. ]
                self.wallet.rescan_utxos()  # to avoid spending outputs of txs that are not in mempool anymore after restart

            # submit one tx with exactly the blockmintxfee rate, and one slightly below
            tx_with_min_feerate = self.wallet.send_self_transfer(from_node=node, fee_rate=blockmintxfee_btc_kvb)
            # [ Double check the fee is what we expect it to be. ]
            assert_equal(tx_with_min_feerate["fee"], get_fee(tx_with_min_feerate["tx"].get_vsize(), blockmintxfee_btc_kvb))
            if blockmintxfee_btc_kvb > 0:
                lowerfee_btc_kvb = blockmintxfee_btc_kvb - Decimal(10)/COIN  # 0.01 sat/vbyte lower
                tx_below_min_feerate = self.wallet.send_self_transfer(from_node=node, fee_rate=lowerfee_btc_kvb)
                assert_equal(tx_below_min_feerate["fee"], get_fee(tx_below_min_feerate["tx"].get_vsize(), lowerfee_btc_kvb))
            else:  # go below zero fee by using modified fees
                tx_below_min_feerate = self.wallet.send_self_transfer(from_node=node, fee_rate=blockmintxfee_btc_kvb)
                node.prioritisetransaction(tx_below_min_feerate["txid"], 0, -1)

            # check that tx below specified fee-rate is neither in template nor in the actual block
            block_template = node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)
            block_template_txids = [tx['txid'] for tx in block_template['transactions']]
            self.generate(self.wallet, 1, sync_fun=self.no_op)
            block = node.getblock(node.getbestblockhash(), verbosity=2)
            block_txids = [tx['txid'] for tx in block['tx']]

            # [ what we want is included ]
            assert tx_with_min_feerate['txid'] in block_template_txids
            assert tx_with_min_feerate['txid'] in block_txids
            # [ what we dont isn't ]
            assert tx_below_min_feerate['txid'] not in block_template_txids
            assert tx_below_min_feerate['txid'] not in block_txids

            # Restart node to clear mempool for the next test
            self.restart_node(0)

```


</details>

This commit adds a few more blockmintxfee cases to the functional test suite for
`blockmintxfee`: 1sat/kvB, 5sat/kvB, and 10sat/kvB, note that 10sat/kvB =
0.01sat/vB.

```diff
-        for blockmintxfee_sat_kvb in (DEFAULT_BLOCK_MIN_TX_FEE, 0, 50, 100, 500, 2500, 5000, 21000, 333333, 2500000):
+        for blockmintxfee_sat_kvb in (DEFAULT_BLOCK_MIN_TX_FEE, 0, 1, 5, 10, 50, 100, 500, 2500, 5000, 21000, 333333, 2500000):
```

One of the sections of the test involves submitting two transactions to the
mempool and then constructing a block, one transaction has a feerate equal to
blockmintxfee:

```python
tx_with_min_feerate = self.wallet.send_self_transfer(from_node=node, fee_rate=blockmintxfee_btc_kvb)
```

and one with a feerate slightly below the blockmintxfee, exactly 0.01sat/vB or 10sat/kvB less:

```python
lowerfee_btc_kvb = blockmintxfee_btc_kvb - Decimal(10)/COIN  # 0.01 sat/vbyte lower
```

Notice though, that in some cases, where the feerate is less than 0.01sat/vB,
this would result in a negative feerate transaction, which is not possible in
practice, but the effect can be approximated with the
`prioritisetransactionrpc`, so in cases where the result would be negative:

```python
tx_below_min_feerate = self.wallet.send_self_transfer(from_node=node, fee_rate=blockmintxfee_btc_kvb)
node.prioritisetransaction(tx_below_min_feerate["txid"], 0, -1)
```

The new test cases requires a change to how we decide whether or not the lower
feerate transaction will be negative:

```diff
-            if blockmintxfee_btc_kvb > 0:
+            if blockmintxfee_sat_kvb > 5:
```

Since 5sat/kvB - 10sat/kvB would be -5sat/kvB. But, more correctly the check
should be:

```python
            if blockmintxfee_sat_kvb >= 10:
```

This commit also adds the following check that no 0-fee transactions are
included if blockmintxfee > 0, which seems correct, but I'm not sure
what it adds over the test's existing check that the minrelayfee transaction was
added, and the one below wasn't:

```python
    # Unless blockmintxfee is 0, the template shouldn't contain free transactions.
    # Note that the real block assembler uses package feerates, but we didn't create dependent transactions so it's ok to use base feerate.
    if blockmintxfee_btc_kvb > 0:
        for txid in block_template_txids:
            tx = node.getmempoolentry(txid)
            assert_greater_than(tx['fees']['base'], 0)
```

### [[test] check bypass of minrelay for various minrelaytxfee settings](https://github.com/bitcoin/bitcoin/pull/33106/commits/85f498893f54ea7d84f2bdf12aa35d198edf8a72)

This commit adds a check that minrelaytxfee doesn't apply to individual TRUC
transactions, but to TRUC packages, and it also checks that v2 transactions with
high package feerates don't get the minrelaytxfee exemption, a simplified
version of this test for legibility:

```python
    def test_minrelay_in_package_combos(self):
        # Loop through a few different minrelaytxfee settings.
        for minrelay_setting in (0, 5, 10, 100, 500, 1000, 5000, 333333, 2500000):
            # [ Units sillyness, the above is in sats/kvB, bitcoind takes an
            #   argument in BTC/kvB ]
            setting_decimal = minrelay_setting / Decimal(COIN)
            # [ Restart the node with the minrelaytxfee setting. ]
            self.restart_node(0, extra_args=[f"-minrelaytxfee={setting_decimal:.8f}", "-persistmempool=0"])
            minrelayfeerate = node.getmempoolinfo()["minrelaytxfee"]
            high_feerate = minrelayfeerate * 50

            # [ Create a high-fee TRUC package, with a parent below
            #    minrelaytxfee and a high fee child. ]
            tx_v3_0fee_parent = self.wallet.create_self_transfer(fee=0, fee_rate=0, confirmed_only=True, version=3)
            tx_v3_child = self.wallet.create_self_transfer(utxo_to_spend=tx_v3_0fee_parent["new_utxo"], fee_rate=high_feerate, version=3)
            total_v3_fee = tx_v3_child["fee"] + tx_v3_0fee_parent["fee"]
            total_v3_size = tx_v3_child["tx"].get_vsize() + tx_v3_0fee_parent["tx"].get_vsize()
            # [ The package feerate is greater than or equal to minrelayfeerate. ]
            assert_greater_than_or_equal(total_v3_fee, get_fee(total_v3_size, minrelayfeerate))

            # [ Do the same but with a v2 transaction. ]
            tx_v2_0fee_parent = self.wallet.create_self_transfer(fee=0, fee_rate=0, confirmed_only=True, version=2)
            tx_v2_child = self.wallet.create_self_transfer(utxo_to_spend=tx_v2_0fee_parent["new_utxo"], fee_rate=high_feerate, version=2)
            total_v2_fee = tx_v2_child["fee"] + tx_v2_0fee_parent["fee"]
            total_v2_size = tx_v2_child["tx"].get_vsize() + tx_v2_0fee_parent["tx"].get_vsize()
            assert_greater_than_or_equal(total_v2_fee, get_fee(total_v2_size, minrelayfeerate))

            # [ The v3 package gets accepted. ]
            result_truc = node.submitpackage([tx_v3_0fee_parent["hex"], tx_v3_child["hex"]], maxfeerate=0)
            assert_equal(result_truc["package_msg"], "success")

            # [ The v2 package only gets accepeted if the minrelayfeerate is > 0. ]
            result_non_truc = node.submitpackage([tx_v2_0fee_parent["hex"], tx_v2_child["hex"]], maxfeerate=0)
            if minrelayfeerate > 0:
                assert_equal(result_non_truc["package_msg"], "transaction failed")
                min_fee_parent = int(get_fee(tx_v2_0fee_parent["tx"].get_vsize(), minrelayfeerate) * COIN)
                assert_equal(result_non_truc["tx-results"][tx_v2_0fee_parent["wtxid"]]["error"], f"min relay fee not met, 0 < {min_fee_parent}")
                self.check_mempool([tx_v3_0fee_parent["txid"], tx_v3_child["txid"]])
            else:
                assert_equal(result_non_truc["package_msg"], "success")
                self.check_mempool([tx_v2_0fee_parent["txid"], tx_v2_child["txid"], tx_v3_0fee_parent["txid"], tx_v3_child["txid"]])
```

### [[test] RBF rule 4 for various incrementalrelayfee settings](https://github.com/bitcoin/bitcoin/pull/33106/commits/72dc18467dbfc16cdbda2dd109b087243b397799)

This commit adds test coverage for various `incrementalrelayfee` settings, this
setting is the implementation of RBF rule 4:

> The replacement transaction must also pay for its own bandwidth at or above
> the rate set by the node's minimum relay fee setting. For example, if the
> minimum relay fee is 1 satoshi/byte and the replacement transaction is 500
> bytes total, then the replacement must pay a fee at least 500 satoshis higher
> than the sum of the originals.

https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki#implementation-details

BIP-0125 describes re-using the minrelaytxfee parameter, but for some reason
that I'm not certain of, an additional knob is provided in Bitcoin Core to tweak
it separately, though they are the same by default, a discussion about removing
the `incrementalrelayfee` knob: https://github.com/bitcoin/bitcoin/pull/33106/commits/6da5de58cabc4133c379baa50845e30e5bc6b3e4#r2267955906

Basically, the test creates a low fee transaction, calculates the necessary
incremental fee to replace it, and makes two replacements, one with the
necessary incremental fee minus 1 sat, check that this is rejected, and the
second with the necessary incremental fee for the replacement, and this is
accepted into the mempool.

```python
    def test_incremental_relay_feerates(self):
        self.log.info("Test that incremental relay fee is applied correctly in RBF for various settings...")
        node = self.nodes[0]
        for incremental_setting in (0, 5, 10, 50, 100, 234, 1000, 5000, 21000):
        # [ Our menagerie of incremental relay fees, expressed in sats/kvB. ]
            # [ Conversion to BTC/kvB, the native units of bitcoind 🤦 ]
            incremental_setting_decimal = incremental_setting / Decimal(COIN)
            # [ Restart with incrementalrelayfee example set... ]
            self.log.info(f"-> Test -incrementalrelayfee={incremental_setting_decimal:.8f}sat/kvB...")
            self.restart_node(0, extra_args=[f"-incrementalrelayfee={incremental_setting_decimal:.8f}", "-persistmempool=0"])

            # When incremental relay feerate is higher than min relay feerate, min relay feerate is automatically increased.
            min_relay_feerate = node.getmempoolinfo()["minrelaytxfee"]
            assert_greater_than_or_equal(min_relay_feerate, incremental_setting_decimal)

            # [ Example low_feerate for a tx, not sure why * 2 was chosen... ]
            low_feerate = min_relay_feerate * 2
            # [ We pick a utxo to spend, holding on to it so that later we can create a replacement that spends the same utxo. ]
            confirmed_utxo = self.wallet.get_utxo(confirmed_only=True)
            # [ Create a transaction that spends our confirmed_utxo with a low fee rate (minfee * 2)
            replacee_tx = self.wallet.create_self_transfer(utxo_to_spend=confirmed_utxo, fee_rate=low_feerate, target_vsize=5000)
            # [ Broadcast it. ]
            node.sendrawtransaction(replacee_tx['hex'])

            # [ Create a replacement transaction, we only want this to see how big the replacement is so that
            replacement_placeholder_tx = self.wallet.create_self_transfer(utxo_to_spend=confirmed_utxo)
            replacement_expected_size = replacement_placeholder_tx['tx'].get_vsize()
            replacement_required_fee = get_fee(replacement_expected_size, incremental_setting_decimal) + replacee_tx['fee']

            # Should always be required to pay additional fees
            if incremental_setting > 0:
                assert_greater_than(replacement_required_fee, replacee_tx['fee'])

            # 1 satoshi shy of the required fee
            failed_replacement_tx = self.wallet.create_self_transfer(utxo_to_spend=confirmed_utxo, fee=replacement_required_fee - Decimal("0.00000001"))
            # [ This should fail. ]
            assert_raises_rpc_error(-26, "insufficient fee", node.sendrawtransaction, failed_replacement_tx['hex'])

            replacement_tx = self.wallet.create_self_transfer(utxo_to_spend=confirmed_utxo, fee=replacement_required_fee)
            node.sendrawtransaction(replacement_tx['hex'])
```
### [[test] explicitly check default -minrelaytxfee and -incrementalrelayfee](https://github.com/bitcoin/bitcoin/pull/33106/commits/1fbee5d7b61b83e68e4230c8a97ca308de92c4c3)

This adds a simple check to the `mempool_accept.py` test suite that the default
values for `minrelaytxfee` and `incrementalrelayfee` are what is expected.

### [[doc] assert that default min relay feerate and incremental are the same](https://github.com/bitcoin/bitcoin/pull/33106/commits/d6213d6aa114aeed6804a585491d741386fd2739)

This commit adds a static assertion to Bitcoin Core that the default incremental
and minrelay fees are equal:

```diff
diff --git a/src/node/mempool_args.cpp b/src/node/mempool_args.cpp
index 11c77ff5610f5..abbe97d9221c6 100644
--- a/src/node/mempool_args.cpp
+++ b/src/node/mempool_args.cpp
@@ -65,6 +65,7 @@ util::Result<void> ApplyArgsManOptions(const ArgsManager& argsman, const CChainP
         }
     }
 
+    static_assert(DEFAULT_MIN_RELAY_TX_FEE == DEFAULT_INCREMENTAL_RELAY_FEE);
     if (const auto arg{argsman.GetArg("-minrelaytxfee")}) {
         if (std::optional<CAmount> min_relay_feerate = ParseMoney(*arg)) {
             // High fee check is done afterward in CWallet::Create()
```

### [[miner] lower default -blockmintxfee to 1sat/kvB](https://github.com/bitcoin/bitcoin/pull/33106/commits/5f2df0ef78be7b24798d0983c9b962740608f1f4)

	Back when we implemented coin age priority as a miner policy, miners
	mempools might admit transactions paying very low fees, but then want to
	set a higher fee for block inclusion. However, since coin age priority
	was removed in v0.15, the block assembly policy is solely based on fees,
	so we do not need to apply minimum feerate rules in multiple places. In
	fact, the block assembly policy ignoring transactions that are added to
	the mempool is likely undesirable as we waste resources accepting and
	storing this transaction.

This commit changes `-blockmintxfee`'s default to 0.001sat/vB, the lowest amount
that can be set. This essentially disables `blockmintxfee` by default, and
instead relies on `mintxrelay` to set fee floor policy for blocks, this seems to
indicate that `-blockmintxfee` should actually be deprecated and `-mintxrelay`
should be used again, but maybe there is an edge case where this knob is still
useful? See discussion here: https://github.com/bitcoin/bitcoin/pull/33106/commits/5f2df0ef78be7b24798d0983c9b962740608f1f4#r2246522617


```diff
diff --git a/src/policy/policy.h b/src/policy/policy.h
index ad787630a45f6..bccd0866a2efe 100644
--- a/src/policy/policy.h
+++ b/src/policy/policy.h
@@ -29,7 +29,7 @@ static constexpr unsigned int DEFAULT_BLOCK_RESERVED_WEIGHT{8000};
  * Setting a lower value is prevented at startup. */
 static constexpr unsigned int MINIMUM_BLOCK_RESERVED_WEIGHT{2000};
 /** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/
-static constexpr unsigned int DEFAULT_BLOCK_MIN_TX_FEE{1000};
+static constexpr unsigned int DEFAULT_BLOCK_MIN_TX_FEE{1};
 /** The maximum weight for transactions we're willing to relay/mine */
 static constexpr int32_t MAX_STANDARD_TX_WEIGHT{400000};
 /** The minimum non-witness size for transactions we're willing to relay/mine: one larger than 64  */
```

It also includes some test changes, most notably (only to me) in the mining
package selection unit tests, it increases the size of a transaction for
mysterious reasons:

```diff
diff --git a/src/test/miner_tests.cpp b/src/test/miner_tests.cpp
index 9207f1bfc2c84..cf0d103b3c767 100644
--- a/src/test/miner_tests.cpp
+++ b/src/test/miner_tests.cpp
@@ -12,6 +12,7 @@
 #include <node/miner.h>
 #include <policy/policy.h>
 #include <test/util/random.h>
+#include <test/util/transaction_utils.h>
 #include <test/util/txmempool.h>
 #include <txmempool.h>
 #include <uint256.h>
@@ -216,6 +217,9 @@ void MinerTestingSetup::TestPackageSelection(const CScript& scriptPubKey, const
     tx.vout.resize(2);
     tx.vout[0].nValue = 5000000000LL - 100000000;
     tx.vout[1].nValue = 100000000; // 1BTC output
+    // Increase size to avoid rounding errors: when the feerate is extremely small (i.e. 1sat/kvB), evaluating the fee
+    // at a smaller transaction size gives us a rounded value of 0.
+    BulkTransaction(tx, 4000);
     Txid hashFreeTx2 = tx.GetHash();
     AddToMempool(tx_mempool, entry.Fee(0).SpendsCoinbase(true).FromTx(tx));
```

### [[prep/test] replace magic number 1000 with respective feerate vars](https://github.com/bitcoin/bitcoin/pull/33106/commits/3eab8b724044dc321f70e5eed66b149713158a04)

This commit is boring, `s/1000/DEFAULT_INCREMENTAL_RELAY_FEE` in
`src/test/mempool_tests.cpp`:

```diff
diff --git a/src/test/mempool_tests.cpp b/src/test/mempool_tests.cpp
index 5992d2a41ebd6..b75a1cc77adec 100644
--- a/src/test/mempool_tests.cpp
+++ b/src/test/mempool_tests.cpp
@@ -482,7 +482,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     BOOST_CHECK(!pool.exists(tx3.GetHash()));
 
     CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(CTransaction(tx3)) + GetVirtualTransactionSize(CTransaction(tx2)));
-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);
+    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE);
 
     CMutableTransaction tx4 = CMutableTransaction();
     tx4.vin.resize(2);
@@ -559,28 +559,28 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     std::vector<CTransactionRef> vtx;
     SetMockTime(42);
     SetMockTime(42 + CTxMemPool::ROLLING_FEE_HALFLIFE);
-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);
+    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE);
     // ... we should keep the same min fee until we get a block
     pool.removeForBlock(vtx, 1);
     SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE);
-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + 1000)/2.0));
+    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE)/2.0));
     // ... then feerate should drop 1/2 each halflife
 
     SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2);
-    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 5 / 2).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + 1000)/4.0));
+    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 5 / 2).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE)/4.0));
     // ... with a 1/2 halflife when mempool is < 1/2 its target size
 
     SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);
-    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 9 / 2).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + 1000)/8.0));
+    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 9 / 2).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE)/8.0));
     // ... with a 1/4 halflife when mempool is < 1/4 its target size
 
     SetMockTime(42 + 7*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);
-    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 1000);
-    // ... but feerate should never drop below 1000
+    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), DEFAULT_INCREMENTAL_RELAY_FEE);
+    // ... but feerate should never drop below DEFAULT_INCREMENTAL_RELAY_FEE
 
     SetMockTime(42 + 8*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);
     BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 0);
-    // ... unless it has gone all the way to 0 (after getting past 1000/2)
+    // ... unless it has gone all the way to 0 (after getting past DEFAULT_INCREMENTAL_RELAY_FEE/2)
 }
```

and a little bit of removing assertions that utter the exact minrelaytxfee from
various functional tests:

<details>

<summary></summary>

```diff
inline CTransactionRef make_tx(std::vector<CAmount>&& output_values, std::vector<CTransactionRef>&& inputs=std::vector<CTransactionRef>(), std::vector<uint32_t>&& input_indices=std::vector<uint32_t>())
diff --git a/test/functional/mempool_limit.py b/test/functional/mempool_limit.py
index c9a200cfd9bba..2a127007a4180 100755
--- a/test/functional/mempool_limit.py
+++ b/test/functional/mempool_limit.py
@@ -92,8 +92,7 @@ def test_mid_package_eviction_success(self):
         assert_equal(node.getrawmempool(), [])
 
         # Restarting the node resets mempool minimum feerate
-        assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))
-        assert_equal(node.getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))
+        assert_equal(node.getmempoolinfo()['minrelaytxfee'], node.getmempoolinfo()["mempoolminfee"])
 
         fill_mempool(self, node)
         current_info = node.getmempoolinfo()
@@ -184,8 +183,7 @@ def test_mid_package_replacement(self):
         self.restart_node(0, extra_args=self.extra_args[0])
 
         # Restarting the node resets mempool minimum feerate
-        assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))
-        assert_equal(node.getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))
+        assert_equal(node.getmempoolinfo()['minrelaytxfee'], node.getmempoolinfo()["mempoolminfee"])
 
         fill_mempool(self, node)
         current_info = node.getmempoolinfo()
@@ -256,8 +254,7 @@ def run_test(self):
 
         relayfee = node.getnetworkinfo()['relayfee']
         self.log.info('Check that mempoolminfee is minrelaytxfee')
-        assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))
-        assert_equal(node.getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))
+        assert_equal(node.getmempoolinfo()['minrelaytxfee'], node.getmempoolinfo()["mempoolminfee"])
 
         fill_mempool(self, node)
 
diff --git a/test/functional/test_framework/mempool_util.py b/test/functional/test_framework/mempool_util.py
index a0b6f5d088fba..78e5f06021be1 100644
--- a/test/functional/test_framework/mempool_util.py
+++ b/test/functional/test_framework/mempool_util.py
@@ -3,7 +3,6 @@
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 """Helpful routines for mempool testing."""
-from decimal import Decimal
 import random
 
 from .blocktools import (
@@ -62,9 +61,7 @@ def fill_mempool(test_framework, node, *, tx_sync_fun=None):
     """
     test_framework.log.info("Fill the mempool until eviction is triggered and the mempoolminfee rises")
     txouts = gen_return_txouts()
-    relayfee = node.getnetworkinfo()['relayfee']
-
-    assert_equal(relayfee, Decimal('0.00001000'))
+    minrelayfee = node.getnetworkinfo()['relayfee']
 
     tx_batch_size = 1
     num_of_batches = 75
@@ -84,7 +81,7 @@ def fill_mempool(test_framework, node, *, tx_sync_fun=None):
 
     test_framework.log.debug("Create a mempool tx that will be evicted")
     tx_to_be_evicted_id = ephemeral_miniwallet.send_self_transfer(
-        from_node=node, utxo_to_spend=confirmed_utxos.pop(0), fee_rate=relayfee)["txid"]
+        from_node=node, utxo_to_spend=confirmed_utxos.pop(0), fee_rate=minrelayfee)["txid"]
 
     def send_batch(fee):
         utxos = confirmed_utxos[:tx_batch_size]
@@ -94,14 +91,14 @@ def send_batch(fee):
     # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool
     # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)
     # by 130 should result in a fee that corresponds to 2x of that fee rate
-    base_fee = relayfee * 130
+    base_fee = minrelayfee * 130
     batch_fees = [(i + 1) * base_fee for i in range(num_of_batches)]
 
     test_framework.log.debug("Fill up the mempool with txs with higher fee rate")
     for fee in batch_fees[:-3]:
         send_batch(fee)
     tx_sync_fun() if tx_sync_fun else test_framework.sync_mempools()  # sync before any eviction
-    assert_equal(node.getmempoolinfo()["mempoolminfee"], Decimal("0.00001000"))
+    assert_equal(node.getmempoolinfo()["mempoolminfee"], minrelayfee)
     for fee in batch_fees[-3:]:
         send_batch(fee)
     tx_sync_fun() if tx_sync_fun else test_framework.sync_mempools()  # sync after all evictions
@@ -113,8 +110,8 @@ def send_batch(fee):
     assert tx_to_be_evicted_id not in node.getrawmempool()
 
     test_framework.log.debug("Check that mempoolminfee is larger than minrelaytxfee")
-    assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))
-    assert_greater_than(node.getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))
+    assert_equal(node.getmempoolinfo()['minrelaytxfee'], minrelayfee)
+    assert_greater_than(node.getmempoolinfo()['mempoolminfee'], minrelayfee)
 
 def tx_in_orphanage(node, tx: CTransaction) -> bool:
     """Returns true if the transaction is in the orphanage."""
```
</details>

### [[prep/util] help MockMempoolMinFee handle more precise feerates](https://github.com/bitcoin/bitcoin/pull/33106/commits/457cfb61b5323a13218b3cfb5a6a6d8b3a7c5f7f)

	Use a virtual size of 1000 to keep precision when using a feerate
	(which is rounded to the nearest satoshi per kvb) that isn't just an
	integer.

This modifies a unit test utility function
`TestChain100Setup::MockMempoolMinFee(const CFeeRate& target_feerate)` that let's you set a target `mempoolminfee` for a chain. This function asserts that the resulting mempoolminfee is eactly what the passed argument asked it to be at the end:

```cpp
    assert(m_node.mempool->GetMinFee() == target_feerate);
```

But for very small target_feerate amounts, (e.g. 0.1sat/vB) there can be rounding errors between the two, so this commit makes the transaction at the target fee rate very large to avoid rounding errors in the computing of the mempoolminfee:

```diff
diff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp
index 76a42d19ea2e4..9c9bdc70ccdb6 100644
--- a/src/test/util/setup_common.cpp
+++ b/src/test/util/setup_common.cpp
@@ -586,6 +587,9 @@ void TestChain100Setup::MockMempoolMinFee(const CFeeRate& target_feerate)
     CMutableTransaction mtx = CMutableTransaction();
     mtx.vin.emplace_back(COutPoint{Txid::FromUint256(m_rng.rand256()), 0});
     mtx.vout.emplace_back(1 * COIN, GetScriptForDestination(WitnessV0ScriptHash(CScript() << OP_TRUE)));
+    // Set a large size so that the fee evaluated at target_feerate (which is usually in sats/kvB) is an integer.
+    // Otherwise, GetMinFee() may end up slightly different from target_feerate.
+    BulkTransaction(mtx, 4000);
     const auto tx{MakeTransactionRef(mtx)};
     LockPoints lp;
     // The new mempool min feerate is equal to the removed package's feerate + incremental feerate.
```

### [[prep/test] make wallet_fundrawtransaction's minrelaytxfee assumption explicit](https://github.com/bitcoin/bitcoin/pull/33106/commits/2e515d2897eaa5a9b012eb78aef105e1cf80d42b)

The `wallet_fundrawtransaction.py` functional test   depends in some way on `minrelaytxfee` having it's current value of 1000 sats/kvB (0.00001000 BTC/kvB). I have not reviewed it myself but I have tested that the test breaks if minrelaytxfee is lowered without this test change. In lieu of making a bunch of modifications to the test, this commit manually sets the `-minrelaytxfee` in this test, so that when the default value is changed in a later commit, this test doesn't break, that seems fair enough to me.

```diff
diff --git a/test/functional/wallet_fundrawtransaction.py b/test/functional/wallet_fundrawtransaction.py
index 2d5c5a2d9939a..7cf92876b3fe5 100755
--- a/test/functional/wallet_fundrawtransaction.py
+++ b/test/functional/wallet_fundrawtransaction.py
@@ -43,7 +43,8 @@ class RawTransactionsTest(BitcoinTestFramework):
     def set_test_params(self):
         self.num_nodes = 4
         self.extra_args = [[
-            "-deprecatedrpc=settxfee"
+            "-deprecatedrpc=settxfee",
+            "-minrelaytxfee=0.00001000",
         ] for i in range(self.num_nodes)]
         self.setup_clean_chain = True
         # whitelist peers to speed up tx relay / mempool sync
```

### [[policy] lower default minrelaytxfee and incrementalrelayfee to 100sat/kvB](https://github.com/bitcoin/bitcoin/pull/33106/commits/6da5de58cabc4133c379baa50845e30e5bc6b3e4)

	Let's say an attacker wants to use/exhaust the network's bandwidth, and
	has the choice between renting resources from a commercial provider and
	getting the network to "spam" itself it by sending unconfirmed
	transactions. We'd like the latter to be more expensive than the former.
    
    The bandwidth for relaying a transaction across the network is roughly
    its serialized size (plus relay overhead) x number of nodes. A 1000vB
    transaction is 1000-4000B serialized. With 100k nodes, that's 0.1-0.4GB
    If the going rate for commercial services is 10c/GB, that's like 1-4c per kvB
    of transaction data, so a 1000vB transaction should pay at least $0.04.

    At a price of 120k USD/BTC, 100sat is about $0.12. This price allows us
    to tolerate a large decrease in the conversion rate or increase in the
    number of nodes.

The most important commit in the series, this actually changes `minrelaytxfee`. It also changes `incrementalrelayfee`, since both are intended to represent the same thing, cost of network relay, see above.

```diff
diff --git a/src/policy/policy.h b/src/policy/policy.h
index bccd0866a2efe..ce8bfc6aef93f 100644
--- a/src/policy/policy.h
+++ b/src/policy/policy.h
@@ -41,7 +41,7 @@ static constexpr unsigned int MAX_STANDARD_TX_SIGOPS_COST{MAX_BLOCK_SIGOPS_COST/
 /** The maximum number of potentially executed legacy signature operations in a single standard tx */
 static constexpr unsigned int MAX_TX_LEGACY_SIGOPS{2'500};
 /** Default for -incrementalrelayfee, which sets the minimum feerate increase for mempool limiting or replacement **/
-static constexpr unsigned int DEFAULT_INCREMENTAL_RELAY_FEE{1000};
+static constexpr unsigned int DEFAULT_INCREMENTAL_RELAY_FEE{100};
 /** Default for -bytespersigop */
 static constexpr unsigned int DEFAULT_BYTES_PER_SIGOP{20};
 /** Default for -permitbaremultisig */
@@ -63,7 +63,7 @@ static constexpr unsigned int MAX_STANDARD_SCRIPTSIG_SIZE{1650};
  * outputs below the new threshold */
 static constexpr unsigned int DUST_RELAY_TX_FEE{3000};
 /** Default for -minrelaytxfee, minimum relay fee for transactions */
-static constexpr unsigned int DEFAULT_MIN_RELAY_TX_FEE{1000};
+static constexpr unsigned int DEFAULT_MIN_RELAY_TX_FEE{100};
 /** Default for -limitancestorcount, max number of in-mempool ancestors */
 static constexpr unsigned int DEFAULT_ANCESTOR_LIMIT{25};
 /** Default for -limitancestorsize, maximum kilobytes of tx + all in-mempool ancestors */
```

The commit also makes some changes to `MempoolSizeLimitTest` to avoid rounding
issues:

<details>


<summary>MempoolSizeLimitTest annotated</summary>


```cpp
BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
{
    // [ Create a mempool. ]
    auto& pool = static_cast<MemPoolTest&>(*Assert(m_node.mempool));
    // [ Take a pool lock 🏊 ]
    LOCK2(cs_main, pool.cs);
    // [ Helper for CTxMempoolEntry. ]
    TestMemPoolEntryHelper entry;

    // [ Create a 1-in 1-out transaction that creates a 10 BTC output with 1000sats of fees. ]
    CMutableTransaction tx1 = CMutableTransaction();
    tx1.vin.resize(1);
    tx1.vin[0].scriptSig = CScript() << OP_1;
    tx1.vout.resize(1);
    tx1.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;
    tx1.vout[0].nValue = 10 * COIN;
    AddToMempool(pool, entry.Fee(10000LL).FromTx(tx1));

    // [ Same as the above transaction, but fee is 500 sats. ]
    CMutableTransaction tx2 = CMutableTransaction();
    tx2.vin.resize(1);
    tx2.vin[0].scriptSig = CScript() << OP_2;
    tx2.vout.resize(1);
    tx2.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;
    tx2.vout[0].nValue = 10 * COIN;
    AddToMempool(pool, entry.Fee(5000LL).FromTx(tx2));

    // [ Trim the pool to it's existing size, this should not remove any tx'es. ]
    pool.TrimToSize(pool.DynamicMemoryUsage()); // should do nothing
    BOOST_CHECK(pool.exists(tx1.GetHash()));
    BOOST_CHECK(pool.exists(tx2.GetHash()));

    // [ Trim the pool to slightly smaller than it's existing size, this should evict the lower feerate transaction: tx2. ]
    pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // should remove the lower-feerate transaction
    BOOST_CHECK(pool.exists(tx1.GetHash()));
    BOOST_CHECK(!pool.exists(tx2.GetHash()));

    // [ Add the trimmed tx2 back in! ]
    AddToMempool(pool, entry.FromTx(tx2));
    // [ Create a third transaction, this pays the largest fee, and has the low feerate tx as an ancestor, as a package tx2 + tx3 pay a higher feerate than tx1. ]
    CMutableTransaction tx3 = CMutableTransaction();
    tx3.vin.resize(1);
    tx3.vin[0].prevout = COutPoint(tx2.GetHash(), 0);
    tx3.vin[0].scriptSig = CScript() << OP_2;
    tx3.vout.resize(1);
    tx3.vout[0].scriptPubKey = CScript() << OP_3 << OP_EQUAL;
    tx3.vout[0].nValue = 10 * COIN;
    AddToMempool(pool, entry.Fee(20000LL).FromTx(tx3));

    // [ Trimming now should result in the lower feerate package tx1 getting evicted. ]
    pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // tx3 should pay for tx2 (CPFP)
    BOOST_CHECK(!pool.exists(tx1.GetHash()));
    BOOST_CHECK(pool.exists(tx2.GetHash()));
    BOOST_CHECK(pool.exists(tx3.GetHash()));

    // [ actually not sure I fully follow this one, we trim to the vsize of tx1, so definitely nothing should fit, none of the tx'es fit including tx1 in just tx1's vsize...]
    pool.TrimToSize(GetVirtualTransactionSize(CTransaction(tx1))); // mempool is limited to tx1's size in memory usage, so nothing fits
    BOOST_CHECK(!pool.exists(tx1.GetHash()));
    BOOST_CHECK(!pool.exists(tx2.GetHash()));
    BOOST_CHECK(!pool.exists(tx3.GetHash()));

    // [ Get the feerate of the higher fee tx2+tx3 package this is the mempool's maxFeeRateRemoved, which I guess is an important metric in the eviction logic. ]
    CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(CTransaction(tx3)) + GetVirtualTransactionSize(CTransaction(tx2)));
    // [ GetMinFee(1) get's the fee for a tx sized 1 to enter the mempool at it's current mempoolminfee, it looks like based on this that the mempool's min fee is equal to the feerate of the highest feerate removed plus the incremental relay fee. ]
    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE);

    // [ tx4 has two 10 BTC outputs. ]
    CMutableTransaction tx4 = CMutableTransaction();
    tx4.vin.resize(2);
    tx4.vin[0].prevout.SetNull();
    tx4.vin[0].scriptSig = CScript() << OP_4;
    tx4.vin[1].prevout.SetNull();
    tx4.vin[1].scriptSig = CScript() << OP_4;
    tx4.vout.resize(2);
    tx4.vout[0].scriptPubKey = CScript() << OP_4 << OP_EQUAL;
    tx4.vout[0].nValue = 10 * COIN;
    tx4.vout[1].scriptPubKey = CScript() << OP_4 << OP_EQUAL;
    tx4.vout[1].nValue = 10 * COIN;

    // [ tx5 has two 10 BTC outputs, descendant of tx4. ]
    CMutableTransaction tx5 = CMutableTransaction();
    tx5.vin.resize(2);
    tx5.vin[0].prevout = COutPoint(tx4.GetHash(), 0);
    tx5.vin[0].scriptSig = CScript() << OP_4;
    tx5.vin[1].prevout.SetNull();
    tx5.vin[1].scriptSig = CScript() << OP_5;
    tx5.vout.resize(2);
    tx5.vout[0].scriptPubKey = CScript() << OP_5 << OP_EQUAL;
    tx5.vout[0].nValue = 10 * COIN;
    tx5.vout[1].scriptPubKey = CScript() << OP_5 << OP_EQUAL;
    tx5.vout[1].nValue = 10 * COIN;

    // [ tx6 has 2*10BTC outputs, descendant of tx4. ]
    CMutableTransaction tx6 = CMutableTransaction();
    tx6.vin.resize(2);
    tx6.vin[0].prevout = COutPoint(tx4.GetHash(), 1);
    tx6.vin[0].scriptSig = CScript() << OP_4;
    tx6.vin[1].prevout.SetNull();
    tx6.vin[1].scriptSig = CScript() << OP_6;
    tx6.vout.resize(2);
    tx6.vout[0].scriptPubKey = CScript() << OP_6 << OP_EQUAL;
    tx6.vout[0].nValue = 10 * COIN;
    tx6.vout[1].scriptPubKey = CScript() << OP_6 << OP_EQUAL;
    tx6.vout[1].nValue = 10 * COIN;

    // [ tx7 is a descendant of tx5 and tx6, two 10 btc outputs. ]
    CMutableTransaction tx7 = CMutableTransaction();
    tx7.vin.resize(2);
    tx7.vin[0].prevout = COutPoint(tx5.GetHash(), 0);
    tx7.vin[0].scriptSig = CScript() << OP_5;
    tx7.vin[1].prevout = COutPoint(tx6.GetHash(), 0);
    tx7.vin[1].scriptSig = CScript() << OP_6;
    tx7.vout.resize(2);
    tx7.vout[0].scriptPubKey = CScript() << OP_7 << OP_EQUAL;
    tx7.vout[0].nValue = 10 * COIN;
    tx7.vout[1].scriptPubKey = CScript() << OP_7 << OP_EQUAL;
    tx7.vout[1].nValue = 10 * COIN;

    // [ Add them to the mempool at varying feerates, it's a package! ]
    AddToMempool(pool, entry.Fee(7000LL).FromTx(tx4));
    AddToMempool(pool, entry.Fee(1000LL).FromTx(tx5));
    AddToMempool(pool, entry.Fee(1100LL).FromTx(tx6));
    AddToMempool(pool, entry.Fee(9000LL).FromTx(tx7));

    // [ I don't understand why this removes two tx'es rather than one?
    //   Oh! This is related to the reason for cluster mempool! It's because mempool
    //   eviction is lowest descendant score first, and that means tx5 is the target! ]

    // we only require this to remove, at max, 2 txn, because it's not clear what we're really optimizing for aside from that
    pool.TrimToSize(pool.DynamicMemoryUsage() - 1);
    BOOST_CHECK(pool.exists(tx4.GetHash()));
    // [ The original test intended (shown by the if below) for tx5 to only
    //   be missing sometimes, but In practice, the following check
    //   always passes:
    //
    //   BOOST_CHECK(!pool.exists(tx5.GetHash()));
    // ]
    BOOST_CHECK(pool.exists(tx6.GetHash()));
    BOOST_CHECK(!pool.exists(tx7.GetHash()));

    // [ This check always is true ]
    if (!pool.exists(tx5.GetHash()))
        AddToMempool(pool, entry.Fee(100LL).FromTx(tx5));
    AddToMempool(pool, entry.Fee(900LL).FromTx(tx7));

    // [ Cut space in half, half tx'es should go with lowest descendant feerates. ]
    pool.TrimToSize(pool.DynamicMemoryUsage() / 2); // should maximize mempool size by only removing 5/7
    BOOST_CHECK(pool.exists(tx4.GetHash()));
    BOOST_CHECK(!pool.exists(tx5.GetHash()));
    BOOST_CHECK(pool.exists(tx6.GetHash()));
    BOOST_CHECK(!pool.exists(tx7.GetHash()));

    // [ Add 'em back 🔫 ]
    AddToMempool(pool, entry.Fee(1000LL).FromTx(tx5));
    AddToMempool(pool, entry.Fee(9000LL).FromTx(tx7));

    // [ the minimum fee to enter the mempool decreases on a half-life. ]
    std::vector<CTransactionRef> vtx;
    SetMockTime(42);
    SetMockTime(42 + CTxMemPool::ROLLING_FEE_HALFLIFE);
    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE);
    // ... we should keep the same min fee until we get a block
    pool.removeForBlock(vtx, 1);
    SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE);
    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE)/2.0));
    // ... then feerate should drop 1/2 each halflife

    SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2);
    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 5 / 2).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE)/4.0));
    // ... with a 1/2 halflife when mempool is < 1/2 its target size

    SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);
    BOOST_CHECK_EQUAL(pool.GetMinFee(pool.DynamicMemoryUsage() * 9 / 2).GetFeePerK(), llround((maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE)/8.0));
    // ... with a 1/4 halflife when mempool is < 1/4 its target size

    SetMockTime(42 + 7*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);
    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), DEFAULT_INCREMENTAL_RELAY_FEE);
    // ... but feerate should never drop below DEFAULT_INCREMENTAL_RELAY_FEE

    SetMockTime(42 + 8*CTxMemPool::ROLLING_FEE_HALFLIFE + CTxMemPool::ROLLING_FEE_HALFLIFE/2 + CTxMemPool::ROLLING_FEE_HALFLIFE/4);
    BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), 0);
    // ... unless it has gone all the way to 0 (after getting past DEFAULT_INCREMENTAL_RELAY_FEE/2)
}
```

</details>

<details>


<summary>diff</summary>

```diff
diff --git a/src/test/mempool_tests.cpp b/src/test/mempool_tests.cpp
index b75a1cc77adec..5f8b63dbdd7d4 100644
--- a/src/test/mempool_tests.cpp
+++ b/src/test/mempool_tests.cpp
@@ -443,7 +443,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     tx1.vout.resize(1);
     tx1.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;
     tx1.vout[0].nValue = 10 * COIN;
-    AddToMempool(pool, entry.Fee(10000LL).FromTx(tx1));
+    AddToMempool(pool, entry.Fee(1000LL).FromTx(tx1));
 
     CMutableTransaction tx2 = CMutableTransaction();
     tx2.vin.resize(1);
@@ -451,7 +451,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     tx2.vout.resize(1);
     tx2.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;
     tx2.vout[0].nValue = 10 * COIN;
-    AddToMempool(pool, entry.Fee(5000LL).FromTx(tx2));
+    AddToMempool(pool, entry.Fee(500LL).FromTx(tx2));
 
     pool.TrimToSize(pool.DynamicMemoryUsage()); // should do nothing
     BOOST_CHECK(pool.exists(tx1.GetHash()));
@@ -469,7 +469,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     tx3.vout.resize(1);
     tx3.vout[0].scriptPubKey = CScript() << OP_3 << OP_EQUAL;
     tx3.vout[0].nValue = 10 * COIN;
-    AddToMempool(pool, entry.Fee(20000LL).FromTx(tx3));
+    AddToMempool(pool, entry.Fee(2000LL).FromTx(tx3));
 
     pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // tx3 should pay for tx2 (CPFP)
     BOOST_CHECK(!pool.exists(tx1.GetHash()));
@@ -481,7 +481,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     BOOST_CHECK(!pool.exists(tx2.GetHash()));
     BOOST_CHECK(!pool.exists(tx3.GetHash()));
 
-    CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(CTransaction(tx3)) + GetVirtualTransactionSize(CTransaction(tx2)));
+    CFeeRate maxFeeRateRemoved(2500, GetVirtualTransactionSize(CTransaction(tx3)) + GetVirtualTransactionSize(CTransaction(tx2)));
     BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + DEFAULT_INCREMENTAL_RELAY_FEE);
 
     CMutableTransaction tx4 = CMutableTransaction();
@@ -532,10 +532,10 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     tx7.vout[1].scriptPubKey = CScript() << OP_7 << OP_EQUAL;
     tx7.vout[1].nValue = 10 * COIN;
 
-    AddToMempool(pool, entry.Fee(7000LL).FromTx(tx4));
-    AddToMempool(pool, entry.Fee(1000LL).FromTx(tx5));
-    AddToMempool(pool, entry.Fee(1100LL).FromTx(tx6));
-    AddToMempool(pool, entry.Fee(9000LL).FromTx(tx7));
+    AddToMempool(pool, entry.Fee(700LL).FromTx(tx4));
+    AddToMempool(pool, entry.Fee(100LL).FromTx(tx5));
+    AddToMempool(pool, entry.Fee(110LL).FromTx(tx6));
+    AddToMempool(pool, entry.Fee(900LL).FromTx(tx7));
 
     // we only require this to remove, at max, 2 txn, because it's not clear what we're really optimizing for aside from that
     pool.TrimToSize(pool.DynamicMemoryUsage() - 1);
@@ -544,8 +544,8 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     BOOST_CHECK(!pool.exists(tx7.GetHash()));
 
     if (!pool.exists(tx5.GetHash()))
-        AddToMempool(pool, entry.Fee(1000LL).FromTx(tx5));
-    AddToMempool(pool, entry.Fee(9000LL).FromTx(tx7));
+        AddToMempool(pool, entry.Fee(100LL).FromTx(tx5));
+    AddToMempool(pool, entry.Fee(900LL).FromTx(tx7));
 
     pool.TrimToSize(pool.DynamicMemoryUsage() / 2); // should maximize mempool size by only removing 5/7
     BOOST_CHECK(pool.exists(tx4.GetHash()));
@@ -553,8 +553,8 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)
     BOOST_CHECK(pool.exists(tx6.GetHash()));
     BOOST_CHECK(!pool.exists(tx7.GetHash()));
 
-    AddToMempool(pool, entry.Fee(1000LL).FromTx(tx5));
-    AddToMempool(pool, entry.Fee(9000LL).FromTx(tx7));
+    AddToMempool(pool, entry.Fee(100LL).FromTx(tx5));
+    AddToMempool(pool, entry.Fee(900LL).FromTx(tx7));
 
     std::vector<CTransactionRef> vtx;
     SetMockTime(42);
```

</details>

This commit also makes changes to increase the size of some transactions in
rbf_tests.cpp since if the transaction size is too small, the incremental relay
feerate is sub-1 so certain scenarios that are expected to fail due to not
covering the incremental relay feerate actually succeed:

```diff
diff --git a/src/test/rbf_tests.cpp b/src/test/rbf_tests.cpp
index 0052276eac470..ade698b017dc6 100644
--- a/src/test/rbf_tests.cpp
+++ b/src/test/rbf_tests.cpp
@@ -238,10 +238,10 @@ BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)
     BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());
     BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());
     // Additional fees must cover the replacement's vsize at incremental relay fee
-    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());
-    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);
-    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());
-    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);
+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 11, incremental_relay_feerate, unused_txid).has_value());
+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 10, incremental_relay_feerate, unused_txid) == std::nullopt);
+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 11, higher_relay_feerate, unused_txid).has_value());
+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 20, higher_relay_feerate, unused_txid) == std::nullopt);
     BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());
     BOOST_CHECK(PaysForRBF(low_fee, high_fee + 99999999, 99999999, incremental_relay_feerate, unused_txid) == std::nullopt);
``` 

Simple functional test change for a test that checks what the default
`incrementalrelayfee` is:

```diff
diff --git a/test/functional/feature_rbf.py b/test/functional/feature_rbf.py
index 5f462512c7c4a..4117326b88324 100755
--- a/test/functional/feature_rbf.py
+++ b/test/functional/feature_rbf.py
@@ -585,7 +585,7 @@ def test_replacement_relay_fee(self):
 
         # Higher fee, higher feerate, different txid, but the replacement does not provide a relay
         # fee conforming to node's `incrementalrelayfee` policy of 1000 sat per KB.
-        assert_equal(self.nodes[0].getmempoolinfo()["incrementalrelayfee"], Decimal("0.00001"))
+        assert_equal(self.nodes[0].getmempoolinfo()["incrementalrelayfee"], Decimal("0.000001"))
         tx.vout[0].nValue -= 1
         assert_raises_rpc_error(-26, "insufficient fee", self.nodes[0].sendrawtransaction, tx.serialize().hex())
```

another functional test checks for an error relating to the min relay fee not
being met, and it looks for an exact error message, since this commit changes
minrelayfee, that message has to change, 147, becomes 14.7, and gets rounded up
to 15 (see
[`CFeeRate::GetFee`](https://github.com/bitcoin/bitcoin/blob/8405fdb06e8ff3220590bfac84e98547067ec6b7/src/policy/feerate.cpp#L24))

```diff
diff --git a/test/functional/mempool_ephemeral_dust.py b/test/functional/mempool_ephemeral_dust.py
index fd77eac3e2b2a..a0308da72acb6 100755
--- a/test/functional/mempool_ephemeral_dust.py
+++ b/test/functional/mempool_ephemeral_dust.py
@@ -216,7 +216,7 @@ def test_non_truc(self):
 
         res = self.nodes[0].submitpackage([dusty_tx["hex"], sweep_tx["hex"]])
         assert_equal(res["package_msg"], "transaction failed")
-        assert_equal(res["tx-results"][dusty_tx["wtxid"]]["error"], "min relay fee not met, 0 < 147")
+        assert_equal(res["tx-results"][dusty_tx["wtxid"]]["error"], "min relay fee not met, 0 < 15")
 
         assert_equal(self.nodes[0].getrawmempool(), [])
``` 


There is a P2P message called `feefilter`, used to inform peers of our
`mempoolminfee`, and asking them not to broadcast tx'es below mempoolminfee to
us. There is a rounding mechanism used to avoid this being a privacy leak, and
that rounds in increments starting with `DEFAULT_MIN_RELAY_TX_FEE / 2` and
increasing by multiplying by powers of `1.1`, because of that some adjustments
need to be made in tests that check for specific fee filters used during IBD:

```diff
diff --git a/test/functional/p2p_ibd_txrelay.py b/test/functional/p2p_ibd_txrelay.py
index 870324d76c3e1..0cd0ac05b2c78 100755
--- a/test/functional/p2p_ibd_txrelay.py
+++ b/test/functional/p2p_ibd_txrelay.py
@@ -28,8 +28,8 @@
 )
 from test_framework.test_framework import BitcoinTestFramework
 
-MAX_FEE_FILTER = Decimal(9170997) / COIN
-NORMAL_FEE_FILTER = Decimal(100) / COIN
+MAX_FEE_FILTER = Decimal(9936506) / COIN
+NORMAL_FEE_FILTER = Decimal(10) / COIN
 
 
 class P2PIBDTxRelayTest(BitcoinTestFramework):
@@ -37,8 +37,8 @@ def set_test_params(self):
         self.setup_clean_chain = True
         self.num_nodes = 2
         self.extra_args = [
-            ["-minrelaytxfee={}".format(NORMAL_FEE_FILTER)],
-            ["-minrelaytxfee={}".format(NORMAL_FEE_FILTER)],
+            ["-minrelaytxfee={:.8f}".format(NORMAL_FEE_FILTER)],
+            ["-minrelaytxfee={:.8f}".format(NORMAL_FEE_FILTER)],
         ]
 
     def run_test(self):
```

This might raise privacy concerns since it reduces increments below 0.1sat/vB:
https://github.com/bitcoin/bitcoin/pull/33106/commits/6da5de58cabc4133c379baa50845e30e5bc6b3e4

Another change is to the bumpfee test, some of the values need to be lowered
from <1sat/vb to <0.1sat/vb to get under the incremental relay fee:

```diff
diff --git a/test/functional/wallet_bumpfee.py b/test/functional/wallet_bumpfee.py
index 05965caacd3c6..097c39575a350 100755
--- a/test/functional/wallet_bumpfee.py
+++ b/test/functional/wallet_bumpfee.py
@@ -535,7 +535,7 @@ def test_dust_to_fee(self, rbf_node, dest_address):
 
 def test_settxfee(self, rbf_node, dest_address):
     self.log.info('Test settxfee')
-    assert_raises_rpc_error(-8, "txfee cannot be less than min relay tx fee", rbf_node.settxfee, Decimal('0.000005'))
+    assert_raises_rpc_error(-8, "txfee cannot be less than min relay tx fee", rbf_node.settxfee, Decimal('0.0000005'))
     assert_raises_rpc_error(-8, "txfee cannot be less than wallet min fee", rbf_node.settxfee, Decimal('0.000015'))
     # check that bumpfee reacts correctly to the use of settxfee (paytxfee)
     rbfid = spend_one_input(rbf_node, dest_address)
@@ -850,7 +850,7 @@ def test_bumpfee_with_feerate_ignores_walletincrementalrelayfee(self, rbf_node,
 
     # Ensure you can not fee bump if the fee_rate is more than original fee_rate but the total fee from new fee_rate is
     # less than (original fee + incrementalrelayfee)
-    assert_raises_rpc_error(-8, "Insufficient total fee", rbf_node.bumpfee, tx["txid"], {"fee_rate": 2.8})
+    assert_raises_rpc_error(-8, "Insufficient total fee", rbf_node.bumpfee, tx["txid"], {"fee_rate": 2.05})
 
     # You can fee bump as long as the new fee set from fee_rate is at least (original fee + incrementalrelayfee)
     rbf_node.bumpfee(tx["txid"], {"fee_rate": 3})
```

Changes to the global defaults set in the test framework:

```diff
diff --git a/test/functional/test_framework/mempool_util.py b/test/functional/test_framework/mempool_util.py
index 78e5f06021be1..901a4ed62e6f1 100644
--- a/test/functional/test_framework/mempool_util.py
+++ b/test/functional/test_framework/mempool_util.py
@@ -30,9 +30,9 @@
 )
 
 # Default for -minrelaytxfee in sat/kvB
-DEFAULT_MIN_RELAY_TX_FEE = 1000
+DEFAULT_MIN_RELAY_TX_FEE = 100
 # Default for -incrementalrelayfee in sat/kvB
-DEFAULT_INCREMENTAL_RELAY_FEE = 1000
+DEFAULT_INCREMENTAL_RELAY_FEE = 100
 
 def assert_mempool_contents(test_framework, node, expected=None, sync=True):
     """Assert that all transactions in expected are in the mempool,
```

In `p2p_1p1c_network.py` instances of `FEERATE_1SAT_VB` need to be changed to
`DEFAULT_MIN_RELAY_TX_FEE/COIN` (divided by `COIN` to convert from sats/kvB to
BTC/kvB):
```diff
diff --git a/test/functional/p2p_1p1c_network.py b/test/functional/p2p_1p1c_network.py
index 4d0f11ea99bda..e4d3b738c1920 100755
--- a/test/functional/p2p_1p1c_network.py
+++ b/test/functional/p2p_1p1c_network.py
@@ -13,9 +13,11 @@
 from math import ceil
 
 from test_framework.mempool_util import (
+    DEFAULT_MIN_RELAY_TX_FEE,
     fill_mempool,
 )
 from test_framework.messages import (
+    COIN,
     msg_tx,
 )
 from test_framework.p2p import (
@@ -31,9 +33,6 @@
     MiniWalletMode,
 )
 
-# 1sat/vB feerate denominated in BTC/KvB
-FEERATE_1SAT_VB = Decimal("0.00001000")
-
 class PackageRelayTest(BitcoinTestFramework):
     def set_test_params(self):
         self.setup_clean_chain = True
@@ -49,12 +48,12 @@ def raise_network_minfee(self):
 
         self.log.debug("Check that all nodes' mempool minimum feerates are above min relay feerate")
         for node in self.nodes:
-            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)
-            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)
+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal(DEFAULT_MIN_RELAY_TX_FEE) / COIN)
+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], Decimal(DEFAULT_MIN_RELAY_TX_FEE) / COIN)
 
     def create_basic_1p1c(self, wallet):
-        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)
-        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent["new_utxo"], fee_rate=999*FEERATE_1SAT_VB)
+        low_fee_parent = wallet.create_self_transfer(fee_rate=Decimal(DEFAULT_MIN_RELAY_TX_FEE) / COIN, confirmed_only=True)
+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent["new_utxo"], fee_rate=999*Decimal(DEFAULT_MIN_RELAY_TX_FEE)/ COIN)
         package_hex_basic = [low_fee_parent["hex"], high_fee_child["hex"]]
         return package_hex_basic, low_fee_parent["tx"], high_fee_child["tx"]
 
@@ -85,8 +84,8 @@ def create_package_2outs(self, wallet):
         return [low_fee_parent_2outs["hex"], high_fee_child_2outs["hex"]], low_fee_parent_2outs["tx"], high_fee_child_2outs["tx"]
 
     def create_package_2p1c(self, wallet):
-        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)
-        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)
+        parent1 = wallet.create_self_transfer(fee_rate=Decimal(DEFAULT_MIN_RELAY_TX_FEE) / COIN * 10, confirmed_only=True)
+        parent2 = wallet.create_self_transfer(fee_rate=Decimal(DEFAULT_MIN_RELAY_TX_FEE) / COIN * 20, confirmed_only=True)
         child = wallet.create_self_transfer_multi(
             utxos_to_spend=[parent1["new_utxo"], parent2["new_utxo"]],
             fee_per_output=999*parent1["tx"].get_vsize(),
diff --git a/test/functional/p2p_opportunistic_1p1c.py b/test/functional/p2p_opportunistic_1p1c.py
index ad42b7308ba62..590d84999e5cc 100755
--- a/test/functional/p2p_opportunistic_1p1c.py
+++ b/test/functional/p2p_opportunistic_1p1c.py
@@ -13,10 +13,12 @@
 from test_framework.blocktools import MAX_STANDARD_TX_WEIGHT
 from test_framework.mempool_util import (
     create_large_orphan,
+    DEFAULT_MIN_RELAY_TX_FEE,
     fill_mempool,
 )
 from test_framework.messages import (
     CInv,
+    COIN,
     COutPoint,
     CTransaction,
     CTxIn,
@@ -79,13 +81,13 @@ def set_test_params(self):
         ]]
 
     def create_tx_below_mempoolminfee(self, wallet, utxo_to_spend=None):
-        """Create a 1-input 1sat/vB transaction using a confirmed UTXO. Decrement and use
+        """Create a 1-input 0.1sat/vB transaction using a confirmed UTXO. Decrement and use
         self.sequence so that subsequent calls to this function result in unique transactions."""
 
         self.sequence -= 1
-        assert_greater_than(self.nodes[0].getmempoolinfo()["mempoolminfee"], FEERATE_1SAT_VB)
+        assert_greater_than(self.nodes[0].getmempoolinfo()["mempoolminfee"], Decimal(DEFAULT_MIN_RELAY_TX_FEE) / COIN)
 
-        return wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, sequence=self.sequence, utxo_to_spend=utxo_to_spend, confirmed_only=True)
+        return wallet.create_self_transfer(fee_rate=Decimal(DEFAULT_MIN_RELAY_TX_FEE) / COIN, sequence=self.sequence, utxo_to_spend=utxo_to_spend, confirmed_only=True)
 
     @cleanup
     def test_basic_child_then_parent(self):
```

There were some more changes that I didn't take the time to fully understand,
but decided that I got enough of an idea of what was going on to decide that
they weren't necessary to look at more carefully:
 
```diff
diff --git a/test/functional/mempool_limit.py b/test/functional/mempool_limit.py
index 2a127007a4180..72696062457ef 100755
--- a/test/functional/mempool_limit.py
+++ b/test/functional/mempool_limit.py
@@ -206,7 +206,7 @@ def test_mid_package_replacement(self):
         # coin is no longer available, but the cache could still contain the tx.
         cpfp_parent = self.wallet.create_self_transfer(
             utxo_to_spend=replaced_tx["new_utxo"],
-            fee_rate=mempoolmin_feerate - Decimal('0.00001'),
+            fee_rate=mempoolmin_feerate - Decimal('0.000001'),
             confirmed_only=True)
 
         self.wallet.rescan_utxos()
@@ -312,9 +312,9 @@ def run_test(self):
         target_vsize_each = 50000
         assert_greater_than(target_vsize_each * 2 * 3, node.getmempoolinfo()["maxmempool"] - node.getmempoolinfo()["bytes"])
         # Should be a true CPFP: parent's feerate is just below mempool min feerate
-        parent_feerate = mempoolmin_feerate - Decimal("0.000001")  # 0.1 sats/vbyte below min feerate
+        parent_feerate = mempoolmin_feerate - Decimal("0.0000001")  # 0.01 sats/vbyte below min feerate
         # Parent + child is above mempool minimum feerate
-        child_feerate = (worst_feerate_btcvb * 1000) - Decimal("0.000001")  # 0.1 sats/vbyte below worst feerate
+        child_feerate = (worst_feerate_btcvb * 1000) - Decimal("0.0000001")  # 0.01 sats/vbyte below worst feerate
         # However, when eviction is triggered, these transactions should be at the bottom.
         # This assertion assumes parent and child are the same size.
         miniwallet.rescan_utxos()
diff --git a/test/functional/mempool_package_rbf.py b/test/functional/mempool_package_rbf.py
index ca56bdf8c5f44..54f3a90c0ac61 100755
--- a/test/functional/mempool_package_rbf.py
+++ b/test/functional/mempool_package_rbf.py
@@ -162,13 +162,13 @@ def test_package_rbf_additional_fees(self):
         self.log.info("Check replacement pays for incremental bandwidth")
         _, placeholder_txns3 = self.create_simple_package(coin)
         package_3_size = sum([tx.get_vsize() for tx in placeholder_txns3])
-        incremental_sats_required = Decimal(package_3_size) / COIN
-        incremental_sats_short = incremental_sats_required - Decimal("0.00000001")
+        incremental_sats_required = (Decimal(package_3_size * 0.1) / COIN).quantize(Decimal("0.00000001"))
+        incremental_sats_short = incremental_sats_required - Decimal("0.00000005")
         # Recreate the package with slightly higher fee once we know the size of the new package, but still short of required fee
         failure_package_hex3, failure_package_txns3 = self.create_simple_package(coin, parent_fee=DEFAULT_FEE, child_fee=DEFAULT_CHILD_FEE + incremental_sats_short)
         assert_equal(package_3_size, sum([tx.get_vsize() for tx in failure_package_txns3]))
         pkg_results3 = node.submitpackage(failure_package_hex3)
-        assert_equal(f"package RBF failed: insufficient anti-DoS fees, rejecting replacement {failure_package_txns3[1].txid_hex}, not enough additional fees to relay; {incremental_sats_short} < {incremental_sats_required}", pkg_results3["package_msg"])
+        assert_equal(f"package RBF failed: insufficient anti-DoS fees, rejecting replacement {failure_package_txns3[1].txid_hex}, not enough additional fees to relay; {incremental_sats_short:8f} < {incremental_sats_required:8f}", pkg_results3["package_msg"])
         self.assert_mempool_contents(expected=package_txns1)
 
         success_package_hex3, success_package_txns3 = self.create_simple_package(coin, parent_fee=DEFAULT_FEE, child_fee=DEFAULT_CHILD_FEE + incremental_sats_required)
@@ -562,12 +562,13 @@ def test_child_conflicts_parent_mempool_ancestor(self):
         )
 
         node.sendrawtransaction(grandparent_result["hex"])
+        minrelayfeerate = node.getnetworkinfo()["relayfee"]
 
         # Now make package of two descendants that looks
         # like a cpfp where the parent can't get in on its own
         self.ctr += 1
         parent_result = self.wallet.create_self_transfer(
-            fee_rate=Decimal('0.00001000'),
+            fee_rate=minrelayfeerate,
             utxo_to_spend=grandparent_result["new_utxo"],
             sequence=MAX_BIP125_RBF_SEQUENCE - self.ctr,
         )
```

</details>

### [[doc] release note for min feerate changes](https://github.com/bitcoin/bitcoin/pull/33106/commits/18720bc5d5b4d3acf91060859180d72cbfdf59b7)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/doc/release-notes-33106.md b/doc/release-notes-33106.md
new file mode 100644
index 0000000000000..95750cedff99e
--- /dev/null
+++ b/doc/release-notes-33106.md
@@ -0,0 +1,17 @@
+Mining and Transaction Relay Policy
+=========================
+
+The minimum block feerate (`-blockmintxfee`) has been changed to 1 satoshi per kvB. It can still be changed using the
+configuration option.
+
+The default minimum relay feerate (`-minrelaytxfee`) and incremental relay feerate (`-incrementalrelayfee`) have been
+changed to 100 satoshis per kvB. They can still be changed using their respective configuration options, but it is
+recommended to change both together if you decide to do so.
+
+Other minimum feerates (e.g. the dust feerate, the minimum returned by the fee estimator, and all feerates used by the
+wallet) remain unchanged. The mempool minimum feerate still changes in response to high volume but more gradually, as a
+result of the change to the incremental relay feerate.
+
+Note that unless these lower defaults are widely adopted across the network, transactions created with lower fee rates
+are not guaranteed to propagate or confirm. The wallet feerates remain unchanged; `-mintxfee` must be changed before
+attempting to create transactions with lower feerates using the wallet.
```
</details>

### [[doc] update mempool-replacements.md for incremental relay feerate change](https://github.com/bitcoin/bitcoin/pull/33106/commits/ba84a25deec0b3b9b94ee51b373e715fec995791)


<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/doc/policy/mempool-replacements.md b/doc/policy/mempool-replacements.md
index eb370672e40e0..73682e2ffb3d2 100644
--- a/doc/policy/mempool-replacements.md
+++ b/doc/policy/mempool-replacements.md
@@ -32,8 +32,8 @@ other consensus and policy rules, each of the following conditions are met:
 4. The additional fees (difference between absolute fee paid by the replacement transaction and the
    sum paid by the original transactions) pays for the replacement transaction's bandwidth at or
    above the rate set by the node's incremental relay feerate. For example, if the incremental relay
-   feerate is 1 satoshi/vB and the replacement transaction is 500 virtual bytes total, then the
-   replacement pays a fee at least 500 satoshis higher than the sum of the original transactions.
+   feerate is 0.1 satoshi/vB and the replacement transaction is 500 virtual bytes total, then the
+   replacement pays a fee at least 50 satoshis higher than the sum of the original transactions.
 
    *Rationale*: Try to prevent DoS attacks where an attacker causes the network to repeatedly relay
    transactions each paying a tiny additional amount in fees, e.g. just 1 satoshi.
@@ -77,3 +77,5 @@ This set of rules is similar but distinct from BIP125.
 * Full replace-by-fee is the default policy as of **v28.0** ([PR #30493](https://github.com/bitcoin/bitcoin/pull/30493)).
 
 * Signaling for replace-by-fee is no longer required as of [PR 30592](https://github.com/bitcoin/bitcoin/pull/30592).
+
+* The incremental relay feerate default is 0.1sat/vB ([PR #33106](https://github.com/bitcoin/bitcoin/pull/33106)).
```
</details>

