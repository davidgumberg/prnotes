# [#34299](https://github.com/bitcoin/bitcoin/pull/34299) wallet: re-activate "AmountWithFeeExceedsBalance" error
_All code comments in `[]` are my own._
## Background


## Problem

## Solution

### [wallet: fix, make 'total_effective_amount' optional actually optional](https://github.com/bitcoin/bitcoin/pull/34299/commits/c467325aaf187d7f056bb1ea1cec6b7c4250af2e)

	this is not needed for the remaining commits but good to fix
	and came up in #25269 review.


Originally from https://github.com/bitcoin/bitcoin/commit/568753018c5ffcddf4612464cd53502fa559f6fa
with description: 

"wallet: fix, make 'total_effective_amount' optional actually optional"

```diff
[
diff --git a/src/wallet/spend.h b/src/wallet/spend.h
index bdbfd75095..5e2b7f24c4 100644
--- a/src/wallet/spend.h
+++ b/src/wallet/spend.h
@@ -59,13 +59,13 @@ struct CoinsResult {
     void Add(OutputType type, const COutput& out);

     CAmount GetTotalAmount() { return total_amount; }
-    std::optional<CAmount> GetEffectiveTotalAmount() {return total_effective_amount; }
+    std::optional<CAmount> GetEffectiveTotalAmount() { return total_effective_amount; }

 private:
     /** Sum of all available coins raw value */
     CAmount total_amount{0};
     /** Sum of all available coins effective value (each output value minus fees required to spend it) */
-    std::optional<CAmount> total_effective_amount{0};
+    std::optional<CAmount> total_effective_amount;
 };
```
[`struct CoinsResult`][struct-coinsresult] is used during coin selection to
represent the coins available for spending.

`CoinsResult` is the type of the value returned by
[`AvailableCoins()`][availablecoins], which is passed to
[`SelectCoins()`][selectcoins] and
[`AutomaticCoinSelection()`][automaticcoinselection].

[`CoinsResult`][struct-coinsresult] is a wrapper with convenience functions for
the following map from `OutputType` to vector of `COutputs`:

```cpp
struct CoinsResult {
    std::map<OutputType, std::vector<COutput>> coins;
    // [...]
}
```

It also tracks the `total_amount` and `total_effective_amount` of the `COutput`'s that it holds:

```cpp
struct CoinsResult {
    // [...]
    CAmount GetTotalAmount() { return total_amount; }
    std::optional<CAmount> GetEffectiveTotalAmount() {return total_effective_amount; }
private:
    /** Sum of all available coins raw value */
    CAmount total_amount{0};
    /** Sum of all available coins effective value (each output value minus fees required to spend it) */
    std::optional<CAmount> total_effective_amount{0};
};
```

(https://github.com/bitcoin/bitcoin/blob/7b48b09b7f77f6afdb52f9749bb03d4a47c96e78/src/wallet/spend.h#L61-L69)

where effective amount (`effective_value`) of a `COutput` is... ü•Å

```cpp
/** A UTXO under consideration for use in funding a new transaction. */
struct COutput {
private:
    /** The output's value minus fees required to spend it and bump its unconfirmed ancestors to the target feerate. */
    std::optional<CAmount> effective_value;
    // [...]
}
```
(https://github.com/bitcoin/bitcoin/blob/7b48b09b7f77f6afdb52f9749bb03d4a47c96e78/src/wallet/coinselection.h#L27-L32)

Why is `COutput`'s `effective_value` optional?

Ask [#25083](https://github.com/bitcoin/bitcoin/pull/25083)!




<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/wallet/spend.cpp b/src/wallet/spend.cpp
index c7c41f5d0f12..1e0ac8f04282 100644
--- a/src/wallet/spend.cpp
+++ b/src/wallet/spend.cpp
@@ -223,7 +223,7 @@ void CoinsResult::Erase(const std::unordered_set<COutPoint, SaltedOutpointHasher
 
             // update cached amounts
             total_amount -= coin.txout.nValue;
-            if (coin.HasEffectiveValue()) total_effective_amount = *total_effective_amount - coin.GetEffectiveValue();
+            if (coin.HasEffectiveValue() && total_effective_amount.has_value()) total_effective_amount = *total_effective_amount - coin.GetEffectiveValue();
             return true;
         });
         vec.erase(remove_it, vec.end());
diff --git a/src/wallet/spend.h b/src/wallet/spend.h
index a22499f3cd66..5a1a879a281a 100644
--- a/src/wallet/spend.h
+++ b/src/wallet/spend.h
@@ -59,13 +59,13 @@ struct CoinsResult {
     void Add(OutputType type, const COutput& out);
 
     CAmount GetTotalAmount() { return total_amount; }
-    std::optional<CAmount> GetEffectiveTotalAmount() {return total_effective_amount; }
+    std::optional<CAmount> GetEffectiveTotalAmount() { return total_effective_amount; }
 
 private:
     /** Sum of all available coins raw value */
     CAmount total_amount{0};
     /** Sum of all available coins effective value (each output value minus fees required to spend it) */
-    std::optional<CAmount> total_effective_amount{0};
+    std::optional<CAmount> total_effective_amount;
 };
 
 struct CoinFilterParams {
```
</details>

### [wallet: clarify PreSelectedInputs total_amount](https://github.com/bitcoin/bitcoin/pull/34299/commits/af3f3bfd57bf8869030153ecf3695f07ae7dd805)

	using total_amount variable to store either the actual total
	amount or effective total amount based on whether SFFO is enabled
	is confusing. keep this SFFO-based functionality in a separate
	function GetTotal() and store both total_amount and effective
	total amount separately.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/wallet/interfaces.cpp b/src/wallet/interfaces.cpp
index 28c4d639323a..6e6d8cd7f5e1 100644
--- a/src/wallet/interfaces.cpp
+++ b/src/wallet/interfaces.cpp
@@ -411,7 +411,7 @@ class WalletImpl : public Wallet
             CoinSelectionParams params(rng);
             // Note: for now, swallow any error.
             if (auto res = FetchSelectedInputs(*m_wallet, coin_control, params)) {
-                total_amount += res->total_amount;
+                total_amount += res->GetTotal(params.m_subtract_fee_outputs);
             }
         }
 
diff --git a/src/wallet/spend.cpp b/src/wallet/spend.cpp
index 1e0ac8f04282..17e07ac10c56 100644
--- a/src/wallet/spend.cpp
+++ b/src/wallet/spend.cpp
@@ -312,7 +312,7 @@ util::Result<PreSelectedInputs> FetchSelectedInputs(const CWallet& wallet, const
         /* Set some defaults for depth, solvable, safe, time, and from_me as these don't matter for preset inputs since no selection is being done. */
         COutput output(outpoint, txout, /*depth=*/0, input_bytes, /*solvable=*/true, /*safe=*/true, /*time=*/0, /*from_me=*/false, coin_selection_params.m_effective_feerate);
         output.ApplyBumpFee(map_of_bump_fees.at(output.outpoint));
-        result.Insert(output, coin_selection_params.m_subtract_fee_outputs);
+        result.Insert(output);
     }
     return result;
 }
@@ -817,7 +817,7 @@ util::Result<SelectionResult> SelectCoins(const CWallet& wallet, CoinsResult& av
                                           const CoinSelectionParams& coin_selection_params)
 {
     // Deduct preset inputs amount from the search target
-    CAmount selection_target = nTargetValue - pre_set_inputs.total_amount;
+    CAmount selection_target = nTargetValue - pre_set_inputs.GetTotal(coin_selection_params.m_subtract_fee_outputs);
 
     // Return if automatic coin selection is disabled, and we don't cover the selection target
     if (!coin_control.m_allow_other_inputs && selection_target > 0) {
@@ -847,7 +847,7 @@ util::Result<SelectionResult> SelectCoins(const CWallet& wallet, CoinsResult& av
 
     // If needed, add preset inputs to the automatic coin selection result
     if (!pre_set_inputs.coins.empty()) {
-        SelectionResult preselected(pre_set_inputs.total_amount, SelectionAlgorithm::MANUAL);
+        SelectionResult preselected(pre_set_inputs.GetTotal(coin_selection_params.m_subtract_fee_outputs), SelectionAlgorithm::MANUAL);
         preselected.AddInputs(pre_set_inputs.coins, coin_selection_params.m_subtract_fee_outputs);
         op_selection_result->Merge(preselected);
         op_selection_result->RecalculateWaste(coin_selection_params.min_viable_change,
diff --git a/src/wallet/spend.h b/src/wallet/spend.h
index 5a1a879a281a..0aed761d95fb 100644
--- a/src/wallet/spend.h
+++ b/src/wallet/spend.h
@@ -156,20 +156,20 @@ util::Result<SelectionResult> ChooseSelectionResult(interfaces::Chain& chain, co
 struct PreSelectedInputs
 {
     std::set<std::shared_ptr<COutput>> coins;
-    // If subtract fee from outputs is disabled, the 'total_amount'
-    // will be the sum of each output effective value
-    // instead of the sum of the outputs amount
     CAmount total_amount{0};
+    CAmount total_effective_amount{0};
 
-    void Insert(const COutput& output, bool subtract_fee_outputs)
+    void Insert(const COutput& output)
     {
-        if (subtract_fee_outputs) {
-            total_amount += output.txout.nValue;
-        } else {
-            total_amount += output.GetEffectiveValue();
-        }
+        total_amount += output.txout.nValue;
+        total_effective_amount += output.GetEffectiveValue();
         coins.insert(std::make_shared<COutput>(output));
     }
+
+    // Returns the appropriate total based on whether fees are being subtracted from outputs
+    CAmount GetTotal(bool subtract_fee_outputs) const {
+        return subtract_fee_outputs ? total_amount : total_effective_amount;
+    }
 };
 
 /**
diff --git a/src/wallet/test/coinselector_tests.cpp b/src/wallet/test/coinselector_tests.cpp
index 5c047bad02ab..3aea21963b7a 100644
--- a/src/wallet/test/coinselector_tests.cpp
+++ b/src/wallet/test/coinselector_tests.cpp
@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)
         COutput select_coin = available_coins.All().at(0);
         coin_control.Select(select_coin.outpoint);
         PreSelectedInputs selected_input;
-        selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);
+        selected_input.Insert(select_coin);
         available_coins.Erase({available_coins.coins[OutputType::BECH32].begin()->outpoint});
 
         LOCK(wallet->cs_wallet);
@@ -256,7 +256,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)
         COutput select_coin = available_coins.All().at(1); // pre select 9 coin
         coin_control.Select(select_coin.outpoint);
         PreSelectedInputs selected_input;
-        selected_input.Insert(select_coin, coin_selection_params_bnb.m_subtract_fee_outputs);
+        selected_input.Insert(select_coin);
         available_coins.Erase({(++available_coins.coins[OutputType::BECH32].begin())->outpoint});
         const auto result13 = SelectCoins(*wallet, available_coins, selected_input, 10 * CENT, coin_control, coin_selection_params_bnb);
         BOOST_CHECK(EquivalentResult(expected_result, *result13));
```
</details>

### [wallet: introduce "tx amount exceeds balance when fees are included" error](https://github.com/bitcoin/bitcoin/pull/34299/commits/f66d5bc0990cc4f82c40aea3e13232fb6b883d31)

	This was previously implemented at the GUI level but we never hit that
	code path.

<details>

<summary>

Commit diff

</summary>

```diff
diff --git a/src/wallet/spend.cpp b/src/wallet/spend.cpp
index 17e07ac10c56..ad3f303000db 100644
--- a/src/wallet/spend.cpp
+++ b/src/wallet/spend.cpp
@@ -1202,7 +1202,22 @@ static util::Result<CreatedTransactionResult> CreateTransactionInternal(
     if (!select_coins_res) {
         // 'SelectCoins' either returns a specific error message or, if empty, means a general "Insufficient funds".
         const bilingual_str& err = util::ErrorString(select_coins_res);
-        return util::Error{err.empty() ?_("Insufficient funds") : err};
+        if (!err.empty()) return util::Error{err};
+
+        // Check if we have enough balance but cannot cover the fees
+        CAmount available_balance = preset_inputs.total_amount + available_coins.GetTotalAmount();
+        // Note: if SelectCoins() fails when SFFO is enabled (recipients_sum = selection_target with SFFO),
+        // then recipients_sum > available_balance and we wouldn't enter into the if condition below.
+        if (available_balance >= recipients_sum) {
+            CAmount available_effective_balance = preset_inputs.total_effective_amount + available_coins.GetEffectiveTotalAmount().value_or(0);
+            if (available_effective_balance < selection_target) {
+                Assume(!coin_selection_params.m_subtract_fee_outputs);
+                return util::Error{strprintf(_("The total exceeds your balance when the %s transaction fee is included."), FormatMoney(selection_target - recipients_sum))};
+            }
+        }
+
+        // General failure description
+        return util::Error{_("Insufficient funds")};
     }
     const SelectionResult& result = *select_coins_res;
     TRACEPOINT(coin_selection, selected_coins,
diff --git a/test/functional/wallet_bumpfee.py b/test/functional/wallet_bumpfee.py
index 044ddc968b8b..1a30f0c3cde7 100755
--- a/test/functional/wallet_bumpfee.py
+++ b/test/functional/wallet_bumpfee.py
@@ -801,7 +801,7 @@ def test_no_more_inputs_fails(self, rbf_node, dest_address):
     self.generatetoaddress(rbf_node, 1, dest_address)
     # spend all funds, no change output
     rbfid = rbf_node.sendall(recipients=[rbf_node.getnewaddress()])['txid']
-    assert_raises_rpc_error(-4, "Unable to create transaction. Insufficient funds", rbf_node.bumpfee, rbfid)
+    assert_raises_rpc_error(-4, "Unable to create transaction. The total exceeds your balance when the 0.00001051 transaction fee is included.", rbf_node.bumpfee, rbfid)
     self.clear_mempool()
 
 
diff --git a/test/functional/wallet_fundrawtransaction.py b/test/functional/wallet_fundrawtransaction.py
index 3577a2f4177c..783267badf95 100755
--- a/test/functional/wallet_fundrawtransaction.py
+++ b/test/functional/wallet_fundrawtransaction.py
@@ -155,6 +155,7 @@ def run_test(self):
         self.test_input_confs_control()
         self.test_duplicate_outputs()
         self.test_watchonly_cannot_grind_r()
+        self.test_cannot_cover_fees()
 
     def test_duplicate_outputs(self):
         self.log.info("Test deserializing and funding a transaction with duplicate outputs")
@@ -1456,7 +1457,8 @@ def test_feerate_rounding(self):
         # To test this does not happen, we subtract 202 sats from the input value. If working correctly, this should
         # fail with insufficient funds rather than bitcoind asserting.
         rawtx = w.createrawtransaction(inputs=[], outputs=[{self.nodes[0].getnewaddress(address_type="bech32"): 1 - 0.00000202}])
-        assert_raises_rpc_error(-4, "Insufficient funds", w.fundrawtransaction, rawtx, fee_rate=1.85)
+        expected_err_msg = "The total exceeds your balance when the 0.00000078 transaction fee is included."
+        assert_raises_rpc_error(-4, expected_err_msg, w.fundrawtransaction, rawtx, fee_rate=1.85)
 
     def test_input_confs_control(self):
         self.nodes[0].createwallet("minconf")
@@ -1542,5 +1544,41 @@ def test_watchonly_cannot_grind_r(self):
         watchonly_funded = watchonly.fundrawtransaction(hexstring=tx, fee_rate=10)
         assert_greater_than(watchonly_funded["fee"], funded["fee"])
 
+    def test_cannot_cover_fees(self):
+        self.log.info("Test error message when transaction amount exceeds available balance when fees are included")
+        default_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)
+
+        self.nodes[1].createwallet("cannot_cover_fees")
+        wallet = self.nodes[1].get_wallet_rpc("cannot_cover_fees")
+
+        # Set up wallet with 2 utxos: 0.3 BTC and 0.15 BTC
+        default_wallet.sendtoaddress(wallet.getnewaddress(), 0.3)
+        txid2 = default_wallet.sendtoaddress(wallet.getnewaddress(), 0.15)
+        self.generate(self.nodes[0], 1)
+        utxos = wallet.listunspent(1)
+        vout2 = next((u["vout"] for u in utxos if u["txid"] == txid2), 0)
+
+        amount_with_fee_err_msg = "The total exceeds your balance when the {} transaction fee is included."
+
+        self.log.info("Test without preselected inputs")
+        self.log.info("Attempt to send 0.45 BTC without SFFO")
+        rawtx = wallet.createrawtransaction(inputs=[], outputs=[{default_wallet.getnewaddress(): 0.45}])
+        assert_raises_rpc_error(-4, amount_with_fee_err_msg.format("0.00000042"), wallet.fundrawtransaction, rawtx, options={"fee_rate":1})
+
+        self.log.info("Send 0.45 BTC with SFFO")
+        wallet.fundrawtransaction(rawtx, options={"subtractFeeFromOutputs":[0]})
+
+        self.log.info("Attempt to send 0.45 BTC by restricting coin selection with minconf=6")
+        assert_raises_rpc_error(-4, "Insufficient funds", wallet.fundrawtransaction, rawtx, options={"minconf":6})
+
+        self.log.info("Test with preselected inputs")
+        self.log.info("Attempt to send 0.45 BTC preselecting 0.15 BTC utxo")
+        rawtx = wallet.createrawtransaction(inputs=[{"txid": txid2, "vout": vout2}], outputs=[{default_wallet.getnewaddress(): 0.45}])
+        assert_raises_rpc_error(-4, amount_with_fee_err_msg.format("0.00000042"), wallet.fundrawtransaction, rawtx, options={"fee_rate":1})
+
+        self.log.info("Send 0.45 BTC preselecting 0.15 BTC utxo with SFFO")
+        wallet.fundrawtransaction(hexstring=rawtx, options={"subtractFeeFromOutputs":[0]})
+
+
 if __name__ == '__main__':
     RawTransactionsTest(__file__).main()
```
</details>




[struct-coinsresult]: https://github.com/bitcoin/bitcoin/blob/7b48b09b7f77f6afdb52f9749bb03d4a47c96e78/src/wallet/spend.h#L45

[availablecoins]: https://github.com/bitcoin/bitcoin/blob/7b48b09b7f77f6afdb52f9749bb03d4a47c96e78/src/wallet/spend.cpp#L320

[selectcoins]: https://github.com/bitcoin/bitcoin/blob/7b48b09b7f77f6afdb52f9749bb03d4a47c96e78/src/wallet/spend.cpp#L814

[automaticcoinselection]: https://github.com/bitcoin/bitcoin/blob/7b48b09b7f77f6afdb52f9749bb03d4a47c96e78/src/wallet/spend.cpp#L866
