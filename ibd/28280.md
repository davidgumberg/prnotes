# [#28280](https://github.com/bitcoin/bitcoin/pull/28280) Don't empty dbcache on prune flushes: >30% faster IBD

## [refactor: encapsulate flags access for dirty and fresh checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/0383defd049fa1feb6de7abea259041487ccda1d)

This commit refactors the checks for whether or not a `CCoinsCacheEntry` is fresh and dirty into methods `entry.IsDirty()` and `entry.IsFresh()`. This is in preparation for a future commit that makes the `flags` attribute of a coins cache entry private.

From `src/coins.h`:
```cpp
struct CCoinsCacheEntry
{
    /* ... */
    inline bool IsDirty() const noexcept { return flags & DIRTY; }
    inline bool IsFresh() const noexcept { return flags & FRESH; }
    /* ... */
};
```

and elsewhere:

```diff
 for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {
-    if (it->second.flags & CCoinsCacheEntry::DIRTY) {
+    if (it->second.IsDirty()) {
```

## [refactor: encapsulate flags get access for all other checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/fc3501d14c27a0103650d6054c4027274b18ed4f)

This refactor commit adds a getter method `GetFlags()`:

```cpp
inline unsigned char GetFlags() const noexcept { return flags; }
```

In preparation for making `flags` a private attribute.

## [refactor: encapsulate flags setting with AddFlags and ClearFlags](https://github.com/bitcoin/bitcoin/pull/28280/commits/5907ace1e6cf1c415eeff1467a348468a8a967b0)

This refactor commit adds an `AddFlags()` and a `ClearFlags()` method to enable
making the `flags` attribute of `CCoinsCacheEntry` private.

```cpp
inline void AddFlags(unsigned char flags) noexcept { this->flags |= flags; }
inline void ClearFlags() noexcept
{
    flags = 0;
}
```

A few comments were made about a change in behavior where settings flags equal
to something has been changed to adding flags, e.g.:

```diff
-entry.flags = CCoinsCacheEntry::Dirty
+entry.AddFlags(CCoinsCacheEntry::Dirty)
```

The author and another reviewer suggested that in all instances where a
flag-setting becomes a flag-adding the entry is freshly constructed and there
is no change in behavior, let's take a look:

```cpp
CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {
    // [...]
    // [ At this point we did not have the `Coin` in our cache, so we fell
    //   back on the CCoinsViewDB and found it and stored it in `Coin tmp`. ]

    // [ We are emplacing the coin into our cache... ]
    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;
    if (ret->second.coin.IsSpent()) {
        // The parent only has an empty entry for this outpoint; we can consider our
        // version as fresh.
        ret->second.AddFlags(CCoinsCacheEntry::FRESH);
        // [ used to be: ret->second.flags = CCoinsCacheEntry::FRESH);
        //   Since the CCoinsCacheEntry was constructed in place as part of the
        //   emplace and piecewise_construct above, we know that its flags are
        //   clear and adding flags == setting flags. ]
    }
    // [...]
}
```

Some background for the next example: when a CCoinsViewCache::Flush() happens,
the backing view of the cache (`view.base`) gets called upon to perform a
`BatchWrite`.

The only time when a `CCoinsViewCache` is the backing view of another
`CCoinsView` is:

Whenever `ChainState::ConnectTip` happens, we create a temporary
`CCoinsViewCache` with the canonical chaintip `CCoinsViewCache` as its parent,
we connect the new block to the temporary Coin View, and then
`CCoinsViewCache::Flush()` it, which calls the parent cache's
`CCoinsViewCache::BatchWrite`.

```cpp
bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn, bool erase) {
    // [ mapCoins is the child's CCoinMap, these are the coins that are getting
    //   flushed to the parent. CCoinsMap consists of {COutpoint,
    //   CCoinsCacheEntry} ] 
    for (CCoinsMap::iterator it = mapCoins.begin();
            it != mapCoins.end();
            it = erase ? mapCoins.erase(it) : std::next(it)) {
        CCoinsMap::iterator itUs = cacheCoins.find(it->first);
        // [ If the parent cache (us) does not have the entry that is being
        //   flushed... ]
        if (itUs == cacheCoins.end()) {
            // The parent cache does not have an entry, while the child cache does.
            // We can ignore it if it's both spent and FRESH in the child
            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {
                // Create the coin in the parent cache, move the data up
                // and mark it as dirty.
                CCoinsCacheEntry& entry = cacheCoins[it->first];
                // [ Since the cacheCoins.find above returned the end iterator,
                //   our view's CCoinsMap cacheCoins does not have the given
                //   COutPoint, the above subscript access inserts a default
                //   constructed value into the CCoinsMap, and a default
                //   constructed CCoinsCacheEntry has blank flags by default. ]

                // [...]
                entry.flags = CCoinsCacheEntry::DIRTY;
                // [ Since the CCoinsCacheEntry is freshly constructed, its
                //   flags are blank, and setting is equal to adding. ]

                // We can mark it FRESH in the parent if it was FRESH in the child
                // Otherwise it might have just been flushed from the parent's cache
                // and already exist in the grandparent
                if (it->second.flags & CCoinsCacheEntry::FRESH) {
                    entry.flags |= CCoinsCacheEntry::FRESH;
                }
            }
        }
        // [...]
    }
    // [...]
}
```

Looks good to me!

## [refactor: disallow setting flags in CCoinsCacheEntry constructors](https://github.com/bitcoin/bitcoin/pull/28280/commits/5b18c53b5ae5215bdd1e960a65e45f740ce14129)

This commit "disallow[s] setting flags in CCoinsCacheEntry constructors." It
also moves default initialization of flags to the member instead of the
`CCoinsCacheEntry`'s constructor.

`src/coins.h`
```diff
 struct CCoinsCacheEntry
 {
     Coin coin; // The actual cached data.
-    unsigned char flags;
+    unsigned char flags{0};

-    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}
-    CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}
+    CCoinsCacheEntry() noexcept = default;
+    explicit CCoinsCacheEntry(Coin&& coin_) noexcept : coin(std::move(coin_)) {}
 }
```

The only place where flag initialization is used is in
`CCoinsViewCache::EmplaceCoinInternalDANGER()`, which is used to emplace coins
during `assumeutxo` snapshot loading:

```cpp
void CCoinsViewCache::EmplaceCoinInternalDANGER(COutPoint&& outpoint, Coin&& coin) {
    cachedCoinsUsage += coin.DynamicMemoryUsage();
    cacheCoins.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(std::move(outpoint)),
        std::forward_as_tuple(std::move(coin), CCoinsCacheEntry::DIRTY)); // [ <-- The line in question ]
}
```

This commit changes this to:

```cpp
void CCoinsViewCache::EmplaceCoinInternalDANGER(COutPoint&& outpoint, Coin&& coin) {
    cachedCoinsUsage += coin.DynamicMemoryUsage();
    // [ Capture the tuple returned by std::unordered_map::emplace with
    //   the iterator and a boolean indicating if the key was unique and
    //   insertion was succesful. [
    auto [it, inserted] = cacheCoins.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(std::move(outpoint)),
        std::forward_as_tuple(std::move(coin))); // [ <-- No longer construct the CoinsCacheEntry with a flag argument ]
        
    // [ This preserves the old behavior since if the entry was not emplaced,
    //   the flags were not modified. ]
    if (inserted) {
        it->second.AddFlags(CCoinsCacheEntry::DIRTY);
    }
}
```

ó°„¹

## [refactor: move flags to private uint8_t and rename to m_flags](https://github.com/bitcoin/bitcoin/pull/28280/commits/9da4e90c1d4bb10d981335e183bd0605daa8b523)

Makes flags private, `uint8_t` instead of `unsigned char` and renames `flags ->
m_flags`:

```diff
 struct CCoinsCacheEntry 
 {
+private:
+     uint8_t m_flags{0};
+
+public:
     Coin coin; // The actual cached data.
-    unsigned char flags{0};
 }
```

## [refactor: add CoinsCachePair alias](https://github.com/bitcoin/bitcoin/pull/28280/commits/a1444346464cff778f317d5d89eccfa0c9b8759e)

`src/coins.h`
```diff
+struct CCoinsCacheEntry;
+using CoinsCachePair = std::pair<const COutPoint, CCoinsCacheEntry>;
+
 /**
  * A Coin in one level of the coins database caching hierarchy.
  *
 @@ -155,8 +158,8 @@ using CCoinsMap = std::unordered_map<COutPoint,
                                      CCoinsCacheEntry,
                                      SaltedOutpointHasher,
                                      std::equal_to<COutPoint>,
-                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,
-                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4>>;
+                                     PoolAllocator<CoinsCachePair,
+                                                   sizeof(CoinsCachePair) + sizeof(void*) * 4>>;
```






