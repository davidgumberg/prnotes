# [#28280](https://github.com/bitcoin/bitcoin/pull/28280) Don't empty dbcache on prune flushes: >30% faster IBD

## [refactor: encapsulate flags access for dirty and fresh checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/0383defd049fa1feb6de7abea259041487ccda1d)

This commit refactors the checks for whether or not a `CCoinsCacheEntry` is fresh and dirty into methods `entry.IsDirty()` and `entry.IsFresh()`. This is in preparation for a future commit that makes the `flags` attribute of a coins cache entry private.

From `src/coins.h`:
```cpp
struct CCoinsCacheEntry
{
    /* ... */
    inline bool IsDirty() const noexcept { return flags & DIRTY; }
    inline bool IsFresh() const noexcept { return flags & FRESH; }
    /* ... */
};
```

and elsewhere:

```diff
 for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {
-    if (it->second.flags & CCoinsCacheEntry::DIRTY) {
+    if (it->second.IsDirty()) {
```

## [refactor: encapsulate flags get access for all other checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/fc3501d14c27a0103650d6054c4027274b18ed4f)

This refactor commit adds a getter method `GetFlags()`:

```cpp
inline unsigned char GetFlags() const noexcept { return flags; }
```

In preparation for making `flags` a private attribute.

## [refactor: encapsulate flags setting with AddFlags and ClearFlags](https://github.com/bitcoin/bitcoin/pull/28280/commits/5907ace1e6cf1c415eeff1467a348468a8a967b0)

This refactor commit adds an `AddFlags()` and a `ClearFlags()` method (and
refactors existing code to use these methods) to enable making the `flags`
attribute of `CCoinsCacheEntry` private in a later commit.

```cpp
inline void AddFlags(unsigned char flags) noexcept { this->flags |= flags; }
inline void ClearFlags() noexcept
{
    flags = 0;
}
```

It also replaces manual setting and adding of CCoinsCacheEntry flags with

Two reviewers asked about whether or not this commit might be a change in
behavior where we previously setting flags and are now adding flags, e.g.:

```diff
-entry.flags = CCoinsCacheEntry::Dirty
+entry.AddFlags(CCoinsCacheEntry::Dirty)
```

The author and another reviewer suggested that in all instances where a
flag-setting becomes a flag-adding the entry is freshly constructed and there
is no change in behavior, let's take a look:

```cpp
CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {
    // [...]
    // [ At this point we did not have the `Coin` in our cache, so we fell
    //   back on the CCoinsViewDB and found it and stored it in `Coin tmp`. ]

    // [ We are emplacing the coin into our cache... ]
    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;
    if (ret->second.coin.IsSpent()) {
        // The parent only has an empty entry for this outpoint; we can consider our
        // version as fresh.
        ret->second.AddFlags(CCoinsCacheEntry::FRESH);
        // [ used to be: ret->second.flags = CCoinsCacheEntry::FRESH);
        //   Since the CCoinsCacheEntry was constructed in place as part of the
        //   emplace and piecewise_construct above, we know that its flags are
        //   clear and adding flags == setting flags. ]
    }
    // [...]
}
```

Some background for the next example: when a CCoinsViewCache::Flush() happens,
the backing view of the cache (`view.base`) gets called upon to perform a
`BatchWrite`.

The only time when a `CCoinsViewCache` is the backing view of another
`CCoinsView` is:

Whenever `ChainState::ConnectTip` happens, we create a temporary
`CCoinsViewCache` with the canonical chaintip `CCoinsViewCache` as its parent,
we connect the new block to the temporary Coin View, and then
`CCoinsViewCache::Flush()` it, which calls the parent cache's
`CCoinsViewCache::BatchWrite`.

```cpp
bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn, bool erase) {
    // [ mapCoins is the child's CCoinMap, these are the coins that are getting
    //   flushed to the parent. CCoinsMap consists of {COutpoint,
    //   CCoinsCacheEntry} ] 
    for (CCoinsMap::iterator it = mapCoins.begin();
            it != mapCoins.end();
            it = erase ? mapCoins.erase(it) : std::next(it)) {
        CCoinsMap::iterator itUs = cacheCoins.find(it->first);
        // [ If the parent cache (us) does not have the entry that is being
        //   flushed... ]
        if (itUs == cacheCoins.end()) {
            // The parent cache does not have an entry, while the child cache does.
            // We can ignore it if it's both spent and FRESH in the child
            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {
                // Create the coin in the parent cache, move the data up
                // and mark it as dirty.
                CCoinsCacheEntry& entry = cacheCoins[it->first];
                // [ Since the cacheCoins.find above returned the end iterator,
                //   our view's CCoinsMap cacheCoins does not have the given
                //   COutPoint, the above subscript access inserts a default
                //   constructed value into the CCoinsMap, and a default
                //   constructed CCoinsCacheEntry has blank flags by default. ]

                // [...]
                entry.flags = CCoinsCacheEntry::DIRTY;
                // [ Since the CCoinsCacheEntry is freshly constructed, its
                //   flags are blank, and setting is equal to adding. ]

                // We can mark it FRESH in the parent if it was FRESH in the child
                // Otherwise it might have just been flushed from the parent's cache
                // and already exist in the grandparent
                if (it->second.flags & CCoinsCacheEntry::FRESH) {
                    entry.flags |= CCoinsCacheEntry::FRESH;
                }
            }
        }
        // [...]
    }
    // [...]
}
```

Looks good to me!

## [refactor: disallow setting flags in CCoinsCacheEntry constructors](https://github.com/bitcoin/bitcoin/pull/28280/commits/5b18c53b5ae5215bdd1e960a65e45f740ce14129)

This commit "disallow[s] setting flags in CCoinsCacheEntry constructors." It
also moves default initialization of flags to the member instead of the
`CCoinsCacheEntry`'s constructor.

`src/coins.h`:
```diff
 struct CCoinsCacheEntry
 {
     Coin coin; // The actual cached data.
-    unsigned char flags;
+    unsigned char flags{0};

-    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}
-    CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}
+    CCoinsCacheEntry() noexcept = default;
+    explicit CCoinsCacheEntry(Coin&& coin_) noexcept : coin(std::move(coin_)) {}
 }
```

The only place where flag initialization is used is in
`CCoinsViewCache::EmplaceCoinInternalDANGER()`, which is used to emplace coins
during `assumeutxo` snapshot loading:

```cpp
void CCoinsViewCache::EmplaceCoinInternalDANGER(COutPoint&& outpoint, Coin&& coin) {
    cachedCoinsUsage += coin.DynamicMemoryUsage();
    cacheCoins.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(std::move(outpoint)),
        std::forward_as_tuple(std::move(coin), CCoinsCacheEntry::DIRTY)); // [ <-- The line in question ]
}
```

This commit changes this to:

```cpp
void CCoinsViewCache::EmplaceCoinInternalDANGER(COutPoint&& outpoint, Coin&& coin) {
    cachedCoinsUsage += coin.DynamicMemoryUsage();
    // [ Capture the tuple returned by std::unordered_map::emplace with
    //   the iterator and a boolean indicating if the key was unique and
    //   insertion was succesful. ]
    auto [it, inserted] = cacheCoins.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(std::move(outpoint)),
        std::forward_as_tuple(std::move(coin))); // [ <-- No longer construct the CoinsCacheEntry with a flag argument ]
        
    // [ This preserves the old behavior since if the entry was not emplaced,
    //   the flags were not modified. ]
    if (inserted) {
        it->second.AddFlags(CCoinsCacheEntry::DIRTY);
    }
}
```

Û∞Ñπ

## [refactor: move flags to private uint8_t and rename to m_flags](https://github.com/bitcoin/bitcoin/pull/28280/commits/9da4e90c1d4bb10d981335e183bd0605daa8b523)

Makes flags private, `uint8_t` instead of `unsigned char` and renames `flags ->
m_flags`:

```diff
 struct CCoinsCacheEntry 
 {
+private:
+     uint8_t m_flags{0};
+
+public:
     Coin coin; // The actual cached data.
-    unsigned char flags{0};
 }
```

## [refactor: add CoinsCachePair alias](https://github.com/bitcoin/bitcoin/pull/28280/commits/a1444346464cff778f317d5d89eccfa0c9b8759e)

Refactor only, `CoinsCachePair` will probably come up in later commits..

`src/coins.h`
```diff
+struct CCoinsCacheEntry;
+using CoinsCachePair = std::pair<const COutPoint, CCoinsCacheEntry>;
+
 /**
  * A Coin in one level of the coins database caching hierarchy.
  *
 @@ -155,8 +158,8 @@ using CCoinsMap = std::unordered_map<COutPoint,
                                      CCoinsCacheEntry,
                                      SaltedOutpointHasher,
                                      std::equal_to<COutPoint>,
-                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,
-                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4>>;
+                                     PoolAllocator<CoinsCachePair,
+                                                   sizeof(CoinsCachePair) + sizeof(void*) * 4>>;
```

## [refactor: require self and sentinel parameters for AddFlags](https://github.com/bitcoin/bitcoin/pull/28280/commits/d53f9cd703ae326446b018e3225c577d221c1e6d)

Adds a parameter `CCoinsCache m_sentinel` to `CCoinsViewCache` that will be used
in a later commit to indicate the beginning entry of a new data structure that
consists of a doubly-linked list of CoinsCachePair's. This commit seems like
semantically it is not atomic, so let's reserve further investigation...

### Sentinels
A sentinel entry is a dummy entry that closes the loop of the doubly linked list
of flagged entries we're working towards, it's `m_prev` is the youngest entry,
and it's `m_next` is the oldest entry, and it should not contain any
information.`


```diff
 class CCoinsViewCache : public CCoinsViewBacked
 {
 private:
     const bool m_deterministic;

 protected:
     /**
     * Make mutable so that we can "fill the cache" even from Get-methods
     * declared as "const".
     */
     mutable uint256 hashBlock;
     mutable CCoinsMapMemoryResource m_cache_coins_memory_resource{};
+    /* The starting sentinel of the flagged entry circular doubly linked list. */
+    mutable CoinsCachePair m_sentinel;
     mutable CCoinMap cacheCoins;

     /* Cached dynamic memory usage for the inner Coin objects. */
     mutable size_t cachedCoinsUsage{0};

     // [...]
 }
```

    üåî Question: Why is `m_sentinal` mutable? Why is it protected rather than
    private?

    Û∞àø `m_sentinel`, and the other parameters here are mutable because 'getter'
    methods that are const like `CCoinsView::GetCoin()` and
    `CCoinsViewCache::FetchCoin()` can and should modify our cache.

    The only descendant class of CCoinsViewCache is CCoinsViewCacheTest

## [coins: call ClearFlags in CCoinsCacheEntry destructor](https://github.com/bitcoin/bitcoin/pull/28280/commits/1845231c68679a02b8cae6aa227c57d24127a0b2)

Clears flags on `CCoinsCacheEntry()` destruction, this is important since we
will need to remove ourselves (an ability that will be added to `ClearFlags()`
in the next commit...) from the linked list when this CoinsCacheEntry loses its
flags. 

```diff
 struct CCoinsCacheEntry
 {
     // [...]
+    ~CCoinsCacheEntry()
+    {
+        ClearFlags();
+    }
     // [...]
 }
```

## [coins: track flagged cache entries in linked list](https://github.com/bitcoin/bitcoin/pull/28280/commits/e3974c4a4d38c15ae5f9441979ef0775c03d1797)

Adds to `Struct CCoinsCacheEntry` two private attributes:

```diff
+    CoinsCachePair* m_prev{nullptr};
+    CoinsCachePair* m_next{nullptr};
```

    ü™¢ Reminder: A CoinsCachePair is `std::pair<const COutPoint,
    CCoinsCacheEntry>`

which are null-by-default pointers to `CoinCachePair`'s.

which will be used to create a doubly-linked list of flagged entries.

The AddFlags method is modified as follows:

```diff
     inline void AddFlags(uint8_t flags, CoinsCachePair& self, CoinsCachePair& sentinel) noexcept
     {
         // [ The `Assume` line was, in fact, added in an earlier commit but it
         //   did not do much then so we'll look at it here.]
+        Assume(&self.second == this);
+        if (!m_flags && flags) {
+            m_prev = sentinel.second.m_prev;
+            m_next = &sentinel;
+            sentinel.second.m_prev = &self;
+            m_prev->second.m_next = &self;
+        }
         m_flags |= flags;
     }
```




We `Assume` that the `self` argument is actually us:

```cpp
Assume(&self.second == this)
```

    ‚õ±Ô∏è  Question: Why is `self` even being passed around?

    üèà Answer: Because the doubly-linked list contains CoinsCachePair's rather
    than COutPoints, but this begs another question, why does our list consist
    of CoinsCachePair's rather than CCoinsCacheEntry's? The answer may have to
    wait...

`Assume` is basically assert in debug builds, nothing otherwise.

If no flags are set in `m_flags`, **and** we are setting flags in this call,
then this CCoinsCacheEntry is eligible for appending to the beginning of the
doubly-linked list.

We do this by connecting our CCoinsCacheEntry's `m_prev` link to the sentinel's
`m_prev`, and setting our `m_next` to the sentinel. Then, we set the sentinel's
previous to us, and we set our `m_prev`'s next to us.

A new method `CCoinsCacheEntry::SelfRef` is introduced (actually introduced
above, but not useful until now):

```cpp
//! Only use this for initializing the linked list sentinel
inline void SelfRef(CoinsCachePair& self) noexcept
{
    // [ Assume that self is us, set our previous and next to self ]
    Assume(&self.second == this);
    m_prev = &self;
    m_next = &self;
}
```

This is used when CCoinsViewCache initializes:

```cpp
CCoinsViewCache::CCoinsViewCache(CCoinsView* baseIn, bool deterministic) :
    CCoinsViewBacked(baseIn), m_deterministic(deterministic),
    cacheCoins(0, SaltedOutpointHasher(/*deterministic=*/deterministic), CCoinsMap::key_equal{}, &m_cache_coins_memory_resource)
{
    m_sentinel.second.SelfRef(m_sentinel);
}
```

to set up its `m_sentinal` to be self-referential.

`ClearFlags` is modified to remove the `CCoinsCacheEntry` from the linked list:

```diff
     inline void ClearFlags() noexcept
     {
         // [ An optimization? ]
+        if (!m_flags) return;

         // [ Our next's previous (currently us) gets rerouted to our current
         //   previous. ]
+        m_next->second.m_prev = m_prev;

         // [ Our prev's next (currently us) gets rerouted to our current
         //   next. ]
+        m_prev->second.m_next = m_next;
         m_flags = 0;
     }
```

And `CCoinsViewCache` gets a destructor:

```diff
+CCoinsViewCache::~CCoinsViewCache()
+{
+    cacheCoins.clear();
+    Assume(m_sentinel.second.Next() == &m_sentinel);
+}
```

---------

I'm a bit confused by this bit, cacheCoins goes out of scope when
`CCoinsViewCache` gets destroyed, so the cacheCoins element would be destroyed
anyways, right?

 ü•° [Wrong!](https://github.com/bitcoin/bitcoin/pull/28280#discussion_r1699236978)
Because the sentinel is not a part of cacheCoins, when each entry in
`cacheCoins` gets destructed and `CCoinsCacheEntry::ClearFlags()` gets called,
some of them might have an `m_prev` or `m_next` that points to the sentinel, and
if the sentinel gets cleared first we'll have a use-after-free!

Follow-up: Why wouldn't `m_sentinel` being destroyed first be OK since: when
`m_sentinel.second.ClearFlags()` happens, that makes the last (youngest) entry's
`m_next` point to the first (oldest) entry and vice versa, right?

üçø [‚ÄºÔ∏èNo!!](https://github.com/bitcoin/bitcoin/pull/28280#discussion_r1699261464):

            `m_sentinel` does not have m_flags set. So when `m_sentinel` is destroyed it
            doesn't actually remove itself from the list.

----------
