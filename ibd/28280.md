# [#28280](https://github.com/bitcoin/bitcoin/pull/28280) Don't empty dbcache on prune flushes: >30% faster IBD

## [refactor: encapsulate flags access for dirty and fresh checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/0383defd049fa1feb6de7abea259041487ccda1d)

This commit refactors the checks for whether or not a `CCoinsCacheEntry` is fresh and dirty into methods `entry.IsDirty()` and `entry.IsFresh()`. This is in preparation for a future commit that makes the `flags` attribute of a coins cache entry private.

From `src/coins.h`:
```cpp
struct CCoinsCacheEntry
{
    /* ... */
    inline bool IsDirty() const noexcept { return flags & DIRTY; }
    inline bool IsFresh() const noexcept { return flags & FRESH; }
    /* ... */
};
```

and elsewhere:

```diff
 for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {
-    if (it->second.flags & CCoinsCacheEntry::DIRTY) {
+    if (it->second.IsDirty()) {
```

## [refactor: encapsulate flags get access for all other checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/fc3501d14c27a0103650d6054c4027274b18ed4f)

This refactor commit adds a getter method `GetFlags()`:

```cpp
inline unsigned char GetFlags() const noexcept { return flags; }
```

In preparation for making `flags` a private attribute.

## [refactor: encapsulate flags setting with AddFlags and ClearFlags](https://github.com/bitcoin/bitcoin/pull/28280/commits/5907ace1e6cf1c415eeff1467a348468a8a967b0)

This refactor commit adds an `AddFlags()` and a `ClearFlags()` method to enable
making the `flags` attribute of `CCoinsCacheEntry` private.

```cpp
inline void AddFlags(unsigned char flags) noexcept { this->flags |= flags; }
inline void ClearFlags() noexcept
{
    flags = 0;
}
```

A few comments were made about a change in behavior where settings flags equal
to something has been changed to adding flags, e.g.:

```diff
-entry.flags = CCoinsCacheEntry::Dirty
+entry.AddFlags(CCoinsCacheEntry::Dirty)
```

The author and another reviewer suggested that in all instances where a
flag-setting becomes a flag-adding the entry is freshly constructed and there
is no change in behavior, let's take a look:

```cpp
CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {
    // [...]
    // [ At this point we did not have the `Coin` in our cache, so we fell
    //   back on the CCoinsViewDB and found it and stored it in `Coin tmp`. ]

    // [ We are emplacing the coin into our cache... ]
    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;
    if (ret->second.coin.IsSpent()) {
        // The parent only has an empty entry for this outpoint; we can consider our
        // version as fresh.
        ret->second.AddFlags(CCoinsCacheEntry::FRESH);
        // [ used to be: ret->second.flags = CCoinsCacheEntry::FRESH);
        //   Since the CCoinsCacheEntry was constructed in place as part of the
        //   emplace and piecewise_construct above, we know that its flags are
        //   clear and adding flags == setting flags. ]
    }
    // [...]
}
```

Some background for the next example: when a CCoinsViewCache::Flush() happens,
the backing view of the cache (`view.base`) gets called upon to perform a
`BatchWrite`.

The only time when a `CCoinsViewCache` is the backing view of another
`CCoinsView` is:

Whenever `ChainState::ConnectTip` happens, we create a temporary
`CCoinsViewCache` with the canonical chaintip `CCoinsViewCache` as its parent,
we connect the new block to the temporary Coin View, and then
`CCoinsViewCache::Flush()` it, which calls the parent cache's
`CCoinsViewCache::BatchWrite`.

```cpp
bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn, bool erase) {
    // [ mapCoins is the child's CCoinMap, these are the coins that are getting
    //   flushed to the parent. CCoinsMap consists of {COutpoint,
    //   CCoinsCacheEntry} ] 
    for (CCoinsMap::iterator it = mapCoins.begin();
            it != mapCoins.end();
            it = erase ? mapCoins.erase(it) : std::next(it)) {
        CCoinsMap::iterator itUs = cacheCoins.find(it->first);
        // [ If the parent cache (us) does not have the entry that is being
        //   flushed... ]
        if (itUs == cacheCoins.end()) {
            // The parent cache does not have an entry, while the child cache does.
            // We can ignore it if it's both spent and FRESH in the child
            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {
                // Create the coin in the parent cache, move the data up
                // and mark it as dirty.
                CCoinsCacheEntry& entry = cacheCoins[it->first];
                // [ Since the cacheCoins.find above returned the end iterator,
                //   our view's CCoinsMap cacheCoins does not have the given
                //   COutPoint, the above subscript access inserts a default
                //   constructed value into the CCoinsMap, and a default
                //   constructed CCoinsCacheEntry has blank flags by default. ]

                // [...]
                entry.flags = CCoinsCacheEntry::DIRTY;
                // [ Since the CCoinsCacheEntry is freshly constructed, its
                //   flags are blank, and setting is equal to adding. ]

                // We can mark it FRESH in the parent if it was FRESH in the child
                // Otherwise it might have just been flushed from the parent's cache
                // and already exist in the grandparent
                if (it->second.flags & CCoinsCacheEntry::FRESH) {
                    entry.flags |= CCoinsCacheEntry::FRESH;
                }
            }
        }
        // [...]
    }
    // [...]
}
```

Looks good to me!

## [refactor: disallow setting flags in CCoinsCacheEntry constructors](https://github.com/bitcoin/bitcoin/pull/28280/commits/5b18c53b5ae5215bdd1e960a65e45f740ce14129)
