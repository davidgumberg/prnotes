# [#28280](https://github.com/bitcoin/bitcoin/pull/28280) Don't empty dbcache on prune flushes: >30% faster IBD

## [refactor: encapsulate flags access for dirty and fresh checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/0383defd049fa1feb6de7abea259041487ccda1d)

This commit refactors the checks for whether or not a `CCoinsCacheEntry` is fresh and dirty into methods `entry.IsDirty()` and `entry.IsFresh()`. This is in preparation for a future commit that makes the `flags` attribute of a coins cache entry private.

From `src/coins.h`:
```cpp
struct CCoinsCacheEntry
{
    /* ... */
    inline bool IsDirty() const noexcept { return flags & DIRTY; }
    inline bool IsFresh() const noexcept { return flags & FRESH; }
    /* ... */
};
```

and elsewhere:

```diff
 for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {
-    if (it->second.flags & CCoinsCacheEntry::DIRTY) {
+    if (it->second.IsDirty()) {
```

## [refactor: encapsulate flags get access for all other checks](https://github.com/bitcoin/bitcoin/pull/28280/commits/fc3501d14c27a0103650d6054c4027274b18ed4f)

This refactor commit adds a getter method `GetFlags()`:

```cpp
inline unsigned char GetFlags() const noexcept { return flags; }
```

In preparation for making `flags` a private attribute.

## [refactor: encapsulate flags setting with AddFlags and ClearFlags](https://github.com/bitcoin/bitcoin/pull/28280/commits/5907ace1e6cf1c415eeff1467a348468a8a967b0)

This refactor commit adds an `AddFlags()` and a `ClearFlags()` method (and
refactors existing code to use these methods) to enable making the `flags`
attribute of `CCoinsCacheEntry` private in a later commit.

```cpp
inline void AddFlags(unsigned char flags) noexcept { this->flags |= flags; }
inline void ClearFlags() noexcept
{
    flags = 0;
}
```

It also replaces manual setting and adding of CCoinsCacheEntry flags with

Two reviewers asked about whether or not this commit might be a change in
behavior where we previously setting flags and are now adding flags, e.g.:

```diff
-entry.flags = CCoinsCacheEntry::Dirty
+entry.AddFlags(CCoinsCacheEntry::Dirty)
```

The author and another reviewer suggested that in all instances where a
flag-setting (`=`) becomes a flag-adding (`+=`) the entry is freshly constructed and there
is no change in behavior, let's take a look:

First example:

When `CCoinsViewCache::FetchCoin` doesn't find the outpoint in our cache, and
has to fall back to grabbing the coin from the backing view, we add the coin
from the backing view to the cache:

```cpp
CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {
    // [...]
    // [ At this point we did not have the `Coin` in our cache, so we fell //
    //   back on the backing CCoinsView and found it and stored it in `Coin tmp`. ]

    // [ We are emplacing the coin into our cache... ]
    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;
    if (ret->second.coin.IsSpent()) {
        // The parent only has an empty entry for this outpoint; we can consider our
        // version as fresh.
        ret->second.AddFlags(CCoinsCacheEntry::FRESH);
        // [ used to be: ret->second.flags = CCoinsCacheEntry::FRESH);
        //   Since the CCoinsCacheEntry that is the value of `ret` was
        //   constructed in place as part of the emplace and piecewise_construct
        //   above, we know that its flags are clear and adding flags == setting
        //   flags. ]
    }
    // [...]
}
```

Second example:

The following comes from `CCoinsViewCache::BatchWrite()`. A CCoinsView's
BatchWrite method is called whenever the CCoinsViewCache that it is backing
decides to `Flush`. Repeating the same thing from the other direction: When a
CCoinsViewCache::Flush() happens, the backing view of the cache (`view.base`)
gets called upon to perform a `BatchWrite`.

The only time when a `CCoinsViewCache` is the backing view of another
`CCoinsView` is:

Whenever `ChainState::ConnectTip` happens, we create a temporary
`CCoinsViewCache` with the canonical chaintip `CCoinsViewCache` as its parent,
we connect the new block to the temporary Coin View, and then
`CCoinsViewCache::Flush()` it, which calls the parent cache's
`CCoinsViewCache::BatchWrite`.

```cpp
bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn, bool erase) {
    // [ mapCoins is the child's CCoinMap, these are the coins that are getting
    //   flushed to the parent. CCoinsMap consists of {COutpoint,
    //   CCoinsCacheEntry} ] 
    for (CCoinsMap::iterator it = mapCoins.begin();
            it != mapCoins.end();
            it = erase ? mapCoins.erase(it) : std::next(it)) {
        CCoinsMap::iterator itUs = cacheCoins.find(it->first);
        // [ If the parent cache (us) does not have the entry that is being
        //   flushed... ]
        if (itUs == cacheCoins.end()) {
            // The parent cache does not have an entry, while the child cache does.
            // We can ignore it if it's both spent and FRESH in the child
            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {
                // Create the coin in the parent cache, move the data up
                // and mark it as dirty.
                CCoinsCacheEntry& entry = cacheCoins[it->first];
                // [ Since the cacheCoins.find above returned the end iterator,
                //   our view's CCoinsMap cacheCoins does not have the given
                //   COutPoint, the above subscript access inserts a default
                //   constructed value into the CCoinsMap, and a default
                //   constructed CCoinsCacheEntry has blank flags by default. ]

                // [...]
           // [ entry.flags = CCoinsCacheEntry::DIRTY; ]
                entry.AddFlags(CCoinsCacheEntry::DIRTY);

                // [ Since the CCoinsCacheEntry is freshly constructed, its
                //   flags are blank, and setting is equal to adding. ]

                // We can mark it FRESH in the parent if it was FRESH in the child
                // Otherwise it might have just been flushed from the parent's cache
                // and already exist in the grandparent
                if (it->second.IsFresh()) {
               // [ entry.flags |= CCoinsCacheEntry::FRESH;
                    entry.AddFlags(CCoinsCacheEntry::FRESH);
                }
            }
        }
        // [...]
    }
    // [...]
}
```

Looks good to me!

## [refactor: disallow setting flags in CCoinsCacheEntry constructors](https://github.com/bitcoin/bitcoin/pull/28280/commits/5b18c53b5ae5215bdd1e960a65e45f740ce14129)

This commit "disallow[s] setting flags in CCoinsCacheEntry constructors." It
also moves default initialization of flags to the member instead of the
`CCoinsCacheEntry`'s constructor.

`src/coins.h`:
```diff
 struct CCoinsCacheEntry
 {
     Coin coin; // The actual cached data.
-    unsigned char flags;
+    unsigned char flags{0};

-    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}
-    CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}
+    CCoinsCacheEntry() noexcept = default;
+    explicit CCoinsCacheEntry(Coin&& coin_) noexcept : coin(std::move(coin_)) {}
 }
```

The only place where flag initialization is used is in
`CCoinsViewCache::EmplaceCoinInternalDANGER()`, which is used to emplace coins
during `assumeutxo` snapshot loading:

```cpp
void CCoinsViewCache::EmplaceCoinInternalDANGER(COutPoint&& outpoint, Coin&& coin) {
    cachedCoinsUsage += coin.DynamicMemoryUsage();
    cacheCoins.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(std::move(outpoint)),
        std::forward_as_tuple(std::move(coin), CCoinsCacheEntry::DIRTY)); // [ <-- The line in question ]
}
```

This commit changes this to:

```cpp
void CCoinsViewCache::EmplaceCoinInternalDANGER(COutPoint&& outpoint, Coin&& coin) {
    cachedCoinsUsage += coin.DynamicMemoryUsage();
    // [ Capture the tuple returned by std::unordered_map::emplace with
    //   the iterator and a boolean indicating if the key was unique and
    //   insertion was succesful. ]
    auto [it, inserted] = cacheCoins.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(std::move(outpoint)),
        std::forward_as_tuple(std::move(coin))); // [ <-- No longer construct the CoinsCacheEntry with a flag argument ]
        
    // [ This preserves the old behavior since if the entry was not emplaced,
    //   the flags were not modified. ]
    if (inserted) {
        it->second.AddFlags(CCoinsCacheEntry::DIRTY);
    }
}
```

󰄹

## [refactor: move flags to private uint8_t and rename to m_flags](https://github.com/bitcoin/bitcoin/pull/28280/commits/9da4e90c1d4bb10d981335e183bd0605daa8b523)

Makes flags private, `uint8_t` instead of `unsigned char` and renames `flags ->
m_flags`:

```diff
 struct CCoinsCacheEntry 
 {
+private:
+     uint8_t m_flags{0};
+
+public:
     Coin coin; // The actual cached data.
-    unsigned char flags{0};
 }
```

## [refactor: add CoinsCachePair alias](https://github.com/bitcoin/bitcoin/pull/28280/commits/a1444346464cff778f317d5d89eccfa0c9b8759e)

Refactor only, `CoinsCachePair` will probably come up in later commits..

`src/coins.h`
```diff
+struct CCoinsCacheEntry;
+using CoinsCachePair = std::pair<const COutPoint, CCoinsCacheEntry>;
+
 /**
  * A Coin in one level of the coins database caching hierarchy.
  *
 @@ -155,8 +158,8 @@ using CCoinsMap = std::unordered_map<COutPoint,
                                      CCoinsCacheEntry,
                                      SaltedOutpointHasher,
                                      std::equal_to<COutPoint>,
-                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,
-                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4>>;
+                                     PoolAllocator<CoinsCachePair,
+                                                   sizeof(CoinsCachePair) + sizeof(void*) * 4>>;
```

## [refactor: require self and sentinel parameters for AddFlags](https://github.com/bitcoin/bitcoin/pull/28280/commits/d53f9cd703ae326446b018e3225c577d221c1e6d)

Adds a parameter `CCoinsCache m_sentinel` to `CCoinsViewCache` that will be used
in a later commit to indicate the beginning entry of a new data structure that
consists of a doubly-linked list of CoinsCachePair's. This commit seems like
semantically it is not atomic, so let's reserve further investigation...

### Sentinels

[Proposed](https://github.com/bitcoin/bitcoin/pull/28280/files#r1667488129) by a
reviewer as an improvement to an earlier draft's linked list design:

A sentinel entry is a dummy entry that closes the loop of the doubly linked list
of flagged entries we're working towards, it's `m_prev` is the youngest entry,
and it's `m_next` is the oldest entry, and it should not contain any
information.`

```
          m_next        m_next       m_next
+--+      +-->--+     +--->---+     +->-+  
|  v      |     v     |       v     |   |  
|  +------+     +-----+       +-----++  v  
^  |Entry |     |Entry|       |Entry |  |  
|  +------+     +------       +-+----+  |  
|  |    ^  m_prev|    ^  m_prev |   ^   v  
|  |    |        |    |         |   |   |
^  v    +----<---+    +----<----+   |   |  
|  |________                        |   |
|  | m_prev|                        |   |  
|  +------->>-------->>------->>----+   |  
|                                       |
+----------<<--------<<-------<<--------+
```


```diff
 class CCoinsViewCache : public CCoinsViewBacked
 {
 private:
     const bool m_deterministic;

 protected:
     /**
     * Make mutable so that we can "fill the cache" even from Get-methods
     * declared as "const".
     */
     mutable uint256 hashBlock;
     mutable CCoinsMapMemoryResource m_cache_coins_memory_resource{};
+    /* The starting sentinel of the flagged entry circular doubly linked list. */
+    mutable CoinsCachePair m_sentinel;
     mutable CCoinMap cacheCoins;

     /* Cached dynamic memory usage for the inner Coin objects. */
     mutable size_t cachedCoinsUsage{0};

     // [...]
 }
```

    🌔 Question: Why is `m_sentinal` mutable? Why is it protected rather than
    private?

    󰈿 `m_sentinel`, and the other parameters here are mutable because 'getter'
    methods that are const like `CCoinsView::GetCoin()` and
    `CCoinsViewCache::FetchCoin()` can and should modify our cache.

    The only descendant class of CCoinsViewCache is CCoinsViewCacheTest

## [coins: call ClearFlags in CCoinsCacheEntry destructor](https://github.com/bitcoin/bitcoin/pull/28280/commits/1845231c68679a02b8cae6aa227c57d24127a0b2)

Clears flags on `CCoinsCacheEntry()` destruction, this is important since we
will need to remove ourselves (an ability that will be added to `ClearFlags()`
in the next commit...) from the linked list when this CoinsCacheEntry loses its
flags. 

```diff
 struct CCoinsCacheEntry
 {
     // [...]
+    ~CCoinsCacheEntry()
+    {
+        ClearFlags();
+    }
     // [...]
 }
```

## [coins: track flagged cache entries in linked list](https://github.com/bitcoin/bitcoin/pull/28280/commits/e3974c4a4d38c15ae5f9441979ef0775c03d1797)

Adds to `Struct CCoinsCacheEntry` two private attributes:

```diff
+    CoinsCachePair* m_prev{nullptr};
+    CoinsCachePair* m_next{nullptr};
```

    🪢 Reminder: A CoinsCachePair is `std::pair<const COutPoint, CCoinsCacheEntry>`

which are null-by-default pointers to `CoinCachePair`'s.

which will be used to create a doubly-linked list of flagged entries.

The AddFlags method is modified as follows:

```diff
     inline void AddFlags(uint8_t flags, CoinsCachePair& self, CoinsCachePair& sentinel) noexcept
     {
         // [ The `Assume` line was, in fact, added in an earlier commit but it
         //   did not do much then so we'll look at it here.]
+        Assume(&self.second == this);
+        if (!m_flags && flags) {
+            m_prev = sentinel.second.m_prev;
+            m_next = &sentinel;
+            sentinel.second.m_prev = &self;
+            m_prev->second.m_next = &self;
+        }
         m_flags |= flags;
     }
```




We `Assume` that the `self` argument is actually us:

```cpp
Assume(&self.second == this)
```

    ⛱️  Question: Why is `self` even being passed around?

    🏈 Answer: Because the doubly-linked list contains CoinsCachePair's rather
    than COutPoints, but this begs another question, why does our list consist
    of CoinsCachePair's rather than CCoinsCacheEntry's? The answer may have to
    wait...

`Assume` is basically assert in debug builds, nothing otherwise.

If no flags are set in `m_flags`, **and** we are setting flags in this call,
then this CCoinsCacheEntry is eligible for appending to the beginning of the
doubly-linked list.

We do this by connecting our CCoinsCacheEntry's `m_prev` link to the sentinel's
`m_prev`, and setting our `m_next` to the sentinel. Then, we set the sentinel's
previous to us, and we set our `m_prev`'s next to us.

A new method `CCoinsCacheEntry::SelfRef` is introduced (actually introduced
above, but not useful until now):

```cpp
//! Only use this for initializing the linked list sentinel
inline void SelfRef(CoinsCachePair& self) noexcept
{
    // [ Assume that self is us, set our previous and next to self ]
    Assume(&self.second == this);
    m_prev = &self;
    m_next = &self;
}
```

This is used when CCoinsViewCache initializes:

```cpp
CCoinsViewCache::CCoinsViewCache(CCoinsView* baseIn, bool deterministic) :
    CCoinsViewBacked(baseIn), m_deterministic(deterministic),
    cacheCoins(0, SaltedOutpointHasher(/*deterministic=*/deterministic), CCoinsMap::key_equal{}, &m_cache_coins_memory_resource)
{
    m_sentinel.second.SelfRef(m_sentinel);
}
```

to set up its `m_sentinal` to be self-referential.

`ClearFlags` is modified to remove the `CCoinsCacheEntry` from the linked list:

```diff
     inline void ClearFlags() noexcept
     {
         // [ An optimization? ]
+        if (!m_flags) return;

         // [ Our next's previous (currently us) gets rerouted to our current
         //   previous. ]
+        m_next->second.m_prev = m_prev;

         // [ Our prev's next (currently us) gets rerouted to our current
         //   next. ]
+        m_prev->second.m_next = m_next;
         m_flags = 0;
     }
```

And `CCoinsViewCache` gets a destructor:

```diff
+CCoinsViewCache::~CCoinsViewCache()
+{
+    cacheCoins.clear();
+    Assume(m_sentinel.second.Next() == &m_sentinel);
+}
```

---------

I'm a bit confused by this bit, cacheCoins goes out of scope when
`CCoinsViewCache` gets destroyed, so the cacheCoins element would be destroyed
anyways, right?

 🥡 [Wrong!](https://github.com/bitcoin/bitcoin/pull/28280#discussion_r1699236978)
Because the sentinel is not a part of cacheCoins, when each entry in
`cacheCoins` gets destructed and `CCoinsCacheEntry::ClearFlags()` gets called,
some of them might have an `m_prev` or `m_next` that points to the sentinel, and
if the sentinel gets cleared first we'll have a use-after-free!

Follow-up: Why wouldn't `m_sentinel` being destroyed first be OK since: when
`m_sentinel.second.ClearFlags()` happens, that makes the last (youngest) entry's
`m_next` point to the first (oldest) entry and vice versa, right?

🍿 [‼️No!!](https://github.com/bitcoin/bitcoin/pull/28280#discussion_r1699261464):

            `m_sentinel` does not have m_flags set. So when `m_sentinel` is destroyed it
            doesn't actually remove itself from the list.

----------

## [test: add cache entry linked list tests](https://github.com/bitcoin/bitcoin/pull/28280/commits/9280c45032dff44d0d4c470e70d5de1e20984168)

Adds unit tests for the new linked list behavior. The author has recently added
a `Prev()` method that does not have coverage in this version of the PR, they
have said that they will add it in a follow-up.

<details>

<summary>Annotated CoinsCachePair Unit Tests</summary>

`src/test/coinscachepair_tests.cpp`:
```cpp
#include <coins.h>

#include <boost/test/unit_test.hpp>

#include <list>

BOOST_AUTO_TEST_SUITE(coinscachepair_tests)

static constexpr auto NUM_NODES{4};

// [ Helper function for the test cases below that generates NUM_NODES many
//   CoinsCachePairs that are flagged. ]
std::list<CoinsCachePair> CreatePairs(CoinsCachePair& sentinel)
{
    std::list<CoinsCachePair> nodes;
    for (auto i{0}; i < NUM_NODES; ++i) {
        // [ Construct a default CoinsCachePair in place at the back of the list ]
        nodes.emplace_back();
/else
        // [ Get the last iterator in the list. Weirdly enough, C++ seems to not
        //   have a method for doing this, std::list::back returns a reference
        //   to the final item and std::list::rbegin() gets an iterator to the
        //   last item, but you have to iterate over the list in the opposite
        //   direction.]
        auto node{std::prev(nodes.end())};
        // [ Add flags to the node, this should also result in it becoming
        //   connected to the sentinel. ]
        node->second.AddFlags(CCoinsCacheEntry::DIRTY, *node, sentinel);

        // [ The node should have the dirty flag. ]
        BOOST_CHECK_EQUAL(node->second.GetFlags(), CCoinsCacheEntry::DIRTY);
        // [ The newest node's next should always be the sentinel. ] 
        BOOST_CHECK_EQUAL(node->second.Next(), &sentinel); 

        // [ if we have more than 1 node here, our prev's next should be us. ]
        if (i > 0) {
            BOOST_CHECK_EQUAL(std::prev(node)->second.Next(), &(*node));
        }
  /**   [ nit: could add:
   *    else {
   *        BOOST_CHECK_EQUAL(sentinel.second.Next(), &(*node));
   *    }
   */
    }
    return nodes;
}

BOOST_AUTO_TEST_CASE(linked_list_iteration)
{
    CoinsCachePair sentinel;
    // [ Sentinel self referencing normally happens in the CCoinsViewCache
    //    constructor. ]
    sentinel.second.SelfRef(sentinel);
    // [ Uses our above helper to generate 4 DIRTY CoinsCachePair's that are
    //   connected to the sentinel. ]
    auto nodes{CreatePairs(sentinel)};

    // Check iterating through pairs is identical to iterating through a list

    // [ The sentinel's next is our oldest/first node. ]
    auto node{sentinel.second.Next()};

    // [ We use the for loop iterate through the list with expected]
    for (const auto& expected : nodes) {
        // [ Check that expected == node.]
        BOOST_CHECK_EQUAL(&expected, node);
        // [ We use the linked list stucture to iterate  through the list with
        //   `node` ]
        node = node->second.Next();
    }

    // [ The final/youngest entry's m_next is the sentinel. ]
    BOOST_CHECK_EQUAL(node, &sentinel);

    // Check iterating through pairs is identical to iterating through a list
    // Clear the flags during iteration

    // [ node is now a pointer to the first/oldest CoinsCachePair.. ]
    node = sentinel.second.Next();
    // [ iterating through the nodes list using a for loop...]
    for (const auto& expected : nodes) {
        // [ check that
        BOOST_CHECK_EQUAL(&expected, node);

        // [ when we clear our node's flags it get's deleted from the list,
        //   so the node prior to us now has an m_next pointing to our m_next,
        //   and the node after us now has an m_prev pointing to our m_prev. ]
        node->second.ClearFlags();

        // [ The strangeness I discuss at the bottom is why we can do this bit
        //   of nastiness of getting our node's next even though it's been
        //   cleared. ]
        node = node->second.Next();
    }

    // [ we ended with the youngest/last entry's who's next-> was the sentinel,
    //   so node should now `== &sentinel`.
    BOOST_CHECK_EQUAL(node, &sentinel);
    // Check that sentinel's next is itself
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &sentinel);

    // Delete the nodes from the list to make sure there are no dangling pointers
    for (auto it{nodes.begin()}; it != nodes.end(); it = nodes.erase(it)) {
        BOOST_CHECK_EQUAL(it->second.GetFlags(), 0);
    }
}

BOOST_AUTO_TEST_CASE(linked_list_iterate_erase)
{
    CoinsCachePair sentinel;
    sentinel.second.SelfRef(sentinel);
    auto nodes{CreatePairs(sentinel)};

    // Check iterating through pairs is identical to iterating through a list
    // Erase the nodes as we iterate through, but don't clear flags
    // The flags will be cleared by the CCoinsCacheEntry's destructor
    auto node{sentinel.second.Next()};
    for (auto expected{nodes.begin()}; expected != nodes.end(); expected = nodes.erase(expected)) {
        // [ similar to the test case above, but we are testing the destructor
        //   of CCoinsCacheEntry ] 
        BOOST_CHECK_EQUAL(&(*expected), node);
        node = node->second.Next();
    }
    // [ left with the sentinel.... ]
    BOOST_CHECK_EQUAL(node, &sentinel);

    // Check that sentinel's next is itself
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &sentinel);
}

BOOST_AUTO_TEST_CASE(linked_list_random_deletion)
{
    CoinsCachePair sentinel;
    sentinel.second.SelfRef(sentinel);
    auto nodes{CreatePairs(sentinel)};

    // Create linked list sentinel->n1->n2->n3->n4->sentinel
    auto n1{nodes.begin()};
    auto n2{std::next(n1)};
    auto n3{std::next(n2)};
    auto n4{std::next(n3)};

    // Delete n2
    // sentinel->n1->n3->n4->sentinel
    nodes.erase(n2);
    // Check that n1 now points to n3, and n3 still points to n4
    // Also check that flags were not altered
    BOOST_CHECK_EQUAL(n1->second.GetFlags(), CCoinsCacheEntry::DIRTY);
    BOOST_CHECK_EQUAL(n1->second.Next(), &(*n3));
    BOOST_CHECK_EQUAL(n3->second.GetFlags(), CCoinsCacheEntry::DIRTY);
    BOOST_CHECK_EQUAL(n3->second.Next(), &(*n4));

    // Delete n1
    // sentinel->n3->n4->sentinel
    nodes.erase(n1);
    // Check that sentinel now points to n3, and n3 still points to n4
    // Also check that flags were not altered
    BOOST_CHECK_EQUAL(n3->second.GetFlags(), CCoinsCacheEntry::DIRTY);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &(*n3));
    BOOST_CHECK_EQUAL(n3->second.Next(), &(*n4));

    // Delete n4
    // sentinel->n3->sentinel
    nodes.erase(n4);
    // Check that sentinel still points to n3, and n3 points to sentinel
    // Also check that flags were not altered
    BOOST_CHECK_EQUAL(n3->second.GetFlags(), CCoinsCacheEntry::DIRTY);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &(*n3));
    BOOST_CHECK_EQUAL(n3->second.Next(), &sentinel);

    // Delete n3
    // sentinel->sentinel
    nodes.erase(n3);
    // Check that sentinel's next now points to itself
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &sentinel);
}

BOOST_AUTO_TEST_CASE(linked_list_add_flags)
{
    CoinsCachePair sentinel;
    sentinel.second.SelfRef(sentinel);
    CoinsCachePair n1;
    CoinsCachePair n2;

    // Check that adding 0 flag has no effect
    n1.second.AddFlags(0, n1, sentinel);
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), 0);
    BOOST_CHECK_EQUAL(n1.second.Next(), nullptr);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &sentinel);

    // Check that adding DIRTY flag inserts it into linked list and sets flags
    n1.second.AddFlags(CCoinsCacheEntry::DIRTY, n1, sentinel);
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), CCoinsCacheEntry::DIRTY);
    BOOST_CHECK_EQUAL(n1.second.Next(), &sentinel);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &n1);

    // Check that adding FRESH flag on new node inserts it after n1
    n2.second.AddFlags(CCoinsCacheEntry::FRESH, n2, sentinel);
    BOOST_CHECK_EQUAL(n2.second.GetFlags(), CCoinsCacheEntry::FRESH);
    BOOST_CHECK_EQUAL(n2.second.Next(), &sentinel);
    BOOST_CHECK_EQUAL(n1.second.Next(), &n2);

    // Check that adding 0 flag has no effect, and doesn't change position
    n1.second.AddFlags(0, n1, sentinel);
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), CCoinsCacheEntry::DIRTY);
    BOOST_CHECK_EQUAL(n1.second.Next(), &n2);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &n1);
    BOOST_CHECK_EQUAL(n2.second.Next(), &sentinel);

    // Check that we can add extra flags, but they don't change our position
    // [ AddFlags has a check to make sure this entry isn't already in the list
    //   before setting the m_next and m_prev's, if that wasn't the case, this
    //   n1's next would be the sentinel and it's previous would by n2, but
    //   problematically, n2's previous would still be n1 ]
    n1.second.AddFlags(CCoinsCacheEntry::FRESH, n1, sentinel);
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), CCoinsCacheEntry::DIRTY | CCoinsCacheEntry::FRESH);
    BOOST_CHECK_EQUAL(n1.second.Next(), &n2);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &n1);
    BOOST_CHECK_EQUAL(n2.second.Next(), &sentinel);

    // Check that we can clear flags then re-add them
    n1.second.ClearFlags();
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), 0);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &n2);

    // Check that calling `ClearFlags` with 0 flags has no effect
    n1.second.ClearFlags();
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), 0);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &n2);

    // Adding 0 still has no effect
    n1.second.AddFlags(0, n1, sentinel);
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), 0);
    BOOST_CHECK_EQUAL(sentinel.second.Next(), &n2);

    // But adding DIRTY re-inserts it after n2
    n1.second.AddFlags(CCoinsCacheEntry::DIRTY, n1, sentinel);
    BOOST_CHECK_EQUAL(n1.second.GetFlags(), CCoinsCacheEntry::DIRTY);
    BOOST_CHECK_EQUAL(n2.second.Next(), &n1);
    BOOST_CHECK_EQUAL(n1.second.Next(), &sentinel);
}

BOOST_AUTO_TEST_SUITE_END()
```

</details>

## Key Takeaways / Questions

- I'm nervous about the prospect of a dangling reference if an entry has it's
  flags cleared, then it's neighbors have their flags cleared. Now, if someone
  calls `entry.Next()` or `entry.Prev()` on an entry who was cleared before it's
  neighbors that have now also been destroyed, we have a dangling reference.
    - This has been addressed in a recent rebase, by setting 
