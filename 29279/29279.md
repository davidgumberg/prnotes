# [29729](https://github.com/bitcoin/bitcoin/pull/29279) Check disconnect due to lack of desirable service flags
All code comments in `[]` are my own

## support disconnect waiting for `add_outbound_p2p_connection`

### Notes
- Adds a boolean parameter `wait_for_disconnect` that defaults to false
  for `add_outbound_p2p_connection`. If set to true, `add_outbound_p2p_connection`
  waits until the connection is closed to return. This is useful for testing outbound
  connections that we expect to fail.
- mzumsande suggests changing this to an `expect_success` parameter would make
  this parameter more flexible since in some scenarios we expect the connection
  to close before a version message. For example, during the v2 transport handshake

### Annotated
```python
def add_outbound_p2p_connection(self, p2p_conn, *, wait_for_verack=True, wait_for_disconnect=False, p2p_idx, connection_type="outbound-full-relay", supports_v2_p2p=None, advertise_v2_p2p=None, **kwargs):
    # [ This commit reuses the feeler connection logic ]
    if connection_type == "feeler" or wait_for_disconnect:
        # [ Wait for the peer to receive a version message ] 
        # feeler connections are closed as soon as the node receives a `version` message
        p2p_conn.wait_until(lambda: p2p_conn.message_count["version"] == 1, check_connected=False)

        # [ Wait for the peer to be disconnected ]
        p2p_conn.wait_until(lambda: not p2p_conn.is_connected, check_connected=False)
```

## [Check Disconnect Due to Lack of Desirable Service Flags](https://github.com/bitcoin/bitcoin/commit/b6c7ae6bde48babea1ceb3820e522f841223d1d3)
### Notes on desirable service flags
- We only care about the service flags of full outbound relay, blocks-only relay,
  and get-addr connections, not inbound, manual or feeler connections.
- `DesirableServiceFlags`:
    - Always `NODE_WITNESS`
    - If our peer advertises `NODE_NETWORK_LIMITED` ('pruned node') **AND** we are close
      enough (144 blocks) to our node's best guess (`ApproximateBestBlockDepth()`)
      of the depth of the best block: then we desire `NODE_NETWORK_LIMITED`
      ```cpp
      if (services & NODE_NETWORK_LIMITED) {
        if (ApproximateBestBlockDepth() < NODE_NETWORK_LIMITED_ALLOW_CONN_BLOCKS) { // <- 144
        return ServiceFlags(NODE_NETWORK_LIMITED | NODE_WITNESS);
      ```
    - Otherwise, we are in an IBD-like situation and want a 'full node' peer:
      ```cpp
      return ServiceFlags(NODE_NETWORK_LIMITED | NODE_WITNESS);
      ```

### Code covered in this test
<details>

<summary>Annotated Code</summary>

- From `net_processing.cpp`: [`PeerManagerImpl::ProcessMessage`](https://github.com/bitcoin/bitcoin/blob/5f3a0574c45477288bc678b15f24940486084576/src/net_processing.cpp#L3384-L3389)
```cpp
void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, DataStream& vRecv,
                                     const std::chrono::microseconds time_received,
                                     const std::atomic<bool>& interruptMsgProc)
    if (msg_type == NetMsgType::VERSION) {
        int64_t nTime;
        ServiceFlags nServices;
        int nVersion;

        // [ Unserialize the version (4 bytes), services(8), and timestamp(8) of
        //   the version message ] 
        vRecv >> nVersion >> Using<CustomUintFormatter<8>>(nServices) >> nTime;

        // [ If we expect good service flags from a peer and they don't have them
        //   log it and evict them ]
        if (pfrom.ExpectServicesFromConn() && !HasAllDesirableServiceFlags(nServices))
        {
            LogPrint(BCLog::NET, "peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\n", pfrom.GetId(), nServices, GetDesirableServiceFlags(nServices));
            pfrom.fDisconnect = true;
            return;
        }

/** [ We only expect our desirable service flags to be satisfied by
 *    Fully relay outbound, block only relay, and addr_fetch peers.
 *  ]
 */
bool ExpectServicesFromConn() const {
    switch (m_conn_type) {
        case ConnectionType::INBOUND:
        case ConnectionType::MANUAL:
        case ConnectionType::FEELER:
            return false;
        case ConnectionType::OUTBOUND_FULL_RELAY:
        case ConnectionType::BLOCK_RELAY:
        case ConnectionType::ADDR_FETCH:
            return true;
    } // no default case, so the compiler can warn about missing cases
    // [ ^^^ the lack of a default case above is a really neat trick ]

    assert(false);
}

// [ GetDesirableServiceFlags(services) == services ]
bool PeerManagerImpl::HasAllDesirableServiceFlags(ServiceFlags services) const
{
    // Shortcut for (services & GetDesirableServiceFlags(services)) == GetDesirableServiceFlags(services)
    return !(GetDesirableServiceFlags(services) & (~services));
}

/** Window, in blocks, for connecting to NODE_NETWORK_LIMITED peers */
static const unsigned int NODE_NETWORK_LIMITED_ALLOW_CONN_BLOCKS = 144;

/** [ We always want the NODE_WITNESS service flag.
 *    If or peer sets `NODE_NETWORK_LIMITED` and we are far enough away from IBD,
 *    (144 blocks off our guess of the best chain), we also desire the
 *    `NODE_NETWORK_LIMITED` flag. Otherwise, we want a peer with the
 *    full `NODE_NETWORK` flag set.
 *  ]
 */
ServiceFlags PeerManagerImpl::GetDesirableServiceFlags(ServiceFlags services) const
{
    // [ NODE_NETWORK_LIMITED flag is set by prune nodes ]
    if (services & NODE_NETWORK_LIMITED) {
        // [ `ApproximateBestBlockDepth()` estimates how many blocks we are from the best chain ]
             
        // Limited peers are desirable when we are close to the tip.
        if (ApproximateBestBlockDepth() < NODE_NETWORK_LIMITED_ALLOW_CONN_BLOCKS) {
            return ServiceFlags(NODE_NETWORK_LIMITED | NODE_WITNESS);
        }
    }
    // [ We are more than 144 blocks from the best tip, this is an IBD-like situation,
    //   and we don't want pruned node connections. ]
    return ServiceFlags(NODE_NETWORK | NODE_WITNESS);
}
```
</details>


